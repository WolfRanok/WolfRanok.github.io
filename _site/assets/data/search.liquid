[
  
  {
    "title"    : "基于svm实现的屏幕翻译项目解析",
    "category" : "",
    "tags"     : " 人工智能, 计算机视觉, python, 机器学习, 爬虫",
    "url"      : "/tranlate",
    "date"     : "February 19, 2023",
    "excerpt"  : "\n  不知不觉间，人工智能慢慢开始走进千家万户。无人驾驶、AI绘图、语音识别、AI聊天都是人工智能的领域。我作为一个智能的学生已经被迷得不行了，在这份热爱的支持下我完成了这份项目。虽然我的项目与当今智能技术无法比拟，但是其中运用到的机器学习模型（如SVM分类器）足以能够让我的项目归类到人工智能。\n\n\n目录\n\n  目录\n  前言\n  项目总目标\n  正文\n    \n      数据收集与数据清洗\n        \n          为什么要收集数据？\n          数据收集\n    ...",
  "content"  : "\n  不知不觉间，人工智能慢慢开始走进千家万户。无人驾驶、AI绘图、语音识别、AI聊天都是人工智能的领域。我作为一个智能的学生已经被迷得不行了，在这份热爱的支持下我完成了这份项目。虽然我的项目与当今智能技术无法比拟，但是其中运用到的机器学习模型（如SVM分类器）足以能够让我的项目归类到人工智能。\n\n\n目录\n\n  目录\n  前言\n  项目总目标\n  正文\n    \n      数据收集与数据清洗\n        \n          为什么要收集数据？\n          数据收集\n          数据规范化\n        \n      \n      建模与机器学习（SVM）\n        \n          对建模的理解与机器学习的理解\n          建模\n            \n              1.随机划分训练集与测试集\n              2.参数调优\n              3.训练\n              4.模型检验\n              5.模型保存\n            \n          \n          数据处理\n        \n      \n    \n  \n\n\n\n\n前言\n  此项目专用于204技术交流会使用，未经本人允许不得外传。为了更好地展示项目，所以在这里写下这篇博客。本博客面向新人，我尽可能的使用了最朴素的方式来表达我的项目技术流程以及算法思想，且文章中不会出现大量生僻难懂的术语，请放心食用。另外，此静态博客网基于Jekyll框架搭建，但对Jekyll的讨论并不在此次技术交流之列中。如果你对Jekyll感兴趣，随时欢迎与我讨论❤️。\n\n  本项目设计以及编码历时共7天，共计划分8个模块，项目大致可以划出以下几个技术分支：\n\n  基于opencv实现的数据清洗与预处理\n  基于svm机器学习分类器识别字母\n  基于selenium无头浏览器实现的翻译爬虫\n  使用threading线程池优化\n\n\n\n\n\n  温馨提示：如果你觉得界面配色有些刺眼，你可以点击右上角的菜单，选择使用圆形按钮切换主题背景。\n\n\n项目总目标\n\n  实现一个可以实时读取屏幕信息，并翻译图中英文的屏幕翻译器。\n\n  效果展示如下图，左右分别为翻译前后的对比：\n\n\n    \n    \n        \n    \n    \n    \n        \n    \n    \n\n\n  项目主要的技术点以及流程如下所示\n\n\n    \n    \n        \n    \n    \n\n\n\n正文\n\n\n\n数据收集与数据清洗\n\n\n为什么要收集数据？\n\n  要翻译屏幕中的英文，首先要做的应该是识别出屏幕中的英文。识别的工作是交由机器学习模型实现的，但是模型并不是一开始就拥有识别英文的能力。事实上你可以将python所提供机器学习模型视为空壳，只有通过不断的喂养其数据，主观的告诉模型什么是对的什么是错的，在不断的训练学习之后模型才有识别的能力。机器学习因此得名“机器学习”。\n\n  什么？你问我为什么不直接去网上下载一个模型？\n  那肯定是（没找到）想要锻炼💪自己呀！\n\n  一般的，一个模型的好坏主要最关键的因素是数据的优劣。数据越多越纯净就越容易训练出优秀的模型。因此数据整理的部分显的尤为重要。\n\n\n数据收集\n\n  模型需要识别的是屏幕中的英文，所以收集的数据也应该是印刷体的的字母图片。不过这类数据资源在网上很少能找得到，少数在Gethub和Kaggle上找到的资源所训练出的模型效果都不尽人意。\n\n  最终还是决定，自己动手创造数据。\n  首先准备好自制的52个大小写英文字母一份。\n\n\n    \n    \n        \n    \n    \n\n\n  每个字母只有一张图片用以供应模型的训练肯定是不够用的，所以应该对数据进行扩充，保证至少每个字母对应能有20张匹配的图片。这里使用到的技术是图片的下采样以做到图片的扩充，简单的理解就是通过对一张图片采用随机的不同程度的模糊化处理从而到多张图片。\n\n  其中对字母A的采样结果示意图如下：\n\n\n    \n    \n        \n    \n    \n\n\n  你问我为什么不多造几个数据，而是使用下采样扩充？\n  （肝不够多）下采样得到的图片是对原有图片的衍生，同样拥有原图像的基本信息，用这样的数据进行训练不会影响模型的效果。\n\n数据规范化\n\n  图像数据需要最终供模型训练，而训练的接口是固定的，因此所有的数据应该有相同的规格。\n\n  我的做法是将数据处理成 \\(20*20\\) 像素的黑白图片素材使用。\n\n  也就是将一个普通的字母图片通过横向纵向的拉伸与压缩变成一个 \\(20*20\\) 标准的图片。显而易见的，这种做法很容易导致图片信息了流失。我在实践中也遇到了这个问题，其中影响最大的就是字母 \\(il\\) 等长宽比差距较大的字母，如果直接通过拉伸与放缩的手段让其规范化的话就会出现以下的结果（左边为原图，右边为处理后的图像）以至于影响到后面建模的效果:\n\n\n    \n    \n        \n    \n    \n    \n        \n    \n    \n\n\n  对此我的做法是显式地判断图片的长宽比，当长宽比超过4时，手动放缩，具体代码如下：\n\n    def resize(self, img):\n        &quot;&quot;&quot;\n        图像需要原先就是灰度图像\n        将图片调整到标准大小20*20\n        :param img: 原图像\n        :return:finish_img\n        &quot;&quot;&quot;\n\n        if img.shape[0] / img.shape[1] &amp;gt; 4:  # 表示长宽比太大了，不适合做拉伸操作\n            ## 待补充，这里需要解决过度拉伸的问题，可能需要寻找填充的方法\n            # 计算需要用于填充的图像的宽高\n            high = img.shape[0]\n            wide = int((img.shape[0] - img.shape[1]) / 2)\n\n            grid = np.zeros((high, wide))  # 计算用于填充的黑色图片\n\n            img = np.hstack((grid, img))  # 左右都做填充\n            img = np.hstack((img, grid))  # 左右都做填充\n\n            # 最后将填充的图像重新转换为20*20的格式\n            img = cv2.resize(img, (20, 20))\n            if self.debug:\n                print(&quot;这里做了一次对称填充&quot;)\n        else:\n            img = cv2.resize(img, (20, 20))\n        # 调整大小并返回\n        return img\n\n\n\n建模与机器学习（SVM）\n\n对建模的理解与机器学习的理解\n  在数据规范化后我们得到了，噪音（杂质）相对较少的 \\(20 * 20\\)的图片信息，但是我们的\\(SVM\\)分类器模型（下面以“\\(SVM\\)”简称）还不能直接使用这些数据，\\(SVM\\)所反映的是多个数值影响一个数值的映射关系函数，可以简单的概括成以下的函数，训练的最终目的就是为了得到这个函数：\n\n\\[f(x) = w_1x_1 + w_2x_2 + w_3x_3 + \\dots w_nx_n\\]\n\n\n  其中 \\(x_i\\) 表示自变量，可以理解为对应图片像素点的数值，\\(w_i\\)表示权值，\\(f(x)\\)是最终计算出来的结果。\n\n\n  将之前清洗好的图像，当成一个个\\(n\\)组400维的方程组，使用\\(SVM\\) 算法“解方程”。\n\n\n  400维由来：一个20*20的图片有400个像素点\n\n\n  上面最终计算得到上面的式子，也就是我们所说的一个训练好的模型。\n\n\n建模\n  数据建模，在这里不是指3D建模，而是指一个机器学习的流程。这里数据建模用到了机器学习是本项目可以称之为人工智能的原因之一。接下来将简单讲解机器学习的流程。\n\n1.随机划分训练集与测试集\n\n  将整理好的数据，按照一定比例划分成训练集与测试集，训练集的数据顾名思义是用于训练数据的，测试集的数据是用来检验模型的正确率的。\n\n\n  训练集的数据就好比那些的有答案的课本，我们拿他学习提升自己的能力，而测试集则更像是试卷，用来检测我们的学习成果。\n\n\n2.参数调优\n\n   一个模型往往有很多的参数需要我们定义，这些参数在不同的情况下需要取不同的数值才能使模型达到最优的效果。不同于平时的算法竞赛题目，这些参数值往往不是确定的，需要我们自己去调整。当然，我们不需要自己手动调参，我们可以用网格搜索与k折交叉验证两种方法来解决最优参数的寻找问题。\n\n  这两种算法的主要做法是，将训练集的数据继续分出一个和验证集，通过不断测试与调整，最终计算出最优模型的参数。由于篇幅有限，其具体做法这里不做过多的描述。\n\n3.训练\n\n  模型训练的操作，其实才是机器学习里面最难的部分，不过好在SVM已经被python封装好了，我们只需要提供前面清洗出的数据以及定义参数调优，稍等片刻即可得到训练好的模型。\n\n4.模型检验\n\n  将之前分出的测试集数据代入模型进行预测，计算正确率。当然评价一个模型的好坏的指标有很多其他的评价指标还有\\(R^2\\)，召回率等等，这里不做延伸。\n\n5.模型保存\n\n  每次训练一个模型经常要消耗大量的时间，为此我们需要保存训练好的模型，在下次做识别时就不需要再训练了。\n\n  上面对机器学习的建模过程的描述地十分简单，但是实际的建模过程远比这个要复杂。只要前面在的“数据分析”“数据选择与清洗”“模型选择”“参数设置”等等环节出现了一个错误都有可能把你的人工智能模型训练成“人工智障”，而且前面的繁多步骤也会加大调参排错的难度。我也是花了4天左右的时间才训练出了一个比较过得去的模型。\n\n\n  ⚡如果你也想入门人工智能，那要求你至少要有比较强的python基础，成熟的面向对象的思维，以及强大的心理素质。⚡\n\n\n  以下是py代码实现\n    def train(self):\n        &quot;&quot;&quot;\n        SVM模型实现\n        :return: None\n        &quot;&quot;&quot;\n        ## 数据分析与预处理\n        x_train, y_train, x_test, y_test = self.get_data()\n\n        ## 网格搜索,找到最优参数\n        machine_svm = svm.SVC()\n\n        param_grid = {&#39;C&#39;: range(0, 50, 10)}  # 这里设置了参数的测试范围\n        grid_search = GridSearchCV(machine_svm, param_grid, cv=3)  # 建立网格搜索器模型\n        grid_search.fit(x_train, y_train)  # 开始搜索\n\n        ## 创建分类器对象\n        print(&quot;最优参数是 c= &quot;, grid_search.best_params_)\n        print(&quot;最优模型正确率 = &quot;, grid_search.best_score_)\n        self.machine_svm = grid_search.best_estimator_  # 获取最优模型\n\n        ## 模型训练\n        self.machine_svm.fit(x_train, y_train)\n\n        ## 模型验证\n        result = self.machine_svm.predict(x_test)\n        correct = np.count_nonzero(result == y_test)\n        accuracy = correct / result.size\n\n        print(&quot;测试集正确率：&quot;, accuracy)\n\n        ## 模型保存\n        joblib.dump(self.machine_svm, &#39;model/svm.pkl&#39;)\n\n\n\n\n\n数据处理\n\n  在前面，我们用做了特殊处理的图片对模型进行训练，所以在用该模型进行识别操作时，也需要对被识别图像做同样的操作。在之前清洗数据时我并没有详细讲解具体的操作，所以放到这里详细说明。\n\n  我们想要预测一个图像，显然无法直接对一个RGB格式的图片下手，对于一个RGB格式的图片，它的每一个像素点都由三个数值组成（Rad Green Blue），这不利于识别，所以需要处理成一个数值，这样的处理过程我们称之为灰度化。\n\n  如下方的两个图像就是做了灰度化处理的图像对比。\n\n\n    \n    \n        \n    \n    \n    \n        \n    \n    \n\n\n  为了更好的配对模型，我们需要对灰度图进一步简化，通常的做法是将像素点间的差距拉的尽可能大（离散化），我们通常使用的方式是二值化\n\n  如下方的两个图像是灰度图像做了二值化处理的前后对比。\n\n\n    \n    \n        \n    \n    \n    \n        \n    \n    \n\n\n  二值化后的图像，为过滤或弱化出图形中的小白点（噪音），我们常常采用高斯模糊（打马赛克）以及腐蚀的方法。\n\n  如下图分别为做了高斯模糊和腐蚀操作的二值图像。\n\n\n    \n    \n        \n    \n    \n    \n        \n    \n    \n\n\n  有时，我们会把握不好腐蚀操作的度，以至于一些重要信息也被过滤掉了，为了弥补过滤掉的内容，一般会对腐蚀后的图像做膨胀操作。\n一般的，先对一个图像做腐蚀再对齐做膨胀的组合操作我们称之为开运算。\n\n  如下为两个分别是做了碰撞和开运算的图像。\n\n\n    \n    \n        \n    \n    \n    \n        \n    \n    \n\n\n  通过opencv库实现以上操作，可以帮助我们从一张图片中提取出很多有效的信息。你可以从下面的代码中直观得体会出这个处理流程。\n\n    def change_color(self, img):\n        &quot;&quot;&quot;\n        将图像进行预处理\n        :param img:img 彩图\n        :return: img 二值图\n        &quot;&quot;&quot;\n        ## 原图像备份\n        copy_img = img.copy()\n        self.show(copy_img)\n\n        ## 高斯模糊\n        copy_img = cv2.GaussianBlur(img, (3, 3), 0)\n\n        ## 图像灰度化\n        copy_img = cv2.cvtColor(copy_img, cv2.COLOR_BGR2GRAY)\n        self.show(copy_img)\n\n        ## 图像二值化\n        _, copy_img = cv2.threshold(copy_img, 115, 255, cv2.THRESH_BINARY_INV)\n        self.show(copy_img)\n\n        ## 开运算降噪\n        copy_img = cv2.morphologyEx(copy_img, cv2.MORPH_OPEN, np.ones((2, 2)), iterations=2)\n        self.show(copy_img)\n\n        ## 膨胀运算\n        copy_img = cv2.morphologyEx(copy_img, cv2.MORPH_DILATE, np.ones((5, 5)), iterations=4)\n        self.show(copy_img)\n\n        return copy_img\n\n\n\n回到顶部\n"
} ,
  
  {
    "title"    : "Java EE",
    "category" : "",
    "tags"     : " java, java ee, 期末考试",
    "url"      : "/javaee",
    "date"     : "December 24, 2022",
    "excerpt"  : "  Java EE，Java 平台企业版（Java Platform Enterprise Edition），之前称为Java 2 Platform, Enterprise Edition (J2EE)，2018年3月更名为 Jakarta EE(这个名称应该还没有得到群众认可)。是 Sun 公司为企业级应用推出的标准平台，用来开发B/S架构软件。Java EE 可以说是一个框架，也可以说是一种规范。\n\n\n\n前言\n  《java EE》是一门与就业相关度较高的一门课程，作为企业级的应用开发...",
  "content"  : "  Java EE，Java 平台企业版（Java Platform Enterprise Edition），之前称为Java 2 Platform, Enterprise Edition (J2EE)，2018年3月更名为 Jakarta EE(这个名称应该还没有得到群众认可)。是 Sun 公司为企业级应用推出的标准平台，用来开发B/S架构软件。Java EE 可以说是一个框架，也可以说是一种规范。\n\n\n\n前言\n  《java EE》是一门与就业相关度较高的一门课程，作为企业级的应用开发，虽然书本上学的ssm框架已经过时，但是作为我们初学者，它的价值还是不小的。\n\n  本博客按知识点整理一些相关内容，祝愿你可以取得一个让自己满意的成绩。\n\n\n问题解析\nSpring中Bean的作用域有哪些，默认是哪一个\n\n  singleton：单例模式（默认），在整个Spring IoC容器中，使用singleton定义的Bean将只有一个实例\n\n  prototype：原型模式，每次通过容器的getBean方法获取prototype定义的Bean时，都将产生一个新的Bean实例\n\n  request：对于每次HTTP请求，使用request定义的Bean都将产生一个新实例，即每次HTTP请求将会产生不同的Bean实例。只有在Web应用中使用Spring时，该作用域才有效\n\n  session：对于每次HTTP Session，使用session定义的Bean豆浆产生一个新实例。同样只有在Web应用中使用Spring时，该作用域才有效\n\n  globalsession：每个全局的HTTP Session，使用session定义的Bean都将产生一个新实例。典型情况下，仅在使用portlet context的时候有效。同样只有在Web应用中使用Spring时，该作用域才有效\n\n\n\nSpring中有哪些注解\n  1. @Controller：将Controller层的类对象交由spring容器生成与管理\n\n  2. @Service：将Service层的类对象交由spring容器生成与管理\n\n  3. @Repository：将Dao层的类对象交由spring容器生成与管理\n\n  4. @Component将类对象交由spring容器生成与管理\n\n\n\nSpring AOP、IOC的概念\n  AOP(Aspect-Oriented Programming:面向切面编程)：是指将那些与业务无关，却被多个业务模块所共同调用逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，提升系统的可维护性。\n\n  IOC就是控制反转，是指程序将创建对象的控制权转交给Spring框架进行管理，由Spring通过java的反射机制根据配置文件在运行时动态的创建实例，并管理各个实例之间的依赖关系。\n\n\n\nSpring AOP中的通知类型\n\n\n  \n    \n      通知类型\n      注解\n      说明\n    \n  \n  \n    \n      before（前置通知）\n      @Before\n      通知方法在目标方法调用之前执行\n    \n    \n      after（后置通知）\n      @After\n      通知方法在目标方法返回或异常后调用\n    \n    \n      after-returning（返回通知）\n      @AfterReturning\n      通知方法会在目标方法返回后调用\n    \n    \n      after-throwing（异常抛出通知）\n      @AfterThrowing\n      通知方法会在目标方法抛出异常后调用\n    \n    \n      around（环绕通知）\n      @Around\n      通知方法会将目标方法封装起来\n    \n  \n\n\n\n\nSpring 实现AOP的动态代理的方式\n\n  1. JDK动态代理（基于接口实现的）：JDK动态代理制能对实现了接口的类生成代理，而不是针对类\n\n  2. CGLIB动态代理（基于类实现的）：CGLIB是针对类实现代理，主要对指定的类生成一个子类，覆盖其中的方法，添加额外功能，因为是继承，所以该类方法不能用final来声明。\n\n\n\nMyBaes如何防止SQL注入问题\n\n  在编写MyBatis的映射语句时，尽量采用“#{xxx}”这样的格式。若不得不使用“${xxx}”这样的参数，要手工地做好过滤工作，来防止SQL注入攻击。\n\n\n\n动态SQL的使用\n\n&amp;lt;select id=&quot;queryList&quot; parameterType=&quot;com.jinzheng.pojo.Book&quot; resultType=&quot;com.jinzheng.pojo.Book&quot;&amp;gt;\n    select * from tb_book\n    &amp;lt;where&amp;gt;\n        &amp;lt;if test=&quot;id != null and id !=&#39;&#39; &quot;&amp;gt;\n            or id = #{id}\n        &amp;lt;/if&amp;gt;\n        &amp;lt;if test=&quot;name != null and name !=&#39;&#39; &quot;&amp;gt;\n            or name like concat(&#39;%&#39;,#{name},&#39;%&#39;)\n        &amp;lt;/if&amp;gt;\n        &amp;lt;if test=&quot;press != null and press !=&#39;&#39; &quot;&amp;gt;\n            or press like concat(&#39;%&#39;,#{press},&#39;%&#39;)\n        &amp;lt;/if&amp;gt;\n        &amp;lt;if test=&quot;author != null and author !=&#39;&#39; &quot;&amp;gt;\n            or author like concat(&#39;%&#39;,#{author},&#39;%&#39;)\n        &amp;lt;/if&amp;gt;\n        &amp;lt;if test=&quot;bookPrice != null and bookPrice !=&#39;&#39; &quot;&amp;gt;\n            or bookPrice = #{bookPrice}\n        &amp;lt;/if&amp;gt;\n    &amp;lt;/where&amp;gt;\n&amp;lt;/select&amp;gt;\n\n\n\n\nSpring MVC的工作原理\n\n\n    \n    \n        \n    \n    \n\n\n\n\n开发Java Web项目的三层架构\n\n  1)：数据访问层：(dao持久层)主要是对原始数据（数据库或者文本文件等存放数据的形式）的操作层，\n而不是指原始数据，也就是说，是对数据的操作，而不是数据库，具体为业务逻辑层或表示层\n提供数据服务．\n\n  2)：业务逻辑层：(service)主要是针对具体的问题的操作，也可以理解成对数据层的操作，对数据业务\n逻辑处理，如果说数据层是积木，那逻辑层就是对这些积木的搭建。具体的讲主要负责对数\n据层的操作。也就是说把一些数据层的操作进行组合。\n\n  3)：表示层：(controller)主要表示WEB方式，如果逻辑层相当强大和完善，\n无论表现层如何定义和更改，逻辑层都能完善地提供服务。\n主要对用户的请求接受，以及数据的返回，为客户端提供应用程序的访问。\n\n\n\nserverlet需要实现的两个方法是什么\n  1. toGet 方法\n  2. toPut 方法\n\nJSP的9个内置对象\n\n  1. Request对象\n  2. Response对象\n  3. Out对象\n  4. session对象\n  5. Application对象\n  6. PageContext对象\n  7. Config对象\n  8. Page（相当于this）对象\n  9. Exception对象\n\n\n\n程序设计题\n1. MyBean\n设计一个数据库访问的代码：\n\npublic void userFindByIdTest() {\n    String resources = &quot;mybatis-config.xml&quot;;\n    Reader reader = null;\n    try {\n        reader = Resources.getResourceAsReader(resources);\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n    SqlSessionFactory sqlMapper = new SqlSessionFactoryBuilder().build(reader);\n    SqlSession session = sqlMapper.openSession();\n    User user = session.selectOne(&quot;findById&quot;, 1);\n    System.out.println(user.getUname());\n    session.close();\n}\n\n\n2. AOP\n基于注解的AOP代码：\n\n注册bean\n\n&amp;lt;bean name=&quot;userDao&quot; class=&quot;com.itheima.demo03.UserDaoImpl&quot;/&amp;gt;\n&amp;lt;bean name=&quot;AnnoAdvice&quot; class=&quot;com.itheima.demo04.AnnoAdvice&quot;/&amp;gt;\n&amp;lt;!-- 开启@aspectj的自动代理支持 --&amp;gt;\n&amp;lt;aop:aspectj-autoproxy/&amp;gt;\n\n\n\n定义通知\n/**\n * 1、在切面中，需要通过指定的注解将方法标识为通知方法\n * @Before：前置通知，在目标对象方法执行之前执行\n * @After：后置通知，在目标对象方法的finally字句中执行\n * @AfterReturning：返回通知，在目标对象方法返回值之后执行\n * @AfterThrowing：异常通知，在目标对象方法的catch字句中执行\n *\n * 2、切入点表达式：设置在标识通知的注解的value属性中\n * execution(public int com.atguigu.spring.aop.annotation.CalculatorImpl.add(int, int)\n * execution(* com.atguigu.spring.aop.annotation.CalculatorImpl.*(..)\n * 第一个*表示任意的访问修饰符和返回值类型\n * 第二个*表示类中任意的方法\n * ..表示任意的参数列表\n * 类的地方也可以使用*，表示包下所有的类\n * 3、重用切入点表达式\n * //@Pointcut声明一个公共的切入点表达式\n * @Pointcut(&quot;execution(* com.atguigu.spring.aop.annotation.CalculatorImpl.*(..))&quot;)\n * public void pointCut(){}\n * 使用方式：@Before(&quot;pointCut()&quot;)\n *\n * 4、获取连接点的信息\n * 在通知方法的参数位置，设置JoinPoint类型的参数，就可以获取连接点所对应方法的信息\n * //获取连接点所对应方法的签名信息\n * Signature signature = joinPoint.getSignature();\n * //获取连接点所对应方法的参数\n * Object[] args = joinPoint.getArgs();\n *\n */\n \n@Component\n@Aspect  //将当前组件标识为切面\npublic class LoggerAspect {\n \n    @Pointcut(&quot;execution(* com.atguigu.spring.aop.annotation.CalculatorImpl.*(..))&quot;)\n    public void pointCut(){}\n \n    //前置通知\n    //@Before(&quot;execution(public int com.atguigu.spring.aop.annotation.CalculatorImpl.add(int, int))&quot;)\n    //@Before(&quot;execution(* com.atguigu.spring.aop.annotation.CalculatorImpl.*(..))&quot;)\n    @Before(&quot;pointCut()&quot;)\n    public void beforeAdviceMethod(JoinPoint joinPoint) {\n        //获取连接点所对应方法的签名信息\n        Signature signature = joinPoint.getSignature();\n        //获取连接点所对应方法的参数\n        Object[] args = joinPoint.getArgs();\n        System.out.println(&quot;LoggerAspect，方法：&quot;+signature.getName()+&quot;，参数：&quot;+ Arrays.toString(args));\n    }\n \n    //后置通知\n    @After(&quot;pointCut()&quot;)\n    public void afterAdviceMethod(JoinPoint joinPoint){\n        // System.out.println(&quot;LoggerAspect,后置通知&quot;);\n        //获取连接点所对应方法的签名信息\n        Signature signature = joinPoint.getSignature();\n        System.out.println(&quot;LoggerAspect，方法：&quot;+signature.getName()+&quot;，执行完毕&quot;);\n    }\n \n    //返回通知\n    /**\n     * 在返回通知中若要获取目标对象方法的返回值\n     * 只需要通过@AfterReturning注解的returning属性\n     * 就可以将通知方法的某个参数指定为接收目标对象方法的返回值的参数\n     */\n    @AfterReturning(value = &quot;pointCut()&quot;, returning = &quot;result&quot;)\n    public void afterReturningAdviceMethod(JoinPoint joinPoint, Object result){\n        // System.out.println(&quot;LoggerAspect,返回通知&quot;);\n        //获取连接点所对应方法的签名信息\n        Signature signature = joinPoint.getSignature();\n        System.out.println(&quot;LoggerAspect，方法：&quot;+signature.getName()+&quot;，结果：&quot;+result);\n    }\n \n      //异常通知\n    @AfterThrowing( &quot;pointCut()&quot;)\n    public void afterThrowingAdviceMethod(JoinPoint joinPoint){\n        //获取连接点所对应方法的签名信息\n        Signature signature = joinPoint.getSignature();\n        System.out.println(&quot;LoggerAspect，方法：&quot;+signature.getName()+&quot;,异常通知&quot;);\n    }\n \n    /**\n     * 在异常通知中若要获取目标对象方法的异常\n     * 只需要通过AfterThrowing注解的throwing属性\n     * 就可以将通知方法的某个参数指定为接收目标对象方法出现的异常的参数\n     */\n    @AfterThrowing(value = &quot;pointCut()&quot;, throwing = &quot;ex&quot;)\n    public void afterThrowingAdviceMethod(JoinPoint joinPoint, Throwable ex){\n        //获取连接点所对应方法的签名信息\n        Signature signature = joinPoint.getSignature();\n        System.out.println(&quot;LoggerAspect，方法：&quot;+signature.getName()+&quot;，异常：&quot;+ex);\n    }\n \n \n    //环绕通知\n    @Around(&quot;pointCut()&quot;)\n    //环绕通知的方法的返回值一定要和目标对象方法的返回值一致\n    public Object aroundAdviceMethod(ProceedingJoinPoint joinPoint){\n        Object result = null;\n        try {\n            System.out.println(&quot;环绕通知--&amp;gt;前置通知&quot;);\n            //表示目标对象方法的执行\n            result = joinPoint.proceed();\n            System.out.println(&quot;环绕通知--&amp;gt;返回通知&quot;);\n        } catch (Throwable throwable) {\n            throwable.printStackTrace();\n            System.out.println(&quot;环绕通知--&amp;gt;异常通知&quot;);\n        } finally {\n            System.out.println(&quot;环绕通知--&amp;gt;后置通知&quot;);\n        }\n        return result;\n    }\n}\n\n\nMyBean XML程序编写\n要求写出对应的增删改查的几种代码\n\n&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&amp;gt;\n&amp;lt;!DOCTYPE mapper\n        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;\n        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&amp;gt;\n&amp;lt;mapper namespace=&quot;com.jinzheng.dao.BookMapper&quot;&amp;gt;\n\n&amp;lt;!--    显示所有目录--&amp;gt;\n    &amp;lt;select id=&quot;findAll&quot; resultType=&quot;com.jinzheng.pojo.Book&quot;&amp;gt;\n        select * from tb_book\n    &amp;lt;/select&amp;gt;\n\n&amp;lt;!--    根据id查询图书信息 --&amp;gt;\n    &amp;lt;select id=&quot;findBookById&quot; parameterType=&quot;Integer&quot;\n            resultType=&quot;com.jinzheng.pojo.Book&quot;&amp;gt;\n        select *\n        from tb_book\n        where id=#{id}\n    &amp;lt;/select&amp;gt;\n\n&amp;lt;!--    添加数据--&amp;gt;\n    &amp;lt;insert id=&quot;addBook&quot; parameterType=&quot;com.jinzheng.pojo.Book&quot;&amp;gt;\n        insert into tb_book values (#{id},#{name},#{press},#{author},#{bookPrice})\n    &amp;lt;/insert&amp;gt;\n\n&amp;lt;!--        删除数据--&amp;gt;\n    &amp;lt;delete id=&quot;deleteById&quot; parameterType=&quot;Integer&quot;&amp;gt;\n        delete from tb_book where id = #{id}\n    &amp;lt;/delete&amp;gt;\n\n&amp;lt;!--    修改数据--&amp;gt;\n    &amp;lt;update id=&quot;updateBook&quot; parameterType=&quot;com.jinzheng.pojo.Book&quot;&amp;gt;\n        update tb_book\n        &amp;lt;set&amp;gt;\n            &amp;lt;if test=&quot;name != null and name != &#39;&#39; &quot;&amp;gt;\n                name = #{name},\n            &amp;lt;/if&amp;gt;\n            &amp;lt;if test=&quot;press != null and press != &#39;&#39; &quot;&amp;gt;\n                press = #{press},\n            &amp;lt;/if&amp;gt;\n            &amp;lt;if test=&quot;author != null and author != &#39;&#39; &quot;&amp;gt;\n                author = #{author},\n            &amp;lt;/if&amp;gt;\n            &amp;lt;if test=&quot;bookPrice != null and bookPrice != &#39;&#39; &quot;&amp;gt;\n                bookPrice = #{bookPrice},\n            &amp;lt;/if&amp;gt;\n\n        &amp;lt;/set&amp;gt;\n        where id = #{id}\n    &amp;lt;/update&amp;gt;\n\n&amp;lt;!--        根据图书信息去模糊查询图书信息(动态SQL)--&amp;gt;\n    &amp;lt;select id=&quot;queryList&quot; parameterType=&quot;com.jinzheng.pojo.Book&quot; resultType=&quot;com.jinzheng.pojo.Book&quot;&amp;gt;\n        select * from tb_book\n        &amp;lt;where&amp;gt;\n            &amp;lt;if test=&quot;id != null and id !=&#39;&#39; &quot;&amp;gt;\n                or id = #{id}\n            &amp;lt;/if&amp;gt;\n            &amp;lt;if test=&quot;name != null and name !=&#39;&#39; &quot;&amp;gt;\n                or name like concat(&#39;%&#39;,#{name},&#39;%&#39;)\n            &amp;lt;/if&amp;gt;\n            &amp;lt;if test=&quot;press != null and press !=&#39;&#39; &quot;&amp;gt;\n                or press like concat(&#39;%&#39;,#{press},&#39;%&#39;)\n            &amp;lt;/if&amp;gt;\n            &amp;lt;if test=&quot;author != null and author !=&#39;&#39; &quot;&amp;gt;\n                or author like concat(&#39;%&#39;,#{author},&#39;%&#39;)\n            &amp;lt;/if&amp;gt;\n            &amp;lt;if test=&quot;bookPrice != null and bookPrice !=&#39;&#39; &quot;&amp;gt;\n                or bookPrice = #{bookPrice}\n            &amp;lt;/if&amp;gt;\n        &amp;lt;/where&amp;gt;\n    &amp;lt;/select&amp;gt;\n\n&amp;lt;/mapper&amp;gt;\n\n\n"
} ,
  
  {
    "title"    : "服务器",
    "category" : "",
    "tags"     : " 服务器, 期末考试",
    "url"      : "/server",
    "date"     : "December 23, 2022",
    "excerpt"  : "  服务器指的是网络环境下为客户机(Client)提供某种服务的专用计算机，服务器安装有网络操作系统和各种服务器应用系统软件(如Web服务、电子邮件服务)的计算机。服务器具有高速的CPU运算能力、长时间的可靠运行、强大的I/O外部数据吞吐能力以及更好的扩展性。\n\n\n\n前言\n  《服务端技术原理与应用》是一门考察类课程，其课程本身难度不大，但是知识点比较多。希望你能好好准备，取得一个好成绩。\n\n\n\n知识点剖析\n\n小点\n\n  在Windows server中，新建的用户属于users组\n  系...",
  "content"  : "  服务器指的是网络环境下为客户机(Client)提供某种服务的专用计算机，服务器安装有网络操作系统和各种服务器应用系统软件(如Web服务、电子邮件服务)的计算机。服务器具有高速的CPU运算能力、长时间的可靠运行、强大的I/O外部数据吞吐能力以及更好的扩展性。\n\n\n\n前言\n  《服务端技术原理与应用》是一门考察类课程，其课程本身难度不大，但是知识点比较多。希望你能好好准备，取得一个好成绩。\n\n\n\n知识点剖析\n\n小点\n\n  在Windows server中，新建的用户属于users组\n  系统安装在NTFS盘中\n  ipconfig /release可以释放IP地址\n  权限以最低为准\n  每个人的最低权限都是只读权限\n\n\n\n\n1. 域名空间结构\n简单介绍\n  根域：代表域名命名空间的根，这里为空。\n\n  顶级域：直接处于根域下面的域，代表一种类型的组织或一些国家。在Internet中，顶级域由InterNIC（Internet Network Information Center）进行管理和维护。\n\n  二级域：在顶级域下面，用来标明顶级域以内的一个特定的组织。在Internet中，二级域也是由InterNIC负责管理和维护。\n\n  子域：在二级域的下面所创建的域，它一般由各个组织根据自己的需求与要求，自行创建和维护。\n\n  主机：是域名命名空间中的最下面一层，它被称之为完全合格的域名（Fully Qualified Domain Name，FQDN），例如www.sanxia.net.cn就是一个完全合格的域名。\n\n域名级别\n\n机构顶级域名：\n  com 商业机构，\n  gov 政府机构，\n  edu 教育机构，\n  int 国际组织，\n  mil 军事部门，\n  net 网络运行与服务中心\n  org 其他的非赢利机构\n\n地区顶级域名：\n  CN（中国）\n  hk （中国香港）\n  TW（中国台湾）\n  JP（日本）\n  RU（俄罗斯）\n  UK或GB（英国）\n\n\n\n2.Window Server 2016主要新增功能\n身份标识和访问权限\n  Window Server 2016的Active Directory域服务可以帮助组织保护Active Directory环境并为组织和个人设备提供更好的标识管理，并提供联合身份验证服务(AD FS) , AD FS对轻型目录访问协议(LDAP) 目录中存储的用户进行身份验证的新功能。\n\n系统管理性能\n  Window Server 2016提供了新安装选项: Nano Server。 Nano Server针对私有云和数据中心进行优化的远程管理的服务器操作系统。其所需磁盘空间小，启动速度快。Windows Server 2016引入了一种新的PackageManagement功能(以前称为OneGet)，该功能可以允许IT专业人员或开发人员使软件发现、安装、清单(SDIl)在本地或远程自动进行，无论安装程序技术为何，也不管软件位于何处。\n\n系统网络管理\n  Window Server 2016新增了软件定义的网络。与分布式防火墙和网络安全组联合使用，使你能够以类似于Azure的方式动态分段和保护工作负荷。其次，你可以使用System Center Virtual Machine\n\n  Manager部署并管理整个软件定义的网络(SDN)堆栈。最后，可以使用Docker来管理Windows Server 容器网络，并将SDN 策略与虚拟机和容器关联。在TCP性能改进方面，默认初始拥塞窗口(ICW) 已从4增加到10并已实现TCP快速打开(TFO)。\n\n系统数据存储\n  Windows Server 2016中的存储包括软件定义存储以及传统文件服务器的新功能和增强功能。存储空间直通允许通过使用具有本地存储的服务器构建高可用性和可缩放存储。存储副本可在各个服务器或群集之间实现存储不可知的块级同步复制，以便在站点间进行灾难恢复及故障转移群集扩展。\n\nweb应用程序开发\n  Windows Server 2016中的lIS 10.0 Web服务器提供的新增功能包括:\n\n  1. 在网络堆栈中支持HTTP/2协议，并与IIS10.0集成，允许IIS 10.0网站针对支持的配置为HTTP/2请求自动提供服务。\n\n  2. 在Nano Server 中运行和管理lIS 10.0的功能\n\n  3. 支持通配符主机头，使管理员能够为域设置Web 服务器，然后让Web服务器为任何子域的请求提供服务。\n一个用于管理IIS的新 PowerShell模块(1ISAdministration)。\n\n\n\n3.DHCP报文\n  DHCP服务器和客户端之间通过8种类型的报文进行通信。8种类型报文的格式相同，只是某些字段的取值不同。DHCP报文格式基于BOOTP的报文格式。它们是:\n\n1. DHCP DISCOVER:\n  这是DHCP客户端首次登录网络时进行DHCP过程的第一个报文，用来寻找DHCP服务器。\n\n2. DHCP OFFER:\n  DHCP服务器用来响应DHCP，DISCOVER报文，此报文携带了各种配置信息。\n\n3. DHCP REQUEST\n  此报文用于以下三种用途：\n\n  客户端初始化后，发送广播的DHCP REQUEST 报文来回应服务器的 DHCP OFFER 报文。\n\n  客户端重启初始化后，发送广播的 DHCP REQUEST 报文来确认先前被分配的IP地址等配置信息。\n\n  当客户端已经和某个IP地址绑定后，发送 DHCP REQUEST 报文来延长IP地址的租期。\n\n4. DHCP ACK:\n  服务器对客户端的DHCP REQUEST 报文的确认响应报文，客户端收到此报\n文后，才真正获得了IP地址和相关的配置信息。\n\n5. DHCP NAK:\n  服务器对客户端的DHCP REQUEST 报文的拒绝响应报文，比如服务器对客户\n\n  端分配的IP地址已超过使用租借期限（服务器没有找到相应的租约记录)或者由于某些原因无法正常分配IP地址，则发送 DHCP NAK报文作为应答（客户端移到了另一个新的网络)。\n\n  通知DHCP客户端无法分配合适IP地址。DHCP客户端需要重新发送\n\nDHCP DISCOVERY\n  报文来申请新的IP地址。\n\nDHCP DECLINE:\n  当客户端发现服务器分配给它的IP地址发生冲突时会通过发送此报文来通知服务器，并且会重新向服务器申请地址。\n\nDHCP RELEASE:\n  客户端可通过发送此报文主动释放服务器分配给它的IP地址，当服务器收到此报文后，可将这个IP地址分配给其它的客户端。\n\nDHCP INFORM:\n  客户端已经获得了IP地址，发送此报文的目的是为了从服务器获得其他的一些网络配置信息，比如网关地址、DNS服务器地址等，\n\n\n\n4.操作题（ip配置）\n\n  在DHCP服务器上创建一个IP地址作用域，它的名称为“office”，所包含的IP地址范围为：192.168.1.1～192.168.1.100，子网掩码为：255.255.255.0，需要排除的IP地址范围为：192.168.1.51～192.168.1.60，采用默认的租约期限，不用配置DHCP选项。\n\n操作步骤：\n  步骤1：单击【开始】→【程序】→【管理工具】→【DHCP】，打开“DHCP”管理控制台。\n\n  步骤2：右键单击这台计算机的名称，然后选择【新建作用域】 。\n\n  步骤3：当出现“欢迎使用新建作用域向导”时，单击【下一步】按钮。这时出现“作用域名”对话框。\n\n  步骤4：在“作用域名”对话框中，输入：“office”，然后单击【下一步】按钮。\n\n  步骤5：在“IP地址范围”对话框中的【起始IP地址】中输入：192.168.1.1、在【结束IP地址】中输入：192.168.1.100、在【子网掩码】中输入：255.255.255.0。单击【下一步】。\n\n  步骤6：在“添加排除”对话框中的【起始IP地址】中输入：192.168.1.51、在【结束IP地址】中输入： 192.168.1.60、然后单击【添加】按钮，再单击【下一步】按钮。\n\n  步骤7：在“配置DHCP选项”对话框中，选择【否，我想稍后配置这些选项】，单击【下一步】按钮。\n\n  步骤8：当出现“正在完成建立作用域向导”对话框时，单击【完成】按钮。\n\n5.DHCP地址分配类型\nDHCP允许有三种类型的地址分配如下:\n\n1.自动分配方式\n  当DHCP客户端第一次成功的从DHCP 服务器端租用到IP地址之后,就永远使用这个地址。\n\n2.动态分配方式\n  当DHCP第一次从 HDCP服务器端租用到IP地址之后，并非永久的使用该地址，只要租约到期，客户端就得释放这个IP地址，以给其它工作站使用。当然，客户端可以比其它主机更优先的更新租约，或是租用其它的IP地址。\n\n3.手工分配方式\n  DHCP客户端的IP地址是由网络管理员指定的,DHCP服务器只是把指定的IP地址告诉客户端。\n\n\n\n6.分布式文件系（DFS）的优点\n  DFS是将相同的文件同时存储到网络上多台服务器上后，就可以有以下功能和优点:\n\n1.访问文件更加容易\n  分布式文件系统使用户可以更容易地访问文件。共享文件可能在物理上跨越多个服务器,用户只需要转到网络上的一个位置即可访问文件。\n\n2.可用性\n  基于域的DFS命名空间以两种方法确保用户保持文件的访问，一是WindowsServer 20016自动将DFS拓扑发布到活动目录中，以确保DFS拓扑对域中所有服务器上的用户总是可见的;二是用户可以复制DFS根目录和DFS共享文件夹。复制意味着可以在域中的多个服务器上存储DFS根目录和DFS共享文件夹，即使这些文件驻留的一个物理服务器不可用，用户仍然可以访问此文件。\n\n3.服务器负载平衡\n  DFS根目录支持物理上分布在网络中的多个DFS共享文件夹。这一点很有用,例如，当用户将频繁访问某一文件时,并非所有的用户都在单个服务器上物理地访问此文件，这将会增加服务器的负担,DFS确保访问文件的用户分布于多个服务器。然而，在用户看来,文件驻留在网络上的相同位置。\n\n7.服务器的分类\n主DNS服务器\n  主域名服务器负责维护域中的域名服务信息，管理员需要配置正向解析文件、反向解析文件等相关信息，本身具有向客户机提供域名解析的功能。\n\n辅助DNS服务器\n  辅助域名服务器不需要配置正向解析与反向解析的数据库文件，辅助域名服务器的正向解析与反向解析数据库是从主域名服务器复制得来的。辅助域名服务器的作用是分担主域名服务器的查询负担，提供域名查询的稳定性和可靠性。\n\n转发DNS服务器\n  转发DNS服务器(Forwarder Name Server)可以向其他DNS转发解析请求。\n\n惟缓存DNS服务器\n  惟缓存DNS服务器不配置域名解析数据库文件，也不从主域名服务器同步其数据库信息。当本地DNS客户机有查询请求时，它会向某个远程DNS服务器转发查询请求。\n\n\n\n8.操作题（账户配置）\n\n在计算机上创建一个本地用户帐户，帐户名为“student”，密码为“12345”，并且允许用户在第一次登录时更改密码。\n\n操作步骤：\n\n步骤1：右键单击【我的电脑】→【管理】，然后在“计算机管理”对话框中的【本地用户和组】中右击【用户】，然后选择【新用户】 。\n\n步骤2：在“新用户”对话框中的【用户名】中输入【student】 ，在【密码】中输入：12345，在【确认密码】中再次输入：12345，然后选中用户【下次登录时须更改密码 】 。\n\n步骤3：单击【创建】按钮。\n\n\n\n9.如何在一台服务器上建立多个Web站点\n\n\n  使用不同的IP地址\n  使用不同的端口号\n  使用主机头\n\n\n10.概念考察总汇\n\n操作系统\n  操作系统位于底层硬件与用户之间，是两者沟通的桥梁。用户可以通过操作系统的用户界面，输入命令。\n\n动态磁盘\n  动态硬盘，即动态磁盘。动态硬盘是指在Windows操作系统的磁盘管理器中将本地硬盘升级得来的。\n\nDNS\n  即域名系统，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。\n\nVPN\n  VPN虚拟专用网络，利用公用网络架设专用网络活动目录。\n\n组策略\n  是管理员为用户和计算机定义并控制程序、网络资源及操作系统行为的主要工具。\n"
} ,
  
  {
    "title"    : "计算机组成原理",
    "category" : "",
    "tags"     : " 计算机组成原理, 期末考试",
    "url"      : "/computer",
    "date"     : "December 18, 2022",
    "excerpt"  : "计算机组成原理重点讲授计算机系统的硬件组成，及其主要功能子系统的基本原理和逻辑设计；主要内容包括计算机系统概述，数据的表示、运算与校验，CPU子系统，存储子系统，总线与I/O子系统，I/O设备及接口等。\n\n\n\n前言\n本博客针对《计算机组成原理》课程进行期末复习，其中复习形式以对真题的解答为主要方式。本门课程偏硬件，对于软件专业的可能需要花费更多的时间来攻克本门课程。希望你顺利通过本门考试。\n\n\n\n考题分析\n\n\n  \n    \n      题型\n      单项分数\n      题量\n   ...",
  "content"  : "计算机组成原理重点讲授计算机系统的硬件组成，及其主要功能子系统的基本原理和逻辑设计；主要内容包括计算机系统概述，数据的表示、运算与校验，CPU子系统，存储子系统，总线与I/O子系统，I/O设备及接口等。\n\n\n\n前言\n本博客针对《计算机组成原理》课程进行期末复习，其中复习形式以对真题的解答为主要方式。本门课程偏硬件，对于软件专业的可能需要花费更多的时间来攻克本门课程。希望你顺利通过本门考试。\n\n\n\n考题分析\n\n\n  \n    \n      题型\n      单项分数\n      题量\n      总分\n    \n  \n  \n    \n      选择\n      2\n      10\n      20\n    \n    \n      判断\n      1\n      10\n      10\n    \n    \n      简答\n      5\n      10\n      20\n    \n    \n      计算\n      10\n      3\n      30\n    \n    \n      综合\n      15\n      2\n      30\n    \n  \n\n\n\n\n选择题\n\n1. 两个数\\(9F5 H\\)和\\(513 H\\)相加，得( C ).\n\n\n  后缀H表示16进制，其表示方式\\(9F5 H\\)等价于\\((9F5)_{16}\\)\n\n\n  A: BDBH\n  B: CD8H\n  C: F08H\n  D: CC8H\n\n2. ( D )表示法主要用于表示浮点数中的阶码。\n\n  A: 原码\n  B: 补码\n  C: 反码\n  D: 移码\n\n3. 存储字长是( C )\n\n  存储字长是位数，大小才是个数\n\n\n  A: 存储单元的个数\n  B: 机器指令的位数\n  C: 存放在一个存储单元之后的二进制代码位数\n  D: 机器字长\n\n4. 若[x]补 = 1.10001100，则[x]原=( B )。\n\n  这里的第一位表示符号位不是小数点\n原码 = 补码按位取反后 + 1\n\n\n  A: 1.0010101\n  B: 1.01110100\n  C: 0.0010110\n  D: 0.1101010\n\n5. 若CPU的地址线为A0~A15，某芯片存储单元有8K，则加在该存储器芯片上的地址线为( C )。\n\n  1k 表示 \\(2^{10}\\) 所以可以推算出 8k 表示 \\(2^{13}\\) 所以总线占据13位\n\n\n  A: A0~A10\n  B: A0~A11\n  C: A0~A12\n  D: A0~A13\n\n6. 冯.诺依曼机工作方式的基本特点是( B )。\n\n  A: 多指令流单数据流\n  B: 按地址访问并顺序执行指令\n  C: 堆栈操作\n  D: 存储器按内容选择地址\n\n7. 某一RAM 芯片，其容为1024*8位，其数据线和地延线分别为( C )。\n\n  1024 表示地址线 \\(2^{10}\\) 共10位，数据线为8位\n\n\n  A: 3、10\n  B: 10、3\n  C: 8、10\n  D: 10、8\n\n8. Cache的地址映射中，若主存中的任意一块均可映射到Cache内的任意一块的位置上，称( B )。\n\n  直接映射表示：取模映射，每一个块只能映射到模数固定的位置上。\n全相联映射：如题意。\n组相联映射：组间直接映射，组内全映射\n\n\n  A: 直接映射\n  B: 全相联映射\n  C: 组相联映射\n  D: 以上全是\n\n9. 某机字长8位，来用补码形式，则机疑数能表示的范国是( C )。\n\n  左闭右开\n\n\n  A: -127~+127\n  B: -128~+128\n  C: -128~+127\n  D: -127~+128\n\n10. 计算机操作的最小单位时间是( A )。\n\n  A: 时钟周期\n  B: 机器周期\n  C: CPU周期\n  D: 指令周期\n\n\n\n判断题\n\n11．超前进位不要考虑前一位来的进位。（✔）\n12. 在补码的加减法中，用两位符号位判断溢出,两位符号位组合为10时，表示结果正溢。（✖）\n\n  00\t结果为正，无溢出 \n01\t正溢，（大于机器所能表示的最大正数）\n10\t负溢，（小于机器所能表示的最小负数）\n11\t结果为负，无溢出\n\n\n13. NAND闪存更适用作为U盘。 （✔）\n14. 在程序的执行过程中，Cache与主存的地址映射是由操作系统来管理的。 (✖)\n\n  此处应该把操作系统换成硬件\n\n\n15．存取时间比存取周期花费的时间要长一些。 (✖)\n\n  存取周期包括了存储时间，所以存储周期时间要更长\n\n\n16. 浮点数的正负由阶码的正负符号决定。 (✖)\n\n  正负由符号位决定\n\n\n17. NOR闪存更适用作为程序存储器。 (✖)\n\n18. \\(E^2PROM\\) 是带电可擦可编程的只读存储。 (✔)\n19．硬件实现的功能一般比款件实现具有更尚的执行速度。 (✔)\n20. 动态存储DRAM的刷新是以列为单位的。 (✖)\n\n  应该以行为单位\n\n\n\n\n简答题\n21. 任意写出五种指令寻址方式。\n\n  1. 隐含寻址\n  2. 立即寻址\n  3. 直接寻址\n  4. 间接寻址\n  5. 寄存器寻址\n  6. 寄存器间接寻址\n  7. 偏移寻址\n  8. 堆栈寻址\n\n22．写出 NOR和NAND型Flash闪存各自的优缺点\n  NOR可靠性高，适用于擦除次数和编程操作较少，而直接执行代码的场合。\n  NAND存储速度快，闪存有10倍于NOR闪存的可擦除次数，适用于大容量存储设备。\n\n\n\n计算题\n23. 二进制计算\n\n  指数 = 阶码 - 127\n\n  IEEE754标准: 1位符号位 + 8位阶码 + 23位尾数\n\n\n(1)设浮点数的阶码和尾数部分均用二进制补码表示，按照浮点数的运算规则计算X+Y:\\(X=2^{-101}*0.101100，Y=2^{-100}*(-0.101000)\\)\n\n  [x]浮=1011;0.101100，[y]浮=1100;1.011000\n\n  对阶:小阶向大阶看齐。\n\n  △E=EA-EB=-1\n\n  [x]浮’=1100;0.010110\n\n  尾数相加：00.010110+11.011000=11.101110\n\n  需左规一次\n\n  [x+y]浮=1011；1.011100\n\n  X+Y=2-101*（-0.100100）\n\n（2）将十进制数10.375表示成单精度的IEEE754标准规定的32位短浮点数（结呆以十六进制形式给出)。\n\n将整数部分和小数部分整理成二进制可以得到：\n\n  \\(10.375=(1010.011)_2\\)\n\n移动小数点，使其位于第一二位之间：\n\n  \\(1010.011=1.010011 X 2^3\\)\n\n可以得到：\n\n  \\(S=0 E=3+127=130 M=010011\\)\n\n所以有二进制的IEEE754标准表达式：\n\n  \\(01000001 00100110 00000000 00000000\\)\n\n最终得到16进制的IEEE754标准表达式：\n\n  \\((41260000)_{16}\\)\n\n24．设主存容量为256K字，Cache容量为2K字，块长为256字，存储器按字寻址。\n\n  块数 = 容量 / 块长\n\n  直接映射标志位 = s - r\n全相联映射标志位 = s\nw = log(块大小)，r = log(Cache行数)，s = log(主存块数) - w\n\n\n1)在直接映射方式下,设计主存地址格式并求标志位的位数;\n\n  \\(块大小 = 256 = 2^8 = 2^w 字节\\)\n  \\(所以w=8位\\)\n\n  \\(主存寻址单元数 = 256K = 2^{18} = 2^{s+w}\\)\n  \\(所以s = 18-8 = 10 位\\)\n\n  \\(Cache的行大小=2K/256=2^2=2^r\\)\n  \\(所以r=2 位，标记位位数=s-r=10-2=8位\\)\n\n综上所述：\n\n\n  \n    \n      标记s-r\n      行r\n      字地址w\n    \n  \n  \n    \n      8位\n      2位\n      8位\n    \n  \n\n\n标记位的位数是8位\n\n2)在全相联映射方式下，设计主存地址格式并求标志位的位数。\n  \\(块大小 = 256 = 2^8 = 2^w 字节\\)\n  \\(所以w=8位\\)\n\n  \\(主存寻址单元数 = 256K = 2^{18} = 2^{s+w}\\)\n  \\(所以s = 18-8 = 10 位\\)\n\n综上所述\n\n\n  \n    \n      标记s\n      字地址w\n    \n  \n  \n    \n      10位\n      8位\n    \n  \n\n\n标记位的位数是10位\n\n\n\n综合题\n\n25．用8K*2位的SRAM芯片组成32K*8位的存储器。试问:\n\n1)地址寄存器多少位?(5分)\n\n  字大小 = 32K = 2^15\n  所以需要15位\n\n2)共需要多少片SRAM?(5分)\n\n由题意可得\n  新组成的存储器，需要4倍的字扩容、4倍的位扩容才能得到\n  所以：需要\\(4*4 = 16\\)片\n\n3)画出此存储器的组成简要框图。(5分)\n\n\n    \n    \n        \n    \n    \n\n\n26. 作图（微指令与微操作）\n\n\n    \n    \n        \n    \n    \n\n\n参见图1的数据通路,画出取数指令“LDA(R3),RO的指令周期流程图,其含义是将(R3)为地址数存单元的内容取至寄存器RO中，画出方框图并标出各微操作信号序列。\n\n  输入可以不用画\n\n  在下图中，包括菱形在内的上面部分是取指，不包括菱形的下部分是执行\n\n\n\n    \n    \n        \n    \n    \n\n\n"
} ,
  
  {
    "title"    : "马克思主义原理",
    "category" : "",
    "tags"     : " 马克思主义基本原理, 期末考试",
    "url"      : "/marxism",
    "date"     : "December 17, 2022",
    "excerpt"  : "马克思主义基本原理是指马克思主义政治经济学、辩证唯物主义和历史唯物主义以及科学社会主义。它是马克思主义科学体系的基本理论、基本范畴，是其立场、观点和方法的理论表达。\n\n\n\n前言\n本篇博客为对马原课程的期末复习整理，主要是针对68个知识点来整理的，内容较多。祝愿你可以在考试中拿下一个好成绩！\n\n\n\n考试题型\n\n\n  \n    \n      题型\n      题量\n      分值（题/分）\n      总分\n    \n  \n  \n    \n      单选\n      20\n      1\n...",
  "content"  : "马克思主义基本原理是指马克思主义政治经济学、辩证唯物主义和历史唯物主义以及科学社会主义。它是马克思主义科学体系的基本理论、基本范畴，是其立场、观点和方法的理论表达。\n\n\n\n前言\n本篇博客为对马原课程的期末复习整理，主要是针对68个知识点来整理的，内容较多。祝愿你可以在考试中拿下一个好成绩！\n\n\n\n考试题型\n\n\n  \n    \n      题型\n      题量\n      分值（题/分）\n      总分\n    \n  \n  \n    \n      单选\n      20\n      1\n      20\n    \n    \n      多选\n      10\n      2\n      20\n    \n    \n      简答\n      2\n      5\n      10\n    \n    \n      论述\n      2\n      10\n      20\n    \n    \n      分析\n      2\n      15\n      30\n    \n    \n      合计\n      36\n       \n      100\n    \n  \n\n\n\n考题分析\n\n\n\n导论\n1.马克思主义的三个基本组成部分及其理论来源（P2、P5）\n  三个基本组成部分：马克思主义哲学、马克思主义政治经济学和科学社会主义。\n  理论来源：德国古典哲学、英国古典政治经济学、英法两国的空想社会主义。\n\n2.马克思主义产生的社会根源、阶级基础和思想渊源（P4-5）（待确定）\n  社会根源：资本主义生产方式的发展。\n  阶级基础：无产阶级斗争对科学理论的需求。 \n  思想渊源：19世纪西欧三大先进思潮。细胞学说，能量守恒与转化定律，生物进化论，为马克思主义的产生提供了自然科学前提。\n\n3.马克思主义公开问世的标志（P6）\n  《共产党宣言》的发表。\n\n4.《反杜林论》（P7）\n  恩格斯写出了《反杜林论》。全面阐述了马克思主义理论体系。\n\n5.马克思主义的鲜明特征（P10-11）\n  科学性，人民性，实践性，发展性。\n\n6.马克思主义的当代价值（P12-15）（多选）\n  观察当代世界变化的认识工具\n  指引当代中国发展的行动指南\n  引领人类社会进步的科学真理。\n\n7.自觉学习和运用马克思主义（P17-18）\n  努力学习和掌握马克思主义的基本立场观点方法。\n  努力学习和掌握马克思主义中国化的理论成果。\n  坚持理论联系实际的马克思主义学风。\n  自觉将马克思主义内化于心外化于行。\n\n\n\n第一章\n8.哲学的基本问题（P21）\n  哲学的基本问题主要包括两方面内容。一是存在和思维，物质和意识谁为本源的问题，即何者为第一性的问题，对于这一问题的不同回答形成了唯物主义和唯心主义两种根本对立的哲学派别，二是存在和思维，物质和意识是否具有同一性的问题，即思维能否正确的反映存在人能否认识或彻底认识世界的问题，对这一问题的不同回答，产生了可知论和不可知论的理论分野\n\n9.意识的本质（P26）\n  意识是人脑这样一种特殊物质的机能和属性，是客观世界的主观映象。\n\n10.主观能动和客观规律性的辩证统一（P27）\n  一方面尊重客观规律是正确发挥主观能动性的前提。\n  另一方面只有充分发挥主观能动性，才能正确认识和利用客观规律。\n\n11.联系的含义及特点（P32）\n  联系是指事物内部各要素之间和事物之间互相影响，互相制约，互相作用的关系。\n  联系具有客观性，普遍性、多样性、条件性。\n\n12.发展的实质（P33）\n  新事物的产生和旧事物的灭亡。\n\n13.矛盾的同一性和斗争性原理及其方法论要求（P35-36）\n\n  本知识点考查大题目\n\n\n方法论原理：\n  矛盾的同一性是指矛盾着的对立面，互相依存，互相贯通的性质和趋势，有两个方面的含义\n  一是矛盾着的对立面，相互依存互为存在的前提并共处于一个统一个体中。\n  二是矛盾着的对立面，互相贯通，在一定条件下可以互相转化。矛盾的斗争性是矛盾着的，对立面互相排斥，互相分离的性质和趋势。\n\n方法论要求：\n  矛盾的统一性和斗争性的辩证关系原理，要求我们在观察和处理问题时，必须善于把两者结合起来，既要看到矛盾双方的对立，又要看到矛盾双方的统一，在斗争中把握同一性，在同一性中把握斗争性。\n\n14.矛盾的普遍性和特殊性的辩证关系原理及其方法论要求（P37）\n\n  本知识点考查大题目\n\n\n方法论原理：\n  矛盾的普遍性和特殊性是辩证统一的关系，矛盾的普遍性，即矛盾的共性，矛盾的特殊性，即矛盾的个性。 \n  二者相互区别矛盾的共性是无条件的，绝对的矛盾的，个性是有条件的，相对的\n  二者相互区别任何存在的事物都是共性和个性的有机统一，共性寓于个性之中，没有离开个性的共性，也没有离开共性的个性\n  二者在一定条件下相互转化\n  方法论要求我们坚持个性与共性相结合的分析方法\n\n方法论要求：\n  矛盾同一性和斗争性的辩证关系原理要求，我们在观察和处理问题时，必须善于把两者结合起来，在斗争性中把握同一性，在同一性中把握斗争性，既要看到矛盾双方的对立，又要看到矛盾双方的统一。\n\n15.量变质变规律及其方法论要求（P38）\n\n  本知识点考查大题目\n\n\n方法论原理：\n  第一量变是质变的必要准备；\n  第二质变是量变的必然结果；\n  第三量变和质变是相互渗透的；\n\n方法论要求：\n  一方面当事物的发展处在量变阶段时，要踏踏实实做好日常工作，为未来重大改变做准备。\n  另一方面当质变来临的时候要果断的不失时机的抓住机遇，促成质变，使工作迈上新台阶。\n\n16.辩证的否定观及其方法论要求（P39）\n\n  本知识点考查大题目\n\n\n方法论原理：\n  第一否定是事物自我否定；\n  第二否定是事物发展的环节；\n  第三否定是新旧事物联系的环节；\n  第四辩证否定的实质是扬弃。\n\n方法论要求：\n  按照否定之父定规律办事，就要求我们树立辩证的否定观，反对形而上学的肯定一切或否定一切，要对事物采取科学分析的态度，使实践活动符合事物自我否定的辩证本性，同时又要求我们正确看待事物发展的过程，既要看到道路的曲折，又要看到前途的光明。\n\n17.原因与结果（P41）\n  原因与结果是揭示事物引起和被引起关系的一对范畴，在事物的普遍联系中，引起某种现象的现象就是原因，被某种现象所引起的现象就是结果。\n\n18.辩证思维能力（P50）\n\n  本知识点考查大题目\n\n\n  提高辩证思维能力，要求我们客观地而不是主观地联系地，而不是孤立地发展地，而不是静止的全面地而不是片面地系统地而不是零散地观察事物，把握事物的本质和发展规律，找到解决问题的方法和途径。\n  以问题为向导，善于正确分析矛盾，在对立中把握统一在统一中把握对立，克服极端化，片面化，善于运用辩证思维谋划事业发展。\n\n\n\n第二章\n19.实践的基本特征（P62-63）\n  实践具有客观实在性、自觉能动性、社会历史性。\n\n20.实践对认识的决定作用（P67-68）\n\n  本知识点考查论述题\n\n\n实践是认识的来源；\n  实践是认识发展的动力；\n  实践是认识的目的；\n  实践是检验认识真理的唯一标准。\n\n21.两条根本对立的认识路线（P69）\n\n  本知识点考查大题目\n\n\n  在认识的本质问题上，存在着两条根本对立的认识路线：\n  一条是坚持从物到感觉和思想的唯物主义认识路线。\n  另一条是坚持从思想和感觉到物的唯心主义认识路线。\n\n22.认识的本质（P71）\n  在认识的本质问题上，存在着两条根本对立的认识路线：\n  一条是坚持从物到感觉和思想的唯物主义认识路线；\n  另一条是坚持从思想和感觉到物的唯心主义认识路线。\n\n23.感性认识和理性认识的辩证统一关系（P74）\n\n  本知识点考查论述题\n\n\n  第一理性认识依赖于感性认识；\n  第二感性认识有待于发展和深化为理性认识；\n  第三感性认识和理性认识相互渗透相互包含\n  第四毛泽东说。我们的实践证明，感觉到了的东西，我们不能立刻理解它，只有理解了的东西才更深刻的感觉它。这段话形象的说明了感性认识上升为理性认识的重要性以及二者关系的交融性\n\n24.实践与认识的辩证运动规律（P77）\n\n  本知识点考查大题目\n\n\n  实践与认识的辩证运动是由一个感性认识到理性认识，又有理性认识，到实践的飞跃是实践认识再实践，再认识循环往复以至无穷的辩证发展过程。\n\n25.真理的一元性（P81）\n  真理的一元性是指在同一条件下，对于特定的认识客体的真理性认识只有一个，而不可能有多个\n\n26.真理的绝对性和相对性的含义（P81-82）\n  真理的绝对性真理的绝对性是指真理主客观统一的确定性和发展的无限性；\n  真理的相对性真理的相对性是指人们在一定条件下对客观事物及其本质和发展规律的正确认识总是有限度的，不完善的；\n\n27.真理与谬误的辩证关系（P85）\n\n  本知识点考查简答题\n\n\n  第一，真理与谬误相互对立；\n  第二，真理与谬误的对立又是相对的，它们在一定条件下能够相互转化。\n\n28.实践是检验真理的唯一标准（P87）\n  实践之所以能够作为检验真理的唯一标准，是由真理的本性和实践的特点决定的。\n\n29.价值的基本特性（P91-92）\n  第一，价值的主体性，价值的主体性是指价值直接与主体相联系，始终以主体为中心；\n  第二，价值的客观性，价值的客观性是指在一定条件下客体对于主体的意义不依赖于主体的主观意识而存在；\n  第三，价值的多维性，价值的多维性是指每个主体的价值，关系具有多样性，同一客体相对于主体的不同需要与会产生不同的价值；\n  第四，价值的社会历史性，主体和客体的不断变化决定了价值的社会历史性\n\n30.价值评价的特点（P92-94）\n\n  本知识点考查简答题\n\n\n  第一，评价与主客体的价值关系为认识对象；\n  第二，评价结果与评价主体直接相关；\n  第三，评价结果的正确与否依赖于客体状态和主体需要的认识；\n  第四，价值评价有科学与非科学之别。\n\n31.真理与价值在实践中的辩证统一（P95-96）\n  人们的实践活动总是受着真理尺度和价值尺度的制约。\n  任何实践活动都是在这两种尺度共同制约下进行的，任何成功的实践都是真理尺度和价值尺度的统一，是合规律性和合目的性的统一。\n  一方面价值尺度必须以真理为前提。\n  另一方面人类自身需要的内在尺度推动着人们不断发现新的真理。\n\n32.理论创新和实践创新的良性互动（P106-107）\n  实践创新为理论创新提供不竭的动力源泉；\n  理论创新为实践创新提供科学的行动指南；\n  努力实现理论创新与实践创新的良性互动。\n\n\n\n第三章\n33.自然地理环境在人类社会生存和发展中的重要作用（P112）\n  自然地理环境是指人类社会所处的地理位置相联系的自然条件的总和，是人类社会生存和发展永恒的必要的条件，是人们生活和生产的自然基础。\n\n34.物质生产方式（P113）\n  物质的生产方式是社会存在和发展的基础及决定力量。\n\n35.社会存在和社会意识的辩证关系（P116）\n\n  本知识点考查简答题（有待补充）\n\n\n  社会存在和社会意识是辩证统一的，社会存在决定社会意识，社会意识是社会存在的反映，并反作用于社会存在\n\n36.社会意识对社会存在具有能动的反作用（P117）\n  社会意识对社会存在具有能动的反作用，这是社会意识相对独立性的突出表现。\n\n37.生产力（P121）\n  劳动者是生产力中最活跃的因素\n\n38.经济基础与上层建筑的辩证关系（P127）\n  经济基础与上层建筑是辩证统一的，经济基础决定上层建筑，上层建筑反作用于经济基础，二者相互影响相互作用。\n\n39.社会形态更替的一般规律及特殊形式（P133-136）\n  社会形态的内涵；\n  社会形态更替的统一性和多样性\n  社会形态更替的必然性与人们的历史选择性；\n  社会形态更替的前进性和曲折性。\n\n40.社会革命在社会发展中的重要作用（P148）\n  革命对社会发展起巨大作用，“革命是历史的火车头”，是社会进步和政治进步的强大推动力。社会革命是实现社会形态根体的重要手段和决定性环节。\n\n41.改革在社会历史发展中的重要作用（P149）\n  在一定社会形态总的量变过程中，当社会基本矛盾发展到一定程度带有尚未激化到引起社会革命的程度时，就需要依靠改革的途径或手段来改变与生产力不相适应的生产关系和与经济基础不相适应的上层建筑。\n\n42.科学技术在社会发展中的作用（P151-153）\n\n  本知识点考查大题目\n\n\n  积极作用：每一次科技革命都不同程度地引起了生产方式，生活方式和思维方式的深刻变化和社会的巨大进步。首先对生产方式产生了深刻影响，其次对于生活方式产生了巨大影响，最后促进了思维方式的变革。\n\n  消极作用：例如工业的发展带来水和空气的污染，大规模的开垦和过度放牧，造成森林和草原的生态破坏。生命科学的发展提出了涉及人自身尊严，健康，遗传以及生态安全和环境保护等方面的伦理问题，基因工程可能导致基因歧视转基因食品的安全性和基因治疗克隆技术的适用范围等问题引起了人们高度关注。互联网可以迅速广泛的传播大量有用的信息，但也存在大量垃圾信息和虚假信息，并可能侵害国家安全，企业经营秘密以及个人隐私。\n\n  方法论要求：正确认识和运用科学技术：一，充分发挥其积极作用，努力创造条件，将消极作用转化为积极作用。二首要的就是有合理的社会制度，保障科学技术的正确运用，始终坚持使科学技术为人类社会的健康发展服务，让科学技术为人类造福\n\n43.两种历史观在历史创造者问题上的对立（P153）\n  唯物史观与唯心史观的对立，在历史创造者问题上表现为群众史观与英雄史观的对立。\n\n44.人民群众在创造历史过程中的决定作用（P157）\n  人民群众是社会物质财富的创造者，人民群众是社会精神财富的创造者，人民群众是社会改革的决定力量。\n\n45.群众路线（P159）\n  一切为了群众，一切依靠群众，从群众中来到群众中去。\n\n\n\n第四章\n46.商品及其二因素（P169-170）\n  商品是用来交换能满足人的某种需要的劳动产品，具有使用价值和价值两因素或两种属性。\n  价值是商品所持有的社会属性。\n\n47.商品价值量的决定（P171）\n  决定商品价值量的不是生产商品的个别劳动时间，而是社会必要劳动时间。\n\n48.价值规律的表现形式（P174）\n  商品经济中价值规律的表现形式是商品的价格围绕商品的价值自发的波动。\n\n49.资本原始积累的两个途径（P186）\n  一是用暴力手段剥夺农民的土地，二是用暴力手段掠夺货币财富。\n\n50.资本主义生产过程的两重性（P192）\n  资本主义生产过程具有二重性：\n  一方面生产物质资料的劳动过程；\n  另一方面是生产剩余价值的过程及价值增值过程。\n\n51.剩余价值的含义（P193）\n  剩余价值是雇佣工人所创造的，并被资本家无偿占有的，超过劳动力价值的那部分价值，他是雇佣工人劳动价值的凝结。\n\n52.资本主义的基本矛盾（P206）\n  生产社会化和生产资料资本主义私人占有之间的矛盾，是资本主义的基本矛盾。\n\n\n\n第五章\n53.资本主义发展的客观规律（P220）\n  自由竞争引起生产集中和资本集中生产集中和资本集中发展到一定阶段必然引起垄断，这是资本主义发展的客观规律。\n\n54.金融寡头对国家机器的控制（P223）\n  金融寡头对国家机器的控制主要是通过同政府的“个人联合”来实现的。\n\n55.垄断价格（P224）\n  垄断价格，包括垄断高价和垄断低价两种形式。\n\n56.国家垄断资本主义的含义（P225）\n  国家垄断资本主义是国家政权和私人垄断资本联合在一起的垄断资本主义。\n\n57.金融垄断资本得以形成和壮大的重要制度条件（P229）\n  金融自由化与金融创新是金融垄断资本得以形成和壮大的重要制度条件。\n\n58.经济全球化的表现（P235）\n  生产全球化，贸易全球化，金融全球化。\n\n59.第二次世界大战后，居主导地位的资本所有制形式（P240）\n  法人资本所有制崛起并成为居主导地位的资本所有制形式。\n\n60.第二次世界大战后资本主义发生变化的根本推动力量（P244）\n  科学技术革命和生产力的发展，是资本主义发生变化的根本推动力量\n\n\n\n第六章\n61.空想社会主义发展到高级阶段的三个代表人物（P259）\n  法国的圣西门、傅立叶和英国的欧文。\n\n62.社会主义从理想到现实的伟大飞跃（P265）\n  十月革命实现了社会主义从理想到现实的伟大飞跃。\n\n63.无产阶级是最先进最革命的阶级（P274）\n  无产阶级是最先进最革命的阶级，肩负着推翻资本主义旧世界、建立社会主义和共产主义新世界的历史使命。\n\n64.探索适合本国国情的发展道路（P290-291）\n  第一，探索社会主义发展道路，必须坚持对待马克思主义的科学态度。\n  第二，探索社会主义发展道路，必须坚持从当时当地的社会历史条件出发，坚持“走自己的路”。\n  第三，探索社会主义发展道路，必须充分吸收人类的一切文明成果。\n  发展社会主义不能照搬苏联社会主义的模式，照搬别国模式，从来不能成功，这是一个被历史反复证明了的颠扑不破的真理。\n\n\n\n第七章\n65.预见未来社会的方法论原则（P300-303）（多选）\n  在揭示人类社会发展一般规律的基础上指明社会发展的方向。\n  在剖析资本主义旧世界的过程中阐发未来新世界的特点。\n  在社会主义社会发展中不断深化对未来共产主义社会的认识。\n  立足于揭示未来社会的一般规律，而不对各种细节做具体描绘。\n\n66.共产主义社会个人消费品的分配方式（P306）\n  在共产主义社会，个人消费品的分配方式是“各尽所能，按需分配”。\n\n67.马克思主义追求的根本价值目标（P309）\n  实现人的自由而全面的发展是马克思主义追求的根本，价值目标也是共产主义社会的根本特征。\n\n68.实现共产主义是历史发展的必然（P312-313）\n  共产主义理想作为一种社会理想，是对人类社会发展规律认识的基础上，设想的社会目标。\n  遗产主义理想是一定会实现的，是以前的社会发展规律以及资本主义社会的基本矛盾发展为依据的。\n  社会主义运动的实践，特别是社会主义国家的兴起和不断发展已经并正在用事实证明共产主义理想实现的必然性。\n"
} ,
  
  {
    "title"    : "机器学习",
    "category" : "",
    "tags"     : " 机器学习, 期末考试, python",
    "url"      : "/machinelearning",
    "date"     : "December 9, 2022",
    "excerpt"  : "今天的人工智能主要依赖的不再是符号知识表示和程序推理机制，现代 AI 而是建立在新的基础上，即机器学习。无论是传统的基于数学的机器学习模型或决策树，还是深度学习的神经网络架构，当今人工智能领域的大多数 AI 应用程序都是基于机器学习技术。\n\n\n\n前言\n机器学习是智能专业的专核心课，其科目本身的难度较高，不论是在于理论层面还是代码实现层面都有一定的难度。想要征服机器学习还是一件非常具有挑战性的事情。\n\n本次博客整理了有关机器学习课程的期末考试重点，希望同学们可以获得一个好成绩。\n\n\n\n问题一...",
  "content"  : "今天的人工智能主要依赖的不再是符号知识表示和程序推理机制，现代 AI 而是建立在新的基础上，即机器学习。无论是传统的基于数学的机器学习模型或决策树，还是深度学习的神经网络架构，当今人工智能领域的大多数 AI 应用程序都是基于机器学习技术。\n\n\n\n前言\n机器学习是智能专业的专核心课，其科目本身的难度较高，不论是在于理论层面还是代码实现层面都有一定的难度。想要征服机器学习还是一件非常具有挑战性的事情。\n\n本次博客整理了有关机器学习课程的期末考试重点，希望同学们可以获得一个好成绩。\n\n\n\n问题一：有关拟合的问题\n什么是过拟合和欠拟合？\n\n过拟合是指模型在训练集上表现很好，到了验证和测试阶段就很差，即模型的泛化能力很差。\n欠拟合是指模型在训练集上表现的不好，以至于在验证和测试阶段表现的也比较差。\n\n如何解决过拟合与欠拟合？\n过拟合的解决方法：\n\n  重新调整一下参数和超参数。\n  对数据进行特征降维处理，有选择性的抛弃一些特征。\n  降低模型的复杂度。\n  使用正则化约束。\n\n\n欠拟合的解决方法：\n\n  增加模型的复杂度，例如使用神经网络代替线性回归、用随机森林代替决策树。\n  考虑选用更多更具有代表意义的特征的数据特征。\n  重新调整一下参数和超参数。\n  降低正则化约束。\n\n\n决策树如何防止过拟合\n剪枝。\n\n\n问题二：回归模型与分类模型的区别是什么？请举例说明。\n\n回归模型：是对连续变量，进行预测的模型，即回归问题是定量问题。\n回归模型问题的举例：对某城市房价预测、对某地区空气湿度的预测。\n\n分类模型：是对离散变量、进行预测的模型，即分类问题是定类问题。\n分类模型问题的举例：对明天是否下雨的预测、判断病人是否患有某种疾病的预测。\n\n\n问题三：机器学习的四大问题是什么？\n回归、分类、聚类、降维。\n\n\n问题四：机器学习的一般步骤。（需要以某一实物为例）\n回归问题以披萨价格预测为例。\n明确任务收集数据。\n在一定范围内的各个城市中随机选取若干家披萨店，作为初始数据。\n数据分析与预处理。\n将数据特征初步定为以下几项：\n\n比萨的尺寸、披萨的脂肪含量、披萨的制作成本、披萨的口味、披萨的品牌、披萨所在城市的GDP水平、生产披萨的披萨店的知名度。\n\n分析这些特征是否出现缺失值，对缺失值较多的特征直接删除。对缺失值较少的使用平均值填补定量的特征（例如披萨的脂肪含量），使用众数填补定类的特征（例如披萨的口味）。\n\n将定类数据数值化，方便后期计算。\n\n使用灰色关联分析法有选择性地剔除关联度较小的几个特征，即进行降维与特征选择处理。\n\n模型训练\n\n选择使用线性回归解决该回归问题。\n\n模型评估与参数调优\n\nR2评估，模型的优劣，当R2的值越接近1时模型性能越好。\n使用k折交叉验证方法选取出最佳的学习率等参数并再次进行模型训练。\n\n模型应用\n\n将训练模型保存下来，并公布用以推广。\n\n分类问题以肿瘤预测为例。\n明确任务收集数据。\n随机选取若干家医院的肿瘤病人数据作为初始数据\n\n数据分析与预处理。\n\n将数据特征初步定为以下几项：\n肿瘤的直径、体积、颜色、数量、肿瘤是否为良性、病人体温、病人是否出现炎症等信息。\n\n将肿瘤是否为良性作为目标列作为输出项并做数值化处理。\n\n分析这些特征是否出现缺失值，对缺失值较多的特征直接删除。对缺失值较少的使用平均值填补定量的特征（例如肿瘤的直径），使用众数填补定类的特征（例如病人是否出现炎症）。\n\n使用灰色关联分析法有选择性地剔除关联度较小的几个特征，即进行降维与特征选择处理。\n\n模型训练\n\n选择使用逻辑回归解决该分类问题。\n\n模型评估与参数调优\n\n使用AUC值评估模型的优劣，当R2的值越接近1时模型性能越好。\n使用k折交叉验证方法选取出最佳的激活函数的阈值等参数并再次进行模型训练。\n\n模型应用\n\n将训练模型保存下来，并公布用以推广。\n\n\n\n问题五：k折交叉验证的简述。\n\nk折交叉验证常用于参数调优，使得更容易训练出较高性能的模型。\n\nk折交叉验证的工作流程：\n\n  将训练集随机地进行k块、并选出其中1块作为验证集。\n  用其余k-1块的数据进行训练，并用验证集，计算出这一次的误差。\n  重复k次以上步骤，每次选取不同的块作为验证集\n  统计每一次计算得到的误差估计，并取平均值作为本次训练参数的最终指标。\n\n\n\n\n问题六：模型的评估标准\n回归问题的评估标准\n\n  MSE（均方误差） 预测残差的平方和，数值越小越好。\n  RMSE（平均绝对误差）是在MSE的基础上开根号计算得到，同样数值越小越好。\n  MAE（平均绝对误差）预测残差的绝对值之和，值越小越好。\n  R2 (R方分数)既考虑预测值与真值之间的差异又考虑问题本身与真值之间的差异。结果的约接近于1越好。\n    分类问题的评估标准\n  \n  正确率（Accuracy）即被预测正确的样本在所有预测样本中的占比。\n  召回率(TRR) 即在所有真的正类中被模型预测出来的比例。\n  AUC值：AUC的概率意义是随机取一对正负样本，正样本得分大于负样本得分的概\n AUC的范围在[0, 1]之间，并且越接近1越好，越接近0.5属于乱猜\n\n\n\n\n问题七：决策树的建立（以ppt为例）\n考察公式：\n\n信息熵公式：\\(H(X)=\\sum_{i=1}^{n}p_i log_2^{\\frac{1}{p_i}}=-\\sum_{i=1}^{n}p_i log_2{p_i}\\)\n信息增益公式：\\(Gain(D,a)=Ent(D)-Ent(d|a)=Ent(D)-\\sum_{v=1}^V \\frac{D_v}{D}Ent(D_v)\\)\n\n问题描述\n\n如下图，第一列为论坛号码，第二列为性别，第三列为活跃度，最后一列用户是否流失。\n\n\n    \n    \n        \n    \n    \n\n\n根据该图整理得到如下表格：\n\n\n    \n    \n        \n    \n    \n\n\n整体熵为多少\n\n\n    \n    \n        \n    \n    \n\n\n计算按照性别划分的信息增益\n\n要计算性别的信息增益需要先计算性别的信息熵\n\n\n    \n    \n        \n    \n    \n\n\n因此得到按照性别划分的信息增益为\n\n\n    \n    \n        \n    \n    \n\n\n计算按照活跃度划分的信息增益\n\n同样的，要计算活跃度的信息增益需要先计算活跃度的信息熵\n\n\n    \n    \n        \n    \n    \n\n\n因此得到按照活跃度划分的信息增益为：\n\n\n    \n    \n        \n    \n    \n\n\n比较两种特征对流失度的影响\n\n活跃度的信息增益比性别的信息增益大，也就是说，活跃度对用户流失的影响比性别大。\n\n做出决策树图形并说明理由\n\n根据第三问的分析，活跃度的信息增益比性别的信息增益大所以要选用，活跃度作为决策树的根节点。最终结果如下所示：\n\n\n    \n    \n        \n    \n    \n\n\n\n\n问题八：逻辑回归的优化目标函数是什么？交叉熵中的两个概率是分布什么？(不确定)\n\n逻辑回归的优化目标函数是:对数似然函数。 \n交叉熵的灵感概率是：真实分布，非真实分布。\n\n问题九：简述k近邻的算法流程，以及问题问题分析\n算法流程\n\n  计算距离：计算已知类别数据集中的点与当前点之间的距离\n2）排序：按距离递增次序排序\n3）选择：选取与当前点距离最小的k个点\n4）计算频次：统计前k个点所在的类别出现的频率\n5）确定类别：返回前k个点出现频率最高的类别作为当前点的预测分类\n\n\n计算题（以ppt为例）\n考察公式\n欧氏距离：平方和开根号 \n曼哈顿距离（城市街区距离）：绝对值的和\n\n提问\n假设我们现在有几部电影，如何去预测序号9电影的类别？\n\n\n    \n    \n        \n    \n    \n\n\n分别计算每个电影和被预测电影的距离，然后求解\n\n\n    \n    \n        \n    \n    \n\n\n所以最终结果预测为喜剧片。\n\n\n\n问题十：标准化与归一化问题（以PPT为例）\n归一化（重点）\n\n归一化定义：通过对原始数据进行变换把数据映射到(默认为[0,1])之间\n\n\n    \n    \n        \n    \n    \n\n\n作用于每一列，max为一列的最大值，min为一列的最小值，那么X’’为最终结果，mx，mi分别为指定区间值，默认mx为1，mi为0\n\n\n    \n    \n        \n    \n    \n\n\n标准化\n\n定义：通过对原始数据进行变换把数据变换到均值为0,标准差为1范围内\n\n\n    \n    \n        \n    \n    \n\n\n其中，它作用于每一列，mean为平均值，σ为标准差\n\n\n\n问题十一：k均值（k-means）聚类的算法\n流程\n\n  随机设置K个特征空间内的点作为初始的聚类中心\n  对于其他每个点计算到K个中心的距离，未知的点选择最近的一个聚类中心点作为标记类别\n  接着对着标记的聚类中心之后，重新计算出每个聚类的新中心点（平均值）\n  如果计算得出的新中心点与原中心点一样（质心不再移动），那么结束，否则重新进行第二步过程\n\n\n\n\n问题十二：梯度下降法\n梯度下降算法的作用：\n\n梯度下降法是一个优化算法，可以递归地找到模型的最小值，从而找到在最优参数。\n\n需要处理的问题：\n\n\n  学习率：需要在模型建立的速度和质量上做出权衡，学习率过大可能会导致最终结果不收敛，学习率过小会导致训练时间过长。\n  方向：计算出当前点的梯度方向，并向下不断更新自己的位置。\n  终止条件：考虑使用迭代次数、损失函数值到达一定范围之后终止。\n\n\n\n\n问题十三：逻辑回归（不确定）\n损失函数：\n\n\n    \n    \n        \n    \n    \n\n\n目标函数\n\n\n    \n    \n        \n    \n    \n\n\n定义：\n逻辑回归是机器学习中的一种分类模型，做二分类（1/0）任务，并给出相应概率。\nsigmoid函数\nsigmoid可以将数值压缩到[0,1]的范围内。\n\n\n\n问题十四：编程大题\n线性回归（以实验为例）\n\n\n  \n    \n      序号\n      直径（英寸）\n      价格（ 美元）\n    \n  \n  \n    \n      1\n      6\n      7\n    \n    \n      2\n      8\n      9\n    \n    \n      3\n      10\n      13\n    \n    \n      4\n      14\n      17.5\n    \n    \n      5\n      18\n      18\n    \n  \n\n\n该线性回归是一个几元函数，表达式是什么？\n是一个一元线性回归函数。\n表达式为：\\(f(x) = w_1x_1 + b\\)\n其中\\(w_1\\)表示的是“直径”特征的权重，\\(x_1\\)表示“直径”变量，\\(b\\)表示截距\n\n代码实现\nimport numpy as np\nimport pandas as pd\nfrom sklearn.linear_model import LinearRegression   # 最小二乘法线性回归\nfrom sklearn.model_selection import train_test_split\nimport matplotlib.pyplot as plt\n\nX_train_old = np.array([6,8,10,14,18]).reshape(5,1)\nY_train_old = np.array([7,9,13,17.5,18]).reshape(5,1)\nX_train_old,Y_train_old\n\n# 因为数据较少所以没必要再单独划出测试集了\nX_train,X_test,Y_train,Y_test = train_test_split(X_train_old,Y_train_old,random_state=33,test_size=0.2)\n# X_train,X_test,Y_train,Y_test = X_train_old,[],Y_train_old,[]\nX_train,X_test,Y_train,Y_test\n\nmodel = LinearRegression()\nmodel.fit(X_train,Y_train)\n\nT_sim1 = model.predict(X_test)\n\n\n逻辑回归（以实验为例）\n代码实现：\nimport pandas as pd\nimport numpy as np\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.linear_model import LogisticRegression\n\n# 1.获取数据\nnames = [&#39;Sample code number&#39;, &#39;Clump Thickness&#39;, &#39;Uniformity of Cell Size&#39;, &#39;Uniformity of Cell Shape&#39;,\n                   &#39;Marginal Adhesion&#39;, &#39;Single Epithelial Cell Size&#39;, &#39;Bare Nuclei&#39;, &#39;Bland Chromatin&#39;,\n                   &#39;Normal Nucleoli&#39;, &#39;Mitoses&#39;, &#39;Class&#39;]\ndata = pd.read_csv(r&quot;breast-cancer-wisconsin.data&quot;,names=names)\ndata.head()\n\nx_train, x_test, y_train, y_test = train_test_split(x, y, random_state=22)\nx_train.head()\n\nestimator = LogisticRegression()\nestimator.fit(x_train, y_train)\n\ny_predict = estimator.predict(x_test)\n\n问题十五：随机森林\n随机森林的算法流程（随机森林=Bagging+决策树）\n\n\n  随机选取m条数据\n  随机选取k个特征\n  训练决策树\n  重复1-3\n  对上面的若决策树进行平权投票\n\n\nbagging和boosting的区别\n\n区别一:数据方面\n\n  Bagging：对数据进行采样训练；\n  Boosting：根据前一轮学习结果调整数据的重要性。\n\n\n区别二:投票方面\n\n  Bagging：所有学习器平权投票；\n  Boosting：对学习器进行加权投票。\n\n\n区别三:学习顺序\n\n  Bagging的学习是并行的，每个学习器没有依赖关系；\n  Boosting学习是串行，学习有先后顺序。\n\n\n区别四:主要作用\n\n  Bagging主要用于提高泛化性能（解决过拟合，也可以说降低方差）\n  Boosting主要用于提高训练精度 （解决欠拟合，也可以说降低偏差）\n\n"
} ,
  
  {
    "title"    : "机器学习三大基础库",
    "category" : "",
    "tags"     : " 机器学习, python, numpy, pandas, matplotlib",
    "url"      : "/machine",
    "date"     : "December 6, 2022",
    "excerpt"  : "机器学习是研究怎样使用计算机模拟或实现人类学习活动的科学，是人工智能中最具智能特征，最前沿的研究领域之一。自20世纪80年代以来，机器学习作为实现人工智能的途径，在人工智能界引起了广泛的兴趣，特别是近十几年来，机器学习领域的研究工作发展很快，它已成为人工智能的重要课题之一。机器学习不仅在基于知识的系统中得到应用，而且在自然语言理解、非单调推理、机器视觉、模式识别等许多领域也得到了广泛应用。一个系统是否具有学习能力已成为是否具有“智能”的一个标志。\n\n\n\n前言\n\n本次博客主要内容为以下三个p...",
  "content"  : "机器学习是研究怎样使用计算机模拟或实现人类学习活动的科学，是人工智能中最具智能特征，最前沿的研究领域之一。自20世纪80年代以来，机器学习作为实现人工智能的途径，在人工智能界引起了广泛的兴趣，特别是近十几年来，机器学习领域的研究工作发展很快，它已成为人工智能的重要课题之一。机器学习不仅在基于知识的系统中得到应用，而且在自然语言理解、非单调推理、机器视觉、模式识别等许多领域也得到了广泛应用。一个系统是否具有学习能力已成为是否具有“智能”的一个标志。\n\n\n\n前言\n\n本次博客主要内容为以下三个python库\n\n  numpy\n  pandas\n  matplotlib\n\n\n前两个库numpy、pandas主要作用是对于数据存储与数据处理，并且广泛适用于很多机器学习的模型。而matplotlib是作图的好帮手，主要用户机器模型数据的可视化。\n\nnumpy（机器学习前缀知识）\n属性\n\n  数组的维数：对象名.ndim\n  数组的每个维度的数量：对象名.shape返回一个元组，元组中的数字表示该维度的长度。\n  元素总个数：对象名.size\n  成员的数据类型：对象名.dtype\n  矩阵的转置：对象名.T\n  对象名.flat 表示返回一个可以遍历所有元素的迭代器\n  numpy.nan 表示无穷\n  xxx\n\n\n功能型小函数\n\n\n  numpy.sum 求和\n  numpy.min 求最小值\n  numpy.max 求最大值\n  numpy.average 求平均值\n  numpy.median 求中位数\n  numpy.cumsum 返回前缀和向量\n  numpy.diff 返回一个差分数组（少一位）\n  numpy.argmin 求最小值的索引（从0开始计算）\n  numpy.argmax 求最大值的索引（从0开始计算）\n  numpy.nonzero返回n个向量，表示非元素所在位置的索引。\n  numpy.sort 返回对数组排序的结果，如果是多维则只会对一维排序（每一行）。\n  numpy.transpose 返回矩阵转置的结果\n  对象名.flatten() 返回该对象的一维展开（即变成一个行向量）\n  对象名.copy() 返回该对象的值拷贝（直接使用“=”是引用拷贝）注意不同于列表使用对象名[:]不能实现值拷贝，必须使用copy函数\n  numpy.random.randn 按正太分布的概率产生随机数数组\n  numpy.all(逻辑表达式) 逻辑表达式后半段 通过用这种方式将矩阵中所有数据参与计算返回一个bool判断矩阵中是不是所有元素都满足这个式子。\n  numpy.any(数组对象)逻辑表达式后半段 通过用这种方式将矩阵中所有数据参与计算返回一个bool判断矩阵中是否存在某个元素满足这个式子。\n\n\n示例（以numpy.sum为例）\n函数的默认计算区域是所有元素，当想要指定维度使用时需要使用axis来指定，axis从\n0开始计数。特别的对于一个矩阵来说，axis=0表示对每一列求和，axis=1表示对每一行求和。\n代码示例：\n\nimport numpy as np\n\na = np.arange(4).reshape(2,2)\nprint(a)\nprint(np.sum(a),np.sum(a,axis=1))\n\n程序运行截图：\n[[0 1]\n [2 3]]\n6 [1 5]\n\n\n矩阵索引\n以二维数组（矩阵）为例\n\n访问单元素的方法\na[i][j]，或 a[i,j]\n\n访问多元素的方法\n访问第i+1行的所有元素\na[i,:]\n访问第j+1列的所有元素\na[:,j]\n\n矩阵初始化 array\n函数签名：\narray(p_object, dtype=None, *args, **kwargs):\n\n上面的构造器接受以下参数：\n\n  object 任何暴露数组接口方法的对象都会返回一个数组或任何（嵌套）序列。\n  dtype 数组的所需数据类型，可选。\n  copy 可选，默认为true，对象是否被复制。\n  order C（按行）、F（按列）或A（任意，默认）。\n  subok 默认情况下，返回的数组被强制为基类数组。 如果为true，则返回子类。\n  ndmin 指定返回数组的最小维数。\n\n\n示例：\narray = numpy.array([[1,2,3],[4,5,6]].numpy.int64)\n\n滤波器clip\n\n函数签名：\ndef clip(a, a_min, a_max, out=None, **kwargs):\n\n将数组中小于a_min的值取a_min，将数组中大于a_max的值取a_max\n代码示例：\nimport numpy as np\n\na = np.arange(12)\n\nprint(np.clip(a,5,9))\n\n程序运行截图：\n[5 5 5 5 5 5 6 7 8 9 9 9]\n\n创建一个全1数组ones\n函数签名：\ndef ones(shape, dtype=None, order=&#39;C&#39;, *, like=None):\n\n示例：\nnumpy.noes((2,3,4)) # 创建一个2叶3行4列的全1矩阵\n\n\n创建一个全0数组zeros\n函数签名：\ndef zeros(shape, dtype=None, order=&#39;C&#39;, *args, **kwargs):\n\n\n示例：\nnumpy.zeros((2,3,4)) # 创建一个2叶3行4列的全0矩阵。\n\n\n创建有序数组arange\n函数签名：\ndef arange(start=None, *args, **kwargs):\n\n示例1（创建一个0~9的行向量）：\nnumpy.arange(10)\n\n程序输出：[0 1 2 3 4 5 6 7 8 9]\n\n示例2（创建一个5~9的行向量）：\nnumpy.arenge(5,10)\n\n程序输出：[5 6 7 8 9]\n\n示例3（创建一个以3为步长1~10的行向量）\nnumpy.arange(1,11,3)\n\n程序输出：[ 1  4  7  10]\n\n示例4（创建一个0~9的2行5列的矩阵）\nnumpy.arange(10).reshape(2,5) # 规模必须与元素个数相匹配\n\n程序输出：\n[[0 1 2 3 4]\n [5 6 7 8 9]]\n\n\n创建一个均匀划分的线段 linspace\n函数签名：\ndef linspace(start, stop, num=50, endpoint=True, retstep=False,type=None,axis=0):\n\n作用：以start为开始以stop结束以num为划分次数创建一个行向量。\n\n示例1（一般示例）：\nnumpy.linspace(0，10，2)\n\n程序输出：\n[ 0. 10.]\n\n示例2（重组元素为一个2*5的矩阵）\nnumpy.linspace(0,10,10).reshape(2,5)\n\n程序输出：\n[[ 0.          1.11111111  2.22222222  3.33333333  4.44444444]\n [ 5.55555556  6.66666667  7.77777778  8.88888889 10.        ]]\n\n\nnumpy的运算\n矩阵加减法：\n代码示例：\na = np.array([10,20,30,40])\nb = np.arange(1,5)\nprint(a-b)\nprint(a+b)\n\n程序运行截图：\n[ 9 18 27 36]\n[11 22 33 44]\n\n\n矩阵点乘：\n代码示例1（矩阵点乘）：\nimport numpy as np\n\na = np.array([10,20,30,40])\nb = np.arange(1,5)\nprint(a*b)\n\n程序运行截图：[ 10  40  90 160]\n\n代码示例2（矩阵乘数字）：\nimport numpy as np\n\na = np.array([10,20,30,40])\n\nprint(a*5)\n\n程序运行截图：[ 50 100 150 200]\n\n矩阵乘法：\n示例1（使用np.dot函数实现矩阵乘法）\n代码示例：\nimport numpy as np\n\na = np.arange(1,4).reshape(1,3)\nb = np.arange(1,4).reshape(3,1)\n\nc_dot = np.dot(a,b)\nd_dot = np.dot(b,a)\nprint(c_dot,d_dot,sep=&#39;\\n&#39;)\n\n程序运行截图：\n[[14]]\n[[1 2 3]\n [2 4 6] \n [3 6 9]]\n\n示例二（使用@符号实现矩阵乘法）：\n\n代码示例：\nimport numpy as np\n\na = np.arange(1,4).reshape(1,3)\nb = np.arange(1,4).reshape(3,1)\n\nprint(a@b,b@a,sep=&#39;\\n&#39;)\n\n程序运行截图：\n[[14]]\n[[1 2 3]\n [2 4 6]\n [3 6 9]]\n\n数组的逻辑判断：\n\n数组可以直接进行逻辑判断，其返回值为与元素组同规模的bool型结果数组。\n可以使用对象[逻辑表达式] 来过滤符合条件的项，返回一个行向量。\n\n代码示例：\nimport numpy as np\n\na = np.arange(10)\nprint(a &amp;lt; 3)\ns = np.random.random((4,4))\nprint(s[s &amp;gt; 0.5])\n\n程序运行截图：\n[ True  True  True False False False False False False False]\n[0.50784044 0.51138057 0.75612031 0.61457462 0.9712732  0.79497591]\n\n矩阵元素的函数运算：\n代码示例：\nimport numpy as np\n\na = np.arange(10)\nprint(np.sin(a))\n\n程序运行截图：\n[ 0.          0.84147098  0.90929743  0.14112001 -0.7568025  -0.95892427\n -0.2794155   0.6569866   0.98935825  0.41211849]\n\n\n创建一个元素值在0~1之间的随机矩阵\n示例（创建一个元素值在0~1之间的2行4列的随机矩阵）：\n代码示例：\nimport numpy as np\n\na = np.random.random((2,4))\n\nprint(a)\n\n程序运行截图：\n[[0.24853676 0.47803948 0.04436044 0.92552742]\n [0.61756337 0.31913713 0.83677922 0.51923448]]\n\n\n合并数组\n上下合并函数签名：\ndef vstack(tup):\n\n左右合并函数签名：\ndef hstack(tup):\n\n代码演示：\nimport numpy as np\n\na = np.array([1,2,3,4])\nb = np.array([4,3,5,8])\nprint(np.vstack((a,b)))\nprint(np.hstack((a,b)))\n\n程序运行截图：\n[[1 2 3 4]\n [4 3 5 8]]\n[1 2 3 4 4 3 5 8]\n\n数组分割 split or array_split\n等量数组分割 split\n\n函数签名：\ndef split(ary, indices_or_sections, axis=0):\n\n注意：axis表示对照切割的维度，例如对于矩阵而言axis=0表示横向切割，axis=1表示纵向切割，切割必须是对等切割否则报错。\n代码展示：\nimport numpy as np\n\nA = np.arange(12).reshape(3,4)\nprint(A)\nprint(&quot;纵向切割&quot;)\nprint(np.split(A,2,axis=1))\nprint(&quot;横向切割&quot;)\nprint(np.split(A,3,axis=0))\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n不等量数组分割 array_split\n函数签名：\ndef array_split(ary, indices_or_sections, axis=0):\n\n注意：这里与函数split最大的区别就是可以实现不等分的分法。前面等分，后面几项少分。\n代码展示：\nimport numpy as np\n\nA = np.arange(12).reshape(3,4)\n\nprint(A)\nprint(&quot;纵向切割&quot;)\nprint(np.array_split(A,3,axis=1))\nprint(&quot;横向切割&quot;)\nprint(np.array_split(A,2,axis=0))\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\npandas（机器学习前缀知识）\n属性\n\n  dtypes 获取所有列的数据格式\n  columns 获取所有列名\n  values 去除行名和列名，返回所有的内容，返回对象是numpy.ndarry。\n  T 获得矩阵的转置（列名和行名也会一起转）。\n    功能型小函数\n  \n  fillna(x) 将序列中出现的nan转变为x\n  isnull返回一个bool矩阵当原矩阵中该数值为nan时为true，非nan数据时为false。可以与numpy.any，numpy.all配套使用。\n  读取csv文件pd.read_csv(文件名)\n\n\n初始化矩阵\n创建矩阵 Series\n创建方式类似于numpy\n代码展示：\nimport pandas as pd\n\ns = pd.Series([1,3,6,44,1])\nprint(s)\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n定义有名称的数据 DataFrame\n说明：\nindex表示行标题，columns表示列标题，默认名称为从0开始的有序数列\n注意：每一行对应的数据数量要保持一致。\n示例1（使用序列创建）\n代码展示：\nimport pandas as pd\nmport numpy as np\ns = \nd.DataFrame(np.random.randn(3,4),index=[&#39;x&#39;,&#39;y&#39;,&#39;x&#39;],columns=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;])\nprint(s)\n\n程序运行截图:\n\n\n    \n    \n        \n    \n    \n\n\n示例2（使用字典创建）\n代码展示：\nimport pandas as pd\n\ns = pd.DataFrame({\n    &quot;a&quot;: [1,3],\n    &quot;b&quot;: [1.2,4],\n    &quot;c&quot;: [1.5,84],\n    &quot;d&quot;: [0.2,6]\n})\nprint(s)\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n数组访问\nloc （名称）表示法\n说明：\nloc[ [行名序列]，[列名序列] ]直接访问\nloc[ 行名序列i：行名序列j，列名序列i：列名序列j ]切片访问（切片是闭区间）\n\n两者可以混合使用。\n\n代码展示：\nimport pandas as pd\nimport numpy as np\n\ndates = pd.date_range(&#39;20221001&#39;, periods=6)\ns = pd.DataFrame(np.random.randn(6, 4), index=dates, columns=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])\n\nprint(s)\nprint(&#39;单个数据访问&#39;,s.loc[&quot;20221002&quot;,&#39;a&#39;],sep=&#39;\\n&#39;)\nprint(&#39;多行单列&#39;,s.loc[[&#39;20221002&#39;,&#39;20221001&#39;],&#39;b&#39;],sep=&#39;\\n&#39;)\nprint(&#39;单行多列&#39;,s.loc[&#39;20221002&#39;,[1,2]],sep=&#39;\\n&#39;)\nprint(&#39;多行多列&#39;,s.loc[[&#39;20221002&#39;,&#39;20221001&#39;],[&#39;a&#39;,&#39;b&#39;]],sep=&#39;\\n&#39;)\nprint(&#39;多行多列切片访问&#39;,s.loc[&#39;20221001&#39;:&#39;20221002&#39;,[&#39;a&#39;,&#39;b&#39;]],sep=&#39;\\n&#39;)\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\niloc（下标）表示法\n说明：\n使用方式等同于loc但是序列名变成了索引号（从0开始计数）（不同于loc的是使用切片表示法时是左开右闭区间）\n代码展示：\nimport pandas as pd\nimport numpy as np\n\ndates = pd.date_range(&#39;20221001&#39;, periods=6)\ns = pd.DataFrame(np.random.randn(6, 4), index=dates, columns=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])\n\nprint(s)\nprint(&#39;单个数据访问&#39;,s.iloc[1,1],sep=&#39;\\n&#39;)\nprint(&#39;多行单列&#39;,s.iloc[0:3,3],sep=&#39;\\n&#39;)\nprint(&#39;单行多列&#39;,s.iloc[0,0:3],sep=&#39;\\n&#39;)\nprint(&#39;多行多列&#39;,s.iloc[0:2,[0,3]],sep=&#39;\\n&#39;)\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n访问一列\n访问方式：\n\n对象名[列名]（适用于所有情况的访问方式）\n对象名.列名（这种访问方式仅适用于标题为字符串型的情况）\n\n代码展示：\nimport pandas as pd\nimport numpy as np\ndates = pd.date_range(&#39;20221001&#39;, periods=6)\ns = pd.DataFrame(np.random.randn(6, 4), index=dates, columns=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])\nprint(s)\nprint(s[&#39;a&#39;])\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n访问一行数据 loc\n代码展示：\nimport pandas as pd\nimport numpy as np\n\ndates = pd.date_range(&#39;20221001&#39;, periods=6)\ns = pd.DataFrame(np.random.randn(6, 4), index=dates, columns=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])\n\nprint(s)\nprint(s.loc[&quot;20221002&quot;])\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n访问多行数据\n\n多行数据直接访问语法：\n对象名[start:end] 这里的start、end既可以是数字用于表示序列的索引，当行名不是整数型时也可以直接使用行名（行名可以是字符串）\n\n数组修改\n说明：\n与赋值相似，对已存在的数值进行修改就是修改，对不存在的数据就是添加可以通过修改不存在的行列使得数据的行列增加（未知数据用NAN代替）\n代码展示：\nimport pandas as pd\nimport numpy as np\n\ndates = pd.date_range(&#39;20221001&#39;, periods=6)\ns = pd.DataFrame(np.random.randn(6, 4), index=dates, columns=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])\nprint(s)\nprint(&quot;修改数值&quot;)\ns.a[s.a &amp;lt; 0] = 0\nprint(s)\nprint(&quot;增加行&quot;)\ns.loc[&#39;new_index&#39;] = np.nan\nprint(s)\nprint(&quot;增加列&quot;)\ns.loc[:,&quot;new_columns&quot;] = np.array([0,1,2,3,4,5,6])\nprint(s)\nprint(&quot;同时增加行和列&quot;)\ns.loc[8,&#39;f&#39;] = np.nan\nprint(s)\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n删除行列 dropna\n说明：\n\naxis = 0 时表示删除行，1表示删除列\n\nhow参数有两个值：\n\n\n  “any”：如果存在任何NAN值，则删除该行或列。\n  “all”：如果所有值都为NAN值，则删除该行或列。\n\n\n注意：dropna 只是返回修改后的结果不会改变原本的值\n代码展示：\nimport pandas as pd\nimport numpy as np\n\ndates = pd.date_range(&#39;20221001&#39;, periods=6)\ns = pd.DataFrame(np.random.randn(6, 4), index=dates, columns=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])\n\nprint(s)\ns.iloc[0,0] = np.nan\ns.iloc[2] = np.nan\ns.iloc[:,3] = np.nan\nprint(s)\nprint(&quot;axis == 0 时表示删除行，1表示删除列&quot;)\ns = s.dropna(axis=0,how=&#39;all&#39;)\nprint(s)\ns = s.dropna(axis=1,how=&#39;all&#39;)\nprint(s)\ns = s.dropna(axis=0,how=&#39;any&#39;)\nprint(s)\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n读写excle文件 read_excle or .to_excle\n注意：\n\nread_excle 得到的是一个pandas对象，之前数据访问修改删除等操作依然成立。\nto_excle创建时会添加一列行名，可以使用index=False 去除行名的添加。\n脚本编程\n逻辑表达式筛选：\n\n使用对象名[逻辑表达式]方式筛选。\n代码展示：\nimport pandas as pd\nimport numpy as np\n\ndates = pd.date_range(&#39;20221001&#39;, periods=6)\ns = pd.DataFrame(np.random.randn(6, 4), index=dates, columns=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])\nprint(s)\nprint(&#39;第0列数据大于0的数据有：&#39;)\nprint(s[s.iloc[:,0] &amp;gt; 0])\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n数据分析 describe\n代码展示：\nimport pandas as pd\n\ns = pd.DataFrame({\n    &quot;a&quot;: [1,3],\n    &quot;b&quot;: [1.2,4],\n    &quot;c&quot;: [1.5,84],\n    &quot;d&quot;: [2,6.2]\n})\nprint(s.describe(),sep=&#39;\\n&#39;)\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n排序 sort_index &amp;amp; sort_values\nsort_index 对行列名排序\n说明：\naxis = 0表示对行名进行排序，1表示对列名进行排序。\n排序默认升序排序，当ascending = True 表示倒序排序\n函数签名：\ndef sort_index(\n    self,\n    axis: Axis = 0,\n    level: Level | None = None,\n    ascending: bool | int | Sequence[bool | int] = True,\n    inplace: bool = False,\n    kind: str = &quot;quicksort&quot;,\n    na_position: str = &quot;last&quot;,\n    sort_remaining: bool = True,\n    ignore_index: bool = False,\n    key: IndexKeyFunc = None,\n):\n\n代码展示：\nimport pandas as pd\ns = pd.DataFrame({\n    &quot;a&quot;: [1, 3],\n    &quot;b&quot;: [1.2, 4],\n    &quot;c&quot;: [1.5, 84],\n    &quot;d&quot;: [2, 6.2]\n})\nprint(s.sort_index(axis=0, ascending=False), sep=&#39;\\n\\n&#39;)\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\nsort_values对数据列排序\n函数签名：\ndef sort_values(  # type: ignore[override]\n    self,\n    by,\n    axis: Axis = 0,\n    ascending=True,\n    inplace: bool = False,\n    kind: str = &quot;quicksort&quot;,\n    na_position: str = &quot;last&quot;,\n    ignore_index: bool = False,\n    key: ValueKeyFunc = None,\n):\n\n代码展示：\nimport pandas as pd\n\ns = pd.DataFrame({\n    &quot;a&quot;: [1, 3],\n    &quot;b&quot;: [1.2, 4],\n    &quot;c&quot;: [1.5, 84],\n    &quot;d&quot;: [2, 6.2]\n})\n\nprint(s.sort_values(&#39;a&#39;,ascending=False))\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n合并数组 merge\n说明：\nhow 有4个取值：inner（默认）、outer、left、right 分别表示内连接、外连接、左外连接、右外连接。\non 表示连接是使用的列（类似于外键）\nindictor == True时，在结果列中增加一列以显示每一个数据连接的方式默认为False，可以给indictor赋予字符串，以表示新列的名称\nleft_\tindex &amp;amp; right_index同时为True时可以按行名合并，默认都为False，两者必须同为True才能生效。\nsuffixex当给其一个包含两个字符串的元组时，合并时若出现同名字段，则会加上这两个字符串后缀。\n函数签名：\ndef merge(\n    left: DataFrame | Series,\n    right: DataFrame | Series,\n    how: str = &quot;inner&quot;,\n    on: IndexLabel | None = None,\n    left_on: IndexLabel | None = None,\n    right_on: IndexLabel | None = None,\n    left_index: bool = False,\n    right_index: bool = False,\n    sort: bool = False,\n    suffixes: Suffixes = (&quot;_x&quot;, &quot;_y&quot;),\n    copy: bool = True,\n    indicator: bool = False,\n    validate: str | None = None,\n) -&amp;gt; DataFrame:\n\n\n案例演示\n示例1（依照指定列进行合并）：\n代码演示：\nimport numpy as np\nimport pandas as pd\n\nleft = pd.DataFrame({\n    &#39;key&#39;: [&#39;K0&#39;, &#39;k1&#39;, &#39;k2&#39;, &#39;k3&#39;],\n    &#39;A&#39;: [&#39;A0&#39;, &#39;A1&#39;, &#39;A2&#39;, &#39;A3&#39;],\n    &#39;B&#39;: [&#39;B0&#39;, &#39;B1&#39;, &#39;B2&#39;, &#39;B3&#39;]\n})\n\nright = pd.DataFrame({\n    &#39;key&#39;:[&#39;K0&#39;, &#39;k1&#39;, &#39;k2&#39;, &#39;k3&#39;],\n    &#39;C&#39;:[&#39;C0&#39;,&#39;C1&#39;,&#39;C2&#39;,&#39;C2&#39;],\n    &#39;D&#39;:[&#39;D0&#39;,&#39;D1&#39;,&#39;D2&#39;,&#39;D3&#39;]\n})\n\nprint(left)\nprint(right)\nres = pd.merge(left,right,on=&#39;key&#39;)\nprint(res)\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n示例2依照多列进行合并\n代码演示：\nimport numpy as np\nimport pandas as pd\n\nleft = pd.DataFrame({\n    &#39;key1&#39;: [&#39;K0&#39;, &#39;k0&#39;, &#39;k1&#39;, &#39;k2&#39;],\n    &#39;key2&#39;: [&#39;K0&#39;, &#39;k1&#39;, &#39;k0&#39;, &#39;k1&#39;],\n    &#39;A&#39;: [&#39;A0&#39;, &#39;A1&#39;, &#39;A2&#39;, &#39;A3&#39;],\n    &#39;B&#39;: [&#39;B0&#39;, &#39;B1&#39;, &#39;B2&#39;, &#39;B3&#39;]\n})\n\nright = pd.DataFrame({\n    &#39;key1&#39;: [&#39;K0&#39;, &#39;k1&#39;, &#39;k1&#39;, &#39;k2&#39;],\n    &#39;key2&#39;: [&#39;K0&#39;, &#39;k0&#39;, &#39;k0&#39;, &#39;k0&#39;],\n    &#39;C&#39;: [&#39;C0&#39;, &#39;C1&#39;, &#39;C2&#39;, &#39;C2&#39;],\n    &#39;D&#39;: [&#39;D0&#39;, &#39;D1&#39;, &#39;D2&#39;, &#39;D3&#39;]\n})\n\nprint(left)\nprint(right)\n# how = [&#39;left&#39;,&#39;right&#39;,&#39;inner&#39;,&#39;outer&#39;]\nprint(&#39;内连接&#39;)\nprint(pd.merge(left, right, on=[&#39;key1&#39;,&#39;key2&#39;],how=&#39;inner&#39;))\nprint(&#39;全外连接&#39;)\nprint(pd.merge(left, right, on=[&#39;key1&#39;,&#39;key2&#39;],how=&#39;outer&#39;))\nprint(&#39;左外连接&#39;)\nprint(pd.merge(left, right, on=[&#39;key1&#39;,&#39;key2&#39;],how=&#39;left&#39;))\nprint(&#39;右外连接&#39;)\nprint(pd.merge(left, right, on=[&#39;key1&#39;,&#39;key2&#39;],how=&#39;right&#39;))\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n示例3（显示每一列的合并方式）\n代码演示：\nimport pandas as pd\ndf1 = pd.DataFrame({&#39;col1&#39;:[0,1],&#39;col_left&#39;:[&#39;a&#39;,&#39;b&#39;]})\ndf2 = pd.DataFrame({&#39;col1&#39;:[1,2,2],&#39;col_right&#39;:[2,2,2]})\nprint(df1)\nprint(df2)\nres = pd.merge(df1,df2,on=&#39;col1&#39;,indicator=True,how=&#39;outer&#39;)\nprint(res)\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n示例4（依照行名进行合并）\n代码演示：\nimport pandas as pd\nleft = pd.DataFrame({\n    &#39;A&#39;:[&#39;A0&#39;,&#39;A1&#39;,&#39;A2&#39;],\n    &#39;B&#39;:[&#39;B0&#39;,&#39;B1&#39;,&#39;B2&#39;]},\n    index=[&#39;K0&#39;,&#39;K1&#39;,&#39;K2&#39;])\nright = pd.DataFrame({\n    &#39;C&#39;:[&#39;C0&#39;,&#39;C2&#39;,&#39;C3&#39;],\n    &#39;D&#39;:[&#39;D0&#39;,&#39;D2&#39;,&#39;D3&#39;]},\n    index=[&#39;K0&#39;,&#39;K2&#39;,&#39;K3&#39;])\nprint(left)\nprint(right)\nres = pd.merge(left,right,right_index=True,left_index=True,how=&#39;outer&#39;)\nprint(res)\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n示例5（同名字段加后缀）\n代码演示：\nimport pandas as pd\nboys = pd.DataFrame({&#39;k&#39;: [&#39;K0&#39;, &#39;k1&#39;, &#39;k2&#39;], &#39;age&#39;: [1, 2, 3]})\ngirls = pd.DataFrame({&#39;k&#39;: [&#39;K0&#39;, &#39;K1&#39;, &#39;K2&#39;], &#39;age&#39;: [4, 5, 6]})\nprint(boys)\nprint(girls)\nres = pd.merge(boys,girls,on=&#39;k&#39;,suffixes=(&#39;_boy&#39;,&#39;_girl&#39;),how=&#39;outer&#39;)\nprint(res)\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n合并数组 concat\n说明：\naxis == 0(默认) 表示竖向的合并，1表示横向合并\nignore == True表示纵向合并时忽略原行序列从新有序定义行标号，默认False\njoin 表示纵向连接方式默认为outer外连接（默认），还可以选择 inner 内连接\n注意：当竖向合并时，列名不一致（不包括次序不一致）将产生新列（全外连接）\n\n示例1\n代码展示：\nimport pandas as pd\nimport numpy as np\n\ndf1 = pd.DataFrame(np.ones((3,4))*0,columns=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;])\ndf2 = pd.DataFrame(np.ones((3,4))*1,columns=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;])\ndf3 = pd.DataFrame(np.ones((3,4))*2,columns=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;])\n\nprint(pd.concat([df1,df2,df3],axis=0,ignore_index=True))\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n示例2（纵向连接，两种连接的比较）\n代码演示：\nimport pandas as pd\nimport numpy as np\n\ndf1 = pd.DataFrame(np.ones((3,4))*0,index=[1,2,3],columns=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;])\ndf2 = pd.DataFrame(np.ones((3,4))*1,index=[2,3,4],columns=[&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;])\n\nprint(pd.concat([df1,df2],axis=0,join=&#39;outer&#39;))\nprint(pd.concat([df1,df2],axis=0,join=&#39;inner&#39;))\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n示例三（横向连接的4种方式比较）\n注意：\n代码演示：\nimport pandas as pd\nimport numpy as np\n\ndf1 = pd.DataFrame(np.ones((3,4))*0,index=[1,2,3],columns=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;])\ndf2 = pd.DataFrame(np.ones((3,4))*1,index=[2,3,4],columns=[&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;])\nprint(&quot;全外连接&quot;)\nprint(pd.concat([df1,df2],axis=1))\nprint(&quot;左外链接&quot;)\nprint(pd.concat([df1,df2.reindex(df1.index)],axis=1))\nprint(&quot;右外连接&quot;)\nprint(pd.concat([df2,df1.reindex(df2.index)],axis=1))\nprint(&quot;内连接&quot;)\nprint(pd.concat([df2.reindex(df1.reindex(df2.index).index)],axis=1))\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n数据筛选query\nDataFrame.query(expr, inplace=False, **kwargs)，用于通过boolean表达式来查询dataframe中的列。\n主要参数为expr，它是字符串表达式，有如下说明：\n\n可以引用变量，方法是在变量前添加一个@字符，例如@a + b。\n可以在反引号内将包含空格或运算符的列名引用起来。 这样，您还可以转义以数字开头或Python关键字的名称。 基本上是无效的Python标识符。\n\nmatplotlib（图像绘制）\n\n函数应用\n函数签名：\ndef plot(*args, scalex=True, scaley=True, data=None, **kwargs):\n\n\n\n  x: 横坐标，可选的， 默认为 range(len(y))\n  y: 纵坐标，即数据项，可以是一维或多维的列表或数组\n  markersize: 标记大小\n  color: 线条颜色\n  marker: 数据标记的形状，默认是没有标记\n  linestyle: 线条样式，默认为实线\n代码演示：\n\n\nimport matplotlib.pyplot as plt\n\nx = [1, 2, 3]\ny = [1, 2, 3]\n# 以下两种写法等价，\nplt.plot(x, y, color=&#39;green&#39;, marker=&#39;o&#39;, linestyle=&#39;dashed&#39;, linewidth=2, markersize=12)\n# plt.flot(x, y, &#39;go--&#39;，linewidth=2, markersize=12)\n# 可以在一个画布上绘制多张图片，\ny1 = [4, 5, 6]\nplt.plot(x, y1, color=&#39;red&#39;, marker=&#39;*&#39;, linestyle=&#39;solid&#39;, linewidth=2, markersize=12)\nplt.show()\n\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n重要示例\n\n示例1（创建4个折线图）\n说明：使用plot实现，其中show函数主要实现图像的展示工作。\n代码演示：\n\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndata = pd.DataFrame(np.random.randn(1000,4),index=np.arange(1000),columns=list(&quot;ABCD&quot;))\n\ndata = data.cumsum()    # 累加\ndata.plot()\nplt.show()\n\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n示例二（创建2个散点图）\n代码演示：\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndata = pd.DataFrame(np.random.randn(1000,4),index=np.arange(1000),columns=list(&quot;ABCD&quot;))\ndata = data.cumsum()    # 累加\nax = data.plot.scatter(x=&#39;A&#39;,y=&#39;B&#39;,color=&#39;DarkBlue&#39;,label=&quot;Class 1&quot;)\ndata.plot.scatter(x=&#39;A&#39;,y=&#39;C&#39;,color=&#39;DarkGreen&#39;,label=&quot;Class 2&quot;,ax=ax)\nplt.show()\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n日常问题\n图形中文乱码\n\n解决方法：更改字体防止图形乱码\nfrom matplotlib import pyplot as pl\npl.rcParams[&#39;font.sans-serif&#39;] = [&#39;SimHei&#39;]\n\n"
} ,
  
  {
    "title"    : "python 多线程与多进程",
    "category" : "",
    "tags"     : " python, 多线程, 多进程",
    "url"      : "/process",
    "date"     : "December 5, 2022",
    "excerpt"  : "进程是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。线程是进程中的一部分，也是进程的的实际运作单位，它也是操作系统中的最小运算调度单位。\n\n\n前言\n多线程与多进程还是比较实用的。本博客以应用为目的展示两个基础的类。\n\n多进程 Process\n\nprocess模块是一个创建进程的模块，借助这个模块，就可以完成进程的创建。\nfrom multiprocessing import Process\n\n参数介绍\nProcess(group=N...",
  "content"  : "进程是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。线程是进程中的一部分，也是进程的的实际运作单位，它也是操作系统中的最小运算调度单位。\n\n\n前言\n多线程与多进程还是比较实用的。本博客以应用为目的展示两个基础的类。\n\n多进程 Process\n\nprocess模块是一个创建进程的模块，借助这个模块，就可以完成进程的创建。\nfrom multiprocessing import Process\n\n参数介绍\nProcess(group=None, target=None, name=None, args=(), kwargs={})\n\n\n\n  group——参数未使用，值始终为None\n  target——表示调用对象，即子进程要执行的任务\n  args——表示调用对象的位置参数元组，args=(1,2,’egon’,)\n  kwargs——表示调用对象的字典，kwargs={‘name’:’egon’,’age’:18}\n  name——为子进程的名称\n\n\n方法介绍\n\n  obj.start()：启动进程，并调用该子进程中的obj.run()\n  obj.run()：进程启动时运行的方法，正是它去调用target指定的函数，我们自定义类的类中一定要实现该方法\n  obj.terminate()：强制终止进程obj，不会进行任何清理操作，如果obj创建了子进程，该子进程就成了僵尸进程，使用该方法需要特别小心这种情况。如果obj还保存了一个锁那么也将不会被释放，进而导致死锁\n  obj.is_alive()：如果obj仍然运行，返回True\n  obj.join([timeout])：主线程等待obj终止（强调：是主线程处于等的状态，而obj是处于运行的状态）。timeout是可选的超时时间，需要强调的是，obj.join只能join住start开启的进程，而不能join住run开启的进程\n\n\n属性介绍\n\n  obj.daemon：默认值为False，如果设为True，代表obj为后台运行的守护进程，当obj的父进程终止时，obj也随之终止，并且设定为True后，obj不能创建自己的新进程，必须在\n  obj.start()：之前设置\n  obj.name：进程的名称\n  obj.pid：进程的pid\n  obj.exitcode：进程在运行时为None、如果为–N，表示被信号N结束(了解即可)\n  obj.authkey：进程的身份验证键,默认是由os.urandom()随机生成的32字符的字符串。这个键的用途是为涉及网络连接的底层进程间通信提供安全性，这类连接只有在具有相同的身份验证键时才能成功（了解即可）\n\n\n使用案例\nfrom multiprocessing import Process\nimport os\n\ndef worker(arg):\n    # 返回父子进程的pid\n    print(os.getpid(), os.getppid())\n\n\nif __name__ == &quot;__main__&quot;:\n    print(&#39;I am parent process&#39;)\n    jobs = []\n    for i in range(5):\n        p = Process(target=worker, args=(i,))\n        jobs.append(p)\n        p.start()\n\n方法介绍\n\n\n    \n    \n        \n    \n    \n\n\n使用样例\n利用函数使用多线程\nfrom threading import Thread\na = 0\ndef work():\n    global a\n    a += 1\n    print(a，end=’’)\n\nif __name__ == &#39;__main__&#39;:\n    childs = []\n    for i in range(5):\n        childs.append(Thread(target=work))\n        childs[-1].start()\n\n\n程序运行结果：\n1 2 3 4 5\n如果创建的不是线程而是进程则资源不会共享，运行结果会是：\n1 1 1 1 1\n\n利用类重写Thrrad方法实现多线程\nfrom threading import Thread\nimport time\nnum = 0\nchilds = []\nclass MyThread(Thread):\n    def run(self):\n        self.t = num\n\n        for _ in range(3):\n            print(self.t, &#39;线程正在工作&#39;)\n            time.sleep(0.5)\n\n\nfor i in range(3):\n    num = i + 1\n    childs.append(MyThread())\n    childs[-1].start()\n\n运行结果之一：\n1 线程正在工作\n2 线程正在工作\n3 线程正在工作\n132 线程正在工作 线程正在工作 \n线程正在工作\n\n13 线程正在工作\n2 线程正在工作\n 线程正在工作\n\n可以看到输出十分的杂乱，说明确实是多线程输出。\n"
} ,
  
  {
    "title"    : "OpenStack",
    "category" : "",
    "tags"     : " OpenStack, 期末考试",
    "url"      : "/openstack",
    "date"     : "December 4, 2022",
    "excerpt"  : "OpenStack是Rackspace和NASA共同成立的一个开源项目，它是为云计算服务的，提供存储空间、计算能力等资源服务的Web Service。简单来说，OpenStack就是一个操作系统，一套软件，一套IaaS（基础设施即服务）软件，对资源进行管理，并且以服务的形式提供给上层应用或者用户去使用。\n\n\n\n前言\n\n以下为openstack的期末复习，考试考点整理，内容比较多且知识点生僻难懂，请好好准备，祝愿各位可以在期末获取一个好成绩！\n\n\n\n第一章考点\n什么是云计算\n云计算是一种把计...",
  "content"  : "OpenStack是Rackspace和NASA共同成立的一个开源项目，它是为云计算服务的，提供存储空间、计算能力等资源服务的Web Service。简单来说，OpenStack就是一个操作系统，一套软件，一套IaaS（基础设施即服务）软件，对资源进行管理，并且以服务的形式提供给上层应用或者用户去使用。\n\n\n\n前言\n\n以下为openstack的期末复习，考试考点整理，内容比较多且知识点生僻难懂，请好好准备，祝愿各位可以在期末获取一个好成绩！\n\n\n\n第一章考点\n什么是云计算\n云计算是一种把计算机基础资源经过重组后给用户使用的一系列相关服务。\n\n云计算架构对应几种架构模式以及概念\nIaaS（基础设施即服务）\nPaaS（平台即服务）\nSaaS（软件即服务）\n\nOpenStack 的主要项目以及对应的项目名称\n\n\n  \n    \n      服务\n      直译\n      项目名称\n    \n  \n  \n    \n      Dashboard\n      仪表盘\n      Horizon\n    \n    \n      Computer\n      计算\n      Nova\n    \n    \n      Natwork\n      网络\n      Neutron\n    \n    \n      Object Storage\n      对象存储\n      Swift\n    \n    \n      Block Storage\n      块存储\n      Cindar\n    \n    \n      Identity\n      身份\n      Keystone\n    \n    \n      Image\n      镜像\n      Glance\n    \n    \n      Telemetry\n      计量\n      Ceilometer\n    \n    \n      Orchestration\n      编排\n      Heat\n    \n    \n      Database\n      数据库\n      Trove\n    \n    \n      Data Processing\n      数据处理\n      Sahara\n    \n  \n\n\n\n\n第二章考点\n网络配置流程\n\n\n  进入网络配置的文件：vi  /etc/sysconfig/netwrok-scripts/ifcfg-ens33\n  修改BOOTPROTO的值为static \n  修改ONBOOT的值为yes\n  添加配置4条信息：IPADDR NETNASK GATEWAY DNS1\n  键入qw保存并退出配置文件\n  输入：systemctl restart network 重启network服务。\n\n\nopenstack的安装\n\n\n  安装openstack-packstack以及其依赖包：yum install -y openstack-packstack\n  安装openstack：packstack --allinone\n  进入文件查看生成的初始密码配置：vi /etc/my.cnf.d/server.cnf\n\n\n\n\n第三章考点\n\n数据库\n1.数据库验证\n验证方式：systemctl status sqlname\n\n2. 数据库有哪些\nNoSQL数据库：MongoDB Memcached Redis\nSQL数据库：MySQL Maria PostgreSQL\n\n消息队列\n什么是消息队列\n消息队列是一种应用程序对应用程序的通信方法。消息传递指的是程序之间通过打消良中发送数却进行通信,而不是通过百捉调用彼此来通信。\n\n消息队列实现的协议以及对应的软件\n协议：AMQP\n软件：RabbitMQ\n\n\n\n第四章考点\n\nREST 含义解释\nRESTFUL是一种网络应用程序的设计风格和开发方式，是我们用http调用资源的时候的统一接口的访问形式，用自己的话说就是把对资源的调用转化到一种表现方式上来，例如开发的时候使用微信小程序表现可以避免用不同的语言开发app应用\n\n调用OpenStack API的四种方式\n\n  cURL \n  OpenStack命令行客服端\n  REST客户端\n  OpenStack的Python SDK\n\n\nOpenStack 的认证与API 请求流程\n\n\n  向云管理员提供的身份端点请求一个认证令牌。\n  如果请求成功，服务器会返回一个认证令牌。\n  发送API请求，并在X-Auth-Token头部包括上一步返回的认证令牌。可以一直使用这个令牌发送API请求，直到服务完成该请求，或者出现未授权(401)的错误。\n  如果遇到未授权（401）的错误，则需要重新请求另一个令牌。\n\n\n获取OpenStack认证令牌\n\n\n  进入demo环境：source keystonerc_demo\n  运行命令cURL来请求一个令牌。\n\n\n发送API请求\n\n\n  设置OS_TOKEN环境变量，将其值设为令牌ID： export OS_TOKEN=令牌ID\n  设置OS_PROJECT_NAME环境变量：export OS_PROJECT_NAME=demo\n  设置OS_COMPUTE_API环境变量：export OS_COMPUTE_API=http://192.168.199.21:8774/v2.1\n  使用Compute API列出示例类型：curl -s -H &quot;X-Auth-Token: $OS_TOKEN&quot; $os_COMPUTE_API/flavors lpython -m json.tool。\n\n\n\n第五章\n\nKeystone的管理层次结构\n\n\n    \n    \n        \n    \n    \n\n\n问：在一个域中的用户User1是否可以管理项目Project1\n\n答：可以，因为用户User1是系统管理员，拥有对项目Project1的管理权限。\n\n\nKeystone认证流程图\n这张图需要背下来。\n\n\n    \n    \n        \n    \n    \n\n\n对图片的解释：\n\n\n  用户向Keystone提供凭证，Keystone验证通过后向用户返回令牌的同时还会返回一个通用目录。\n  用户使用该令牌向该目录列表中的端点请求该用户对应的项目信息，Keystone验证通过后返回用户对应的项目列表\n  用户从列表中选择要访问的项目再次向Keystone发出请求，Keystone验证通过后返回管理该项目的服务列表，并允许访问该项目的令牌。\n  用户会通过这个服务和通用目录映射找到服务的端点，并通过端点找到实际服务组件的位置。\n  用户在凭借项目令牌和端点来访问实际上的服务组件。\n  服务组件会向Keystone提供这个用户项目令牌进行验证，Keystone验证通过后会返回一系列的确认信息和附加信息给服务\n  服务执行一系列操作。\n\n\n罗列命令行操作\n\n  列出可用角色：openstack role list\n  创建角色：openstack role create new-role\n  分配角色：openstack role add --user 用户名或ID --oject项目名或ID角色名或ID\n  查看角色详细信息：openstack role show角色名或ID\n  删除角色：openstack role remove --user 用户名或ID--project用户名或ID角色名或ID\n\n\n\n\n第六章\n常用的镜像格式以及容器\n\n镜像格式：qcwr\n不用容器使用bare代替\n使用容器可以在ovf ova aki ari docker中选择\n\nopenstack中创建镜像的流程\n创建镜像，转成快照\n\n\n  获取实例啃决照的文件路径，可通过查看其详细信息中的“ID”值。\n  其中执行openstack image create 创建新的镜像：openstack image create &quot;entOS7-img&quot;--file varlib/glance/limages/快照id --disk-format qcow2--container-format bare\n  新创建的镜像类型变为镜像(image) .\n\n\n\n第七章\n\n虚拟机实例化的流程\n\n  首先用户（可以是OpenStack最终用户，也可以是其他程序）执行Nova Client提供的用于创建虚拟机的命令。\n  nova-api服务监听到来白于Nova Client的HTTP请求,并将这些请求转换为AMQP消息之后加入消息队列。\n  通过消息队列调用nova-conductor报务。\n  nova-conductor服务从消息队列中接收到虚拟机实例化请求消息后,进行一些准备工作。\n  nova-conductor服务通过消息队列告诉nova-scheduler服务去选择一个合适的计算节点来创建虚拟机，此时nova-scheduler会读取数据库的内容。\n  nova-conductor服务从nova-scheduler服务得到了合适的将计算节点的信息后，在通过消息队列来通知nova-compute服务实现虚拟机的创建。\n\n\n其他\n配置文件中对两个值的解释\n\n”” 空字符串\n表示“always”（总是）\n\n”!” 感叹号\n表示“nerver”或者“nobady”，即拒绝。\n\n小知识点\n\n\n  oslo.policy是json格式的文件。\n  openstack是使用python语言实现的。\n\n"
} ,
  
  {
    "title"    : "Jekyll 入门指导",
    "category" : "",
    "tags"     : " Jekyll, web前端",
    "url"      : "/jekyll",
    "date"     : "December 4, 2022",
    "excerpt"  : "jekyll是一个简单的免费的Blog生成工具，类似WordPress。但是和WordPress又有很大的不同，原因是jekyll只是一个生成静态网页的工具，不需要数据库支持。但是可以配合第三方服务,例如Disqus。最关键的是jekyll可以免费部署在Github上，而且可以绑定自己的域名。\n\n\n\n前言\n\n该博客的部署使用的就是Jekyll框架，Jekyll是一门很成熟的技术（也可能是有点老的缘故），他可以将makedown格式的文档转化成一个个静态的页面，即便你没有系统的学过前端三件套...",
  "content"  : "jekyll是一个简单的免费的Blog生成工具，类似WordPress。但是和WordPress又有很大的不同，原因是jekyll只是一个生成静态网页的工具，不需要数据库支持。但是可以配合第三方服务,例如Disqus。最关键的是jekyll可以免费部署在Github上，而且可以绑定自己的域名。\n\n\n\n前言\n\n该博客的部署使用的就是Jekyll框架，Jekyll是一门很成熟的技术（也可能是有点老的缘故），他可以将makedown格式的文档转化成一个个静态的页面，即便你没有系统的学过前端三件套也可以制作自己的主页（真的太棒了！）。\n\n对于使用者来说只需要找到对应的资源模板，套用jekyll即可得到你想要的博客。\n\n如果你想要了解更多，这个是Jekyll官网的传送门 \\(\\Longrightarrow\\) Jekyll\n\n\n\nJekyll 基础知识\n\n基本结构\nJekyll 也遵循「约定大于配置」的基本原则，所以上手成本极低。\n\n在新创建的项目目录下，有几个重要的文件夹：\n\n_layouts\n\n用于存放各种布局.html 的文件用于对.md文件的转换，在md设置的消息头中的变量，.md文件选择了layout布局之后，会引入对应的布局.html中，html会存放这些变量的默认值，\n\n_drafts\n\n用于存放.md博客的草稿，不会再jekyll工作的时候生成，需要使用指令jekyll server –draft 才会显示在界面中\n_posts\n\n用于存放博客文章\n_site\n\n用于存放项目构建完成之后所生成的静态文件，也就是说，静态网站的所有文件都会来源于此，其中 CSS 文件、JS 文件以及图片文件，会存放在该目录下的 assets 文件夹中。我们可以直接把该目录下的文件拿去部署\n\n除此之外，还有一些其他文件：\n_config.yml\n\n是项目的配置文件，一些全局配置会写在这个文件内，比如 collections（后续推文会讲解），默认文件/路径，等等。总之，这里可以自定义很多东西\n\n.gitignore\n\n创建项目时会自动生成，不需要纳入到 CVS 的文件存放于此，它可以限制一些元素在_site 中的生成\n\nGemfile &amp;amp; Gemfile.lock\n\n存放项目所依赖的 Ruby gems，里面拥有存放页面的样式信息，当新加入了主题配置之后，需要使用bundle install指令安装新的配置才能使用。需要使用新的主题时，需要在_config.yml文件的there做更改。注意，使用了新的布局之后可能会导致一些布局不可用，例如“post”，因为在新的主题上可能没有定义这样的布局。所以使用新的布局之后要在_layout中查看一下是否有对应的布局可以使用。\n\nabout.md\n\n会存放有关在界面中的about的内容，生成的页面会出现在主界面上的位置，同理命名其他的文件也会在主界面的上方出现\n\n\n\nmakedown 语法\npermalink\n可以用于自定义所创建页面的URL。例如，permalink：/Jekyll/ 表示创建的页面会在主页面URL中后加上/Jekyll\n\nlayout\n表示自己所使用的界面样式，常见的值有post\n\n._config.yml\n\n\n  defaults：可用于写一些默认值，例如为layout设置默认值（要注意以下冒号的位置）\n    defaults:\n  - \n scope:\n   path: &quot;&quot;  # 这里填写此默认值影响的返回路径\n values:   # 这里补充默认值\n     layout: &quot;post&quot;\n    \n    再例如对图片文件的加载：\n    defaults:\n  -\n scope:\n   path: &quot;assets/img&quot;\n values:\n   image: true\n    \n    该例子表示，在html文件中可能加载图片信息的位置会在，assets/img的文件夹下寻找\n  \n\n\n\n常用指令\n\n  jekyll new 工程名  创建工程\n  bundle exec jekyll server   启动项目，启动项目之后可以在浏览器中访问http://127.0.0.1:400/看到效果。\n  jekyll new PATH --blank  创建新的空项目\n  jekyll build 或 jekyll b 构建项目，生成可部署的 _site 目录\n  jekyll serve 或 jekyll s  构建并运行项目，会自动监听文件变化，不需要反复执行\n  jekyll clean  清除所有的构建产物\n  jekyll new-theme  创建一个新的主题脚手架\n  jekyll doctor  诊断，输出所有已经废弃的依赖包或者有问题的配置\n\n"
} ,
  
  {
    "title"    : "MySql 学习笔记",
    "category" : "",
    "tags"     : " MySql, 数据库",
    "url"      : "/mysql",
    "date"     : "December 3, 2022",
    "excerpt"  : "MySQL是一种关系型数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。\n\n\n前言\n本人比较懒，所以专门挑了一个篇幅比较少的MySql来写博客，主要还是针对笔记的性质来写的。如果有错欢迎指正。\n\n\n\nMySql 基本语法\n1.分组\nGROUP BY 字段名 [HAVING 条件表达式]\n\n2.去重\n在 select的字段前面加上distinct就可以去重\n\n3.插入多行数据\n\n格式：\ninsert into 表名[（字段名1...",
  "content"  : "MySQL是一种关系型数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。\n\n\n前言\n本人比较懒，所以专门挑了一个篇幅比较少的MySql来写博客，主要还是针对笔记的性质来写的。如果有错欢迎指正。\n\n\n\nMySql 基本语法\n1.分组\nGROUP BY 字段名 [HAVING 条件表达式]\n\n2.去重\n在 select的字段前面加上distinct就可以去重\n\n3.插入多行数据\n\n格式：\ninsert into 表名[（字段名1，字段名2,…）] values(值\\(a_1\\)，值\\(b_1\\),…), (值\\(a_2\\),值\\(b_2\\),…)\n\n示例：\ninsert into mywork\nvalues(&quot;小明&quot;,18),(&quot;小红&quot;,20)\n\n\n4.外连接\n语法：\nselect 字段列表 from 表1 [inner] join 表2 on 连接条件;\n示例:\n\nselect * \nfrom wuhan.commercialhousing \njoin secondhouse on district regexp qy\nlimit 10;\n\n\n同理还有左外连接：left join，右外连接：right join\n\n5.排序\n\n排序语句：order by 字段值[ desc | asc]\n其中 asc是表示升序（默认），表示降序\n\n示例：\nselect customer_number\nfrom Orders\ngroup by customer_number\norder by COUNT(*) desc\n\n\n6.if语句\n\n语法：IF(expr1,expr2,expr3)\n\n如果 expr1 是TRUE (或者expr1 &amp;lt;&amp;gt; 0 且 expr1 &amp;lt;&amp;gt; NULL)，则 IF()的返回值为expr2; 否则返回值则为 expr3。IF() 的返回值为数字值或字符串值，具体情况视其所在语境而定。\n\n7.ifnull语句\n\n语法：IFNULL(expr1,expr2)\nexpr1不为NULL，则 IFNULL() 的返回值为expr1; 否则其返回值为 expr2。IFNULL()的返回值是数字或是字符串，具体情况取决于其所使用的语境。\n\n8.正则语句\n\n关键字：regexp\n\n使用语法：被检测字符串 regexp [binary] 正则语句\n不区分大小写（即大写和小写都匹配）。为区分大小写，可以使用 BINARY 关键字例如：\nWHHERE name REGEXP BINARY &#39;Hern .000&#39;\n\n\n9.存在判断语句 exists\n\n当我们只需要判断某些满足特定条件的数据是否存在时，为了提高效率，我们不需要将所有的数据捞出来判断，只需要判断是否存在就可以了。\n采用exists即可满足需求。\n示例：\nselect exists (SELECT *\n        from  a \n        where\n        money&amp;gt;0 and time&amp;gt;&#39;2021-03-05&#39;;\n)\n\n\n10.表格合并\n\nUNION操作符合并两个或多个 SELECT 语句的结果。\nUNION关键字应处于两次查询之间\n默认地，UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL。\n注意：union的优先级低于order by，即先合并再排序。\n示例1：\nSELECT column_name(s) FROM table1\nUNION\nSELECT column_name(s) FROM table2;\n\n示例2：\nSELECT column_name(s) FROM table1\nUNION ALL\nSELECT column_name(s) FROM table2;\n\n\n11.数据修改 update\n语法：\nUPDATE &amp;lt;表名&amp;gt; SET 字段 1=值 1 [,字段 2=值 2… ] \n[WHERE 子句 ]\n[ORDER BY 子句] [LIMIT 子句]\n\n\n\n\nmysql常用函数\n\n日期比较函数：datediff\n\n语法：DATEDIFF(date1,date2)\n参数说明\ndate1: 比较日期1\ndate2: 比较日期2\n\nDATEDIFF函数返回date1 - date2的计算结果，date1和date2两个参数需是有效的日期或日期时间值;如果参数传递的是日期时间值，DATEDIFF函数仅将日期部分用于计算，并忽略时间部分(只有值的日期部分参与计算)\n\n示例：\nSELECT DATEDIFF(&#39;2022-04-29&#39;,&#39;2022-04-30&#39;); --返回 -1\nSELECT DATEDIFF(&#39;2022-04-30&#39;,&#39;2022-04-29&#39;); --返回 1\n\n\n日期加减函数：date_add\n\n语法：date_add(‘某个日期时间’,interval 1 时间种类名)\n示例：\n\nselect date_add(data, interval 1 year); --加1年\nselect date_add(fata, interval 1 month); --加1月\n\n\nquarter:季，week:周，day:天，hour:小时，minute:分钟，second:秒，microsecond:毫秒\n注：也可以不用变量，直接加减某个时间，如：select date_add(‘1998-01-01’, interval 1 day);\n\n字符串专题\n字符串拼接：concat\n\n将给入的参数逐一拼接\n例如：\nconcat(‘%’,’abc’,’%’) --结果为%abc%\n\n字符串与日期的相互转换\n使用语法：\nDATE_FORMAT(date,format) 日期转字符串\nSTR_TO_DATE(str,format) 字符串转日期\n示例：\n\nselect DATE_FORMAT(now(),&#39;%Y-%m-%d %H:%i:%s&#39;);\n\n返回：2022-12-01 10:07:41\n\nselect str_to_date(&#39;2022-8-7&#39;,&#39;%Y&#39;)\n\n返回：2022-00-00\n因为这里只获取到了年份，但是作为datetime对象需要补全月份和日所以会有-00-00出现。\n\n组内字符串拼接 group_concat\n\n语法：\nGROUP_CONCAT([DISTINCT] column1 [ORDER BY column2 ASC|DESC] [SEPARATOR seq])\n\n\n将分组中column1这一列对应的多行的值按照column2 升序或者降序进行连接，其中分隔符为seq\n如果用到了DISTINCT，将表示将不重复的column1按照column2升序或者降序连接\n如果没有指定SEPARATOR的话，也就是说没有写，那么就会默认以 ‘,’分隔\n\n字符串截取 substring\n语法格式：SUBSTRING(str, begin, end)\nsubstring函数可以将字符串str从下标begin到end截取下来（下标从1开始计算）（闭区间包括begin和end），其中end默认为空，当end省略时表示截取到字符串最后。\nmysq支持逆向访问，即可以使用负数表示下标，负数的下标即从右边开始计算的下标。\n示例：\nselect substring(&quot;01234&quot;,1,2);\t-- 01\nselect substring(&quot;01234&quot;,1);\t-- 01234\nselect substring(&quot;01234&quot;,1,100); -- 01234\nselect substring(&quot;01234&quot;,-1);\t-- 4\n\n\n字符串大小写转换\nupper(str)  字符串中所有字母转大写\nlower(str)  字符串中所有字母转小写\n\n\n\n技巧语法\n\n查询排名前n的数据\n\n使用limit n语句实现（该语句需要放在查询结果的最后）\n\n示例：\n\nSELECT * FROM wuhan.secondhouse limit 10;\n\n\n使用正则配对字符串\n\n使用regexp关键字实现\n格式： 字段值 regexp 正则字符串\n示例：\n\nselect distinct district,house_type,wq_area,wq_num,yqy_area,yqy_num\nfrom commercialhousing\nwhere district regexp &#39;江岸&#39;;\n\n"
} 
  
  
  
]
