[
  
  {
    "title"    : "研究生英语期末复习",
    "category" : "",
    "tags"     : " English, 期末考试",
    "url"      : "/postgraduateEnglish",
    "date"     : "September 19, 2024",
    "excerpt"  : "  研究生英语，作为高等教育阶段的一个重要组成部分，是为已具备本科或相当水平英语能力的研究生所设计的课程体系。这一阶段的英语学习，不仅旨在进一步提升学生的英语综合应用能力，包括听、说、读、写、译五个方面，还强调在专业领域内有效运用英语进行学术交流和研究的能力。\n\n\n前言\n  本博客是针对期末英语的知识点整理，仅表示个人看法，如果整理有疏漏的地方欢迎和我讨论。最后希望你能认真复习，祝你取得一个好成绩！\n\n\n试题\n试题介绍\n\n  试题内容如下表所示\n\n\n  \n    \n      题型\n   ...",
  "content"  : "  研究生英语，作为高等教育阶段的一个重要组成部分，是为已具备本科或相当水平英语能力的研究生所设计的课程体系。这一阶段的英语学习，不仅旨在进一步提升学生的英语综合应用能力，包括听、说、读、写、译五个方面，还强调在专业领域内有效运用英语进行学术交流和研究的能力。\n\n\n前言\n  本博客是针对期末英语的知识点整理，仅表示个人看法，如果整理有疏漏的地方欢迎和我讨论。最后希望你能认真复习，祝你取得一个好成绩！\n\n\n试题\n试题介绍\n\n  试题内容如下表所示\n\n\n  \n    \n      题型\n      分值\n      来源\n    \n  \n  \n    \n      阅读理解\n      40\n      精读四篇线下阅读+一篇显示泛读文章\n    \n    \n      词汇\n      10\n      精读文章的线上词汇题目原题\n    \n    \n      完型填空\n      10\n      精读文章的线上完型填空原题\n    \n    \n      翻译\n      10\n      英译中-线下精读文章原题\n    \n    \n      作文\n      30\n      无\n    \n  \n\n\n\n阅读理解（译文）\n\n4篇泛读\n\nUnit 3 Passage A : Spillonomics: Underestimating Risk\n\n回想起来，模式似乎很清楚。早在“深水地平线”钻机自爆前的很多年，BP石油公司为了省钱甘冒安全的风险就已经声名狼藉。2005年得克萨斯州炼油厂爆炸中有15名工人丧生。联邦监管机构和前国务卿詹姆斯·贝克三世领导的专门小组认为，削减成本是事故的部分原因。第二年，阿拉斯加腐蚀的管道将石油漏入普拉德霍湾。就连乔·巴顿那个对全球变暖持怀疑态度、来自得克萨斯州的共和党众议员，都谴责BP管理人员“对安全和环境问题表现得漠不关心”\n\n这种冷漠大部分源于对利润的过度追求，不管是什么情况。但似乎也还有另一个因素在起作用，一个更普遍的人性的因素。BP的管理人员在估计似乎不太可能发生但一旦发生就会带来巨大损失的事件真正会发生的可能性时，犯了一个可怕的错误。也许理解这一点最简单的方法就是思考一下BP高管们如今的想法。显然，考虑到清理费用和对BP声誉的影响，高管们真希望可以回到过去，多花些钱让“深水地平线更安全。他们没有增加这笔费用就表明他们认为钻机在当时的状态下不会出问题。\n\n尽管针对 BP高管的所有批评可能都是他们应得的，但是他们绝不是唯一艰难应对这种低概率、高成本事件的人。几乎每个人都会如此。“这些正是我们人类处理时很难做出合理反应的一类事件。”哈佛大学环境经济学家罗伯特·斯塔文斯说。我们经常犯两种基本的且性质相反的错误。当一件事情是很难想象的，我们往往会低估它的可能性。这就是众所周知的黑天鹅(稀有之物)现象。大多数在“深水地平线”工作的人可能从未经历过钻井平台爆炸。因此他们认为这不会发生，至少不会发生在他们身上。\n\n同样,不久以前,本·伯南克和艾伦·格林斯潘也喜欢称全国房地产市场没有泡沫因为以前从未有过泡沫。华尔街交易员也持同样观点，他们建立的数学模型根本不存在房价下降的可能性。许多购房者签订了负担不起的抵押贷款，相信一旦其价格上涨，他们可以再融资或卖掉房子。所以看起来房价过去一直是在上涨。\n\n另一方面，当一个不太可能发生的事件是很容易想象时，我们经常会走向另一个极端，高估它的可能性。“9·11”恐怖袭击后，美国人取消了飞机旅行，转而驾车上路。2002年在这个国家没有发生恐怖袭击，但更多的驾车出行显然导致了交通死亡人数的增加。\n\n当风险非常高时，应该由政府负责以帮助避免这些完全人为的错误。如果让市场自行其是，往往做不到这一点。然而，在“深水地平线”这件事情上，政府的政策实际上起到了相反的作用。它助长 BP低估了灾难的可能性。\n\n埃克森公司瓦尔迪兹漏油事件发生后，在1990年的一个法案很少引人注意的一项条款中，美国国会将钻机泄漏清理费用的责任上限定为7500万美元。即使对旅游业、渔业等造成的经济损失高达数十亿美元，责任方也仅需要支付7500万美元。(在这种情况下，BP已同意对它认为合法的索赔，放弃这一上限。)在华盛顿负责汉密尔顿项目的麻省理工学院经济学家迈克尔·格林斯通说这一法律从根本上扭曲了公司的决策。如果赔偿没有上限，管理人员就会权衡油井可能的收益以及钻井的成本和损害赔偿的风险。而有了这个上限，他们就可以在很大程度上忽略清理费用之外的潜在损害赔偿。所以在损害可能非常可怕的地方，如靠近海岸线的地方，他们也会钻井。换句话说，人类的弱点使得BP 公司高管低估了低概率、高成本事件的可能性。而联邦法律则使得他们低估了成本。\n\n在“深水地平线”之后，美国国会和奥巴马政府毫无疑问希望通过相关法律以减少再次出现“深水地平线”这样的风险。当然他们可以采取一些明智的做法，如解除责任上限，摆脱石油业对监管人员的影响。不过，如果认为我们目前仍然低估的只是那些突然间引人注目的风险，那是非常愚蠢的。\n\n大的金融风险已不再是房地产泡沫。相反它可能是医疗保险、医疗救助和社会保障的增长在未来将会导致的巨额赤字，以及贷款人可能最终不愿再向华盛顿扩大信贷。诚然，一些经济学家和决策者坚持认为国家还不应该考虑如何应对这种可能性，因为贷款人与美国政府的关系从来没有恶化过，也没有迹象显示现在就是这样。但这是不是让人联想到伯南克和格林斯潘对住房市场的老调呢?\n\n当然，即使油井正常运转时，油井(与其他事物一起)也会向大气中排放温室气体。科学家们说，这些气体的积累已经可能在22世纪将地球温度提高至少3度，并导致干旱、风暴和更多的冰层融化。最近，研究人员的预测又提高了，地球温度有可能上升约12度。这样的气候变暖可能会在各大城市引起洪灾，并导致南极部分坍塌。\n\n这样的事情还没有发生过。即使想象它都是困难的。人们更容易做到的，是希望出现这种结果的可能性小到微乎其微。事实上，抱有这样的希望是自然的反应。但是，这并不代表它是明智的。\n\n\n\nUnit 6 Passage A : A Christmas Sermon on peace\n\n今年圣诞时节，人们困惑惶恐，内心无法宁静，外部没有和平。无论身置何处, 恐慌昼夜萦绕于胸，无论走到哪里，战争的阴霾时时笼罩天空。我们这个世界已厌倦了战争，无论何处都危机四伏。各位教友，即便如此，我们不能把祈求和平、善待众人的基督圣训视作不切实际的虔诚美梦。如果不能友善待人，我们所有和所能必将由于使用不当而使我们走向自我毁灭。历史的经验告诉我们，战争早已过时。曾几何时，战争或有以毒攻毒之效，可以遏制邪恶势力的蔓延与发展，然而正是现代战争利器的巨大破坏力，使它再不能被视作打击邪恶的正义之举。因此，如果我们认为人生值得一过，如果我们认为人类有权生存，那么我们就必须抛弃战争，另寻他径。正因为如此，今天上午让我们探讨怎样才能和平，重新思考“世界和平，人人友爱”的圣诞梦想的含义。说到何以有和平，我认为生活于现代的人们确实要好好研究非暴力主义的意义，它的哲学和战略。\n\n关于非暴力主义的含义，我们在美国争取种族正义的斗争中，已经有所尝试。现在是把非暴力主义运用到人类的各种冲突中去的时候了，也就是说要在国际范围内推行非暴力主义。\n\n现在，我首先要说的是，要想世界和平，我们就必须忠于芸芸众生，而不是忠于一隅。我们的忠心必须超越我们的种族和部落，超越我们的阶层和国家;这就意味着我们必须放眼世界。没有一个人能够独自生存，没有一个国家能够孤立存在。我们越想独立世上越有战争的可能。上帝的审判就在眼前，我们要么学会像兄弟一样和平共处，要么像一群傻瓜统统消失。\n\n的确，无论是国家还是个人，我们都要相互依存。我以前和你们说过，若干年前我去过印度。那次经历美妙无比，但是我现在要告诉你们，其中也有不少令人沮丧的时刻。眼见数百万人饿着肚子上床睡觉，怎能不让人沮丧?目睹成千上万的人晚上睡在马路边如何不让人沮丧?每天晚上有一百多万人睡在孟买的街道旁，有五十多万人睡在加尔各答的道路边。他们无家可归。他们没床可睡。此情此景，我的心中不禁要问:“身在美国的我们能袖手旁观、不闻不问吗?”有个声音答道:“不能!”我突然想到就在美国，就在这儿，我们每天要花费数百万美元储藏过剩的食物。我对自己说:“我知道有个地方，可以免费储存那些食物，就在数百万上帝的子民干瘪的肚子里。他们有的在亚洲、非洲，有的在拉丁美洲，有的甚至来自我们自己的国度，饥饿与他们的睡眠相伴。”\n\n归结起来，就是一点:一切生命休戚相关。我们大家都身不由己，置身在一个相互关联的网络之中，我们共穿同一件命运的外衣。不管是什么，只要直接影响到一个人，就会间接影响到所有人。我们生来就得共处,因为世界是相互关联的。你是否偶尔想到过如果不依靠世上的大部分人，你早上连班都上不了呢?你起了床，去洗手间，伸手要拿海绵，那是经过太平洋上的某个岛民之手你才有的。你要拿块肥皂，那是经过某个法国人之手才有的，然后，你走进厨房用早餐，你的咖啡是经过某个南美人之手才有的。也许你想喝茶，那是经过某个中国人之手才有的，或许你很想喝一杯可可茶，那是经过某个西非人之手才有的。你伸手去拿烤面包，那是经过某个会说英语的农夫之手才有的，更不必说面包师傅了。你的早餐还没吃完，就和大半个世界的人产生关联了。这就是我们的宇宙的构造方式，这就是宇宙相互关联的属性。一切事物相互联系，我们只有认识到这一基本事实，世界才有和平。\n\n其次，我呼吁，要实现世界和平，所有众人、所有国家必须坚守非暴力信念，坚信目的、手段必须互渗互连。手段与目的的关系一直是历史上颇有争议的重大哲学问题。总有人认为只要目的正确，可以不择手段，重要的是要达到目的。\n\n因此他们说，假如你正寻求建立一个公正的社会，重要的是建立与否，而手段如何实在无关紧要。只要能让这样的社会建立起来,任何手段都行,包括暴力手段,欺诈手段甚至于可以通过非正义的手段达到正义的目的。纵观历史,总有些人是这样认为的。然而世上永远不会出现和平，除非人们普遍认识到手段与目的并非毫无关系，因为手段让理想体现在行动中，让目的体现在过程中。通过邪恶的手段终归达不到好的结果，因为手段相当于种子，而目的就像是果实。\n\n世上所有伟大的军事天才都谈论过和平，这是最让人感到奇怪的事情之一。古时的征服者们为了所谓的和平一路杀来，亚历山大大帝，裘力斯·恺撒，查理大帝，还有拿破仑，他们寻求和平的世界秩序的做法都一样。要是你真的好好读了《我的奋斗》一书，你就会发现希特勒曾经声称，他在德国所做的一切都是为了和平。今日世界的领导者们谈起和平来头头是道。每次美军在北越投下炸弹，约翰逊总统都会就和平夸夸其谈一番。问题出在哪里?他们是把和平当作一个遥远的目标，当作我们所追求的一个目的来谈的，可是总有一天我们一定会看到，和平不仅仅是我们追求的一个遥远的目标，而且是我们达到这一日标的一个途径。我们必须运用和平的途径达到和平的目的。归根结底一句话，手段和目的是一致的，因为目的先存于手段之中，破坏性的手段终究不能带来建设性的目的。\n\n再者，我要说，若想世界和平、世人和睦，必须以非暴力形式证明所有人的生命都是神圣的。每个人都很重要，因为他们都是上帝之子，因此，我们说“勿杀生”，是指人的生命是神圣的，不应在战场上被轻易夺走人的生命远非旋转电子构成的奇妙之物，也不是无尽燃烧的焖火中升起的一缕轻烟。人类是上帝的子民，是上帝按自身的样子造出来的，因此必须得到应有的尊重。除非天下的人们懂得这一点世界的各国看到这一点，否则我们就会争战不断总有一天有人会提醒我们，即使我们之间可能存在政见的不同，存在意识形态的不同，但是，越南人是我们的兄弟，俄国人是我们的兄弟，中国人也是我们的兄弟，终有一天我们会坐在一起，共享手足之情。在基督里不分犹太人和异教徒，不分男人和女人，不分共产主义者和资本主义者。在基督里，无论如何，不分自由的和不自由的。在基督里，我们同为一体。一旦我们真的相信人格的神圣性，我们就不会压榨别人，就不会用压迫的铁蹄践踏别人，就不会伤人性命。\n\n\n\nUnit 9 Passage B : Fearing Fear Itself\n\n孩子能应对多少恐惧，焦虑和风险?直到19世纪末，多数人认为这一问题的答案是“相当多”。亚里士多德本人说可以将教育定义为:教会我们正确处理恐惧。人们普遍认为恐惧感对孩子的性格形成有积极意义。1819年，教会传道会声称,“孩子们惧怕老师是必要的”，并详细阐述了恐惧在儿童教育中的极端重要性。儿童的恐惧经历有时被描述为开发其想象力和创造力的必要条件。例如，在1848年，ChristianRegister 周刊向家长们提出忠告:一个“从来不知道任何恐惧的孩子不可能富有想象力:感受不到世界的奇妙，没有生命的冲动，也没有敬畏或崇拜。”\n\n与此形成反差的是当今的文化:娱乐活动满足各个层次的年龄需求;用词不当(或微歧视)被说成可以引发焦虑症;分离带来的终极恐惧被看作对儿童具有巨大伤害，如果处理不好，可能会毁掉孩子的一生。童年的恐惧和对这些恐惧的惧怕似乎无处不在:恐惧霸凌，更怕公共集会及枪击。害怕电视中不断出现的战争和事故场面。当今，由于周遭世界充盈着各种攻击，多数家长不会像从前那样试图吓唬孩子，不会鞭打孩子或是让孩子像裁着镣铐的囚犯一样于一年的苦力。我们尽自己所能了解孩子的忧虑，竭尽全力不惜代价减少他们的恐惧。\n\n新旧观念的转变可以追溯到19世纪后期心理学的出现。心理学的先驱 G.斯坦利·霍尔强烈反对恐惧情绪，认为它给儿童一生造成极具破坏力影响。因而，曾经被认为是儿童性格形成关键因素的恐惧情绪，因其对儿童成长有害而遭到公开谴责。19世纪90年代，霍尔所从事的研究呼吁对恐惧重新定位。他没有将儿童的恐惧–亚里士多德所说的世间教师，视为人生的正常现象，他认为应该将其视为对儿童健康的威胁。医学文献已有大量有关病态恐惧即心理忍惧危险性的记载，霍尔呼吁人们关注这种危险的存在。霍尔在1921年出版的《儿童生活及教育研究》一书中指出，他的研究显示了“由于不明智的恐惧所导致的各种形式的拘捕乃至性变态的数量。”他同时指出:这些“不明智的恐惧’通常归因于不适当的育儿方式。\n\n霍尔的观点被心理学家以及育儿专家和教育工作者广泛接受。1917年，《母亲杂志》的一位答读者问专栏作家要求当局“介入并阻止我们将儿童变成精神和道德有缺陷的人”这位匿名作者断言“恐惧是一种疾病，通常源于儿时受到的不当的培养和虐待”。\n\n在第二次世界大战爆发前的几十年里，关于恐惧情绪对儿童福祉构成威胁的说法得到了更多的重视。此时，育儿忠告让父母作为监护人承担起防止幼儿恐惧的责任。行为心理学的创始人约翰·沃森认为,“父母的主要工作应该是防止恐惧，因为一些恐惧极难治愈。”\n\n育儿指导意见指出，恐惧是一个复杂而危险的问题，在儿童人生的每个关键时期,成年人应担起保护儿童使命。因此，1934年，一个建议专栏刊登的题为《克服恐惧:幼儿园的现代方法》的文章告诫“母亲和保育员”“避免引起儿童恐惧的任何理由”。人们用危言耸听和说教的口吻对不了解恐惧对儿童造成伤害的母亲进行谴责。1922年《麦克卢尔杂志》的一位评论员写道:现如今，普通母亲跟自己的祖母不知道细菌存在的危险一样，对这些思想和精神上的敌人，这些暗藏着同机伤害孩子的心理危害知之甚少。一些专家担心家长不能有效应对儿童的恐惧，而这些儿童被认为比以前想象的要脆弱得多。\n\n20世纪 20-30年代中形成的儿童脆弱性这一观念的发展，与以儿童为中心的生育文化的出现如影随形，在中产阶级中尤其如此。父母和教育工作者都被警告他们有责任保护儿童免受对其心理健康的威胁。一位评论员批评家长对他们的孩子施加了太大的压力，并警告,“从幼儿园到获得大学学位这条充满荆棘道路上的各个阶段，孩子和青少年都可能在压力下崩溃。”来自父母的压力和纪律约束被指引发儿童的恐惧和焦虑。父母被告知要肯定他们的孩子，鼓励而不是训斥他们，也不要给他们施加太大的压力。\n\n在20世纪30年代，教育工作者也接受了让儿童远离恐惧的呼吁。1939年，一位老师在《教育杂志》上写道,“很多男孩和女孩都患有恐惧症”“很惭愧，我承认学校经常使情况变得更糟。”其他人认为，家庭作业和考试可能会让孩子承受过度的压力和紧张。人们经常声称，家庭作业导致了“儿童脊柱弯曲、夜惊和神经衰弱。”为了回应这些主张纽约的公立学校四年级前禁止留作业，在圣地亚哥，学校到八年级才给学生留作业。\n\n起初，只有少数其中主要是中产阶级父母响应放宽纪律约束并不断安抚孩子的呼吁。但逐渐地，采用心理学专业手段来应对儿童的恐惧变成等同于负责任的父母的做法。\n\n尽管害怕恐惧，但几十年来大多数人都认为，一定程度的逆境可以提高心理适应性。灾难中幸存的儿童更具心理复原力，专家说，尤其是这种情感支持源于家人时。但是，到了 20世纪 70年代中期，这个论调开始发生变化:研究人员开始更仔细地审视这个问题质疑儿童心理适应性的程度，转而强调儿童的脆弱性。到20世纪80年代，“易恐儿童-词被普遍使用:这被认为不是某些孩子独有的特定问题，而是所有儿童都存在的问题。\n\n对这一概念的研究表明，大多数已发表的文献将“易恐儿童”视为童年时期相对显而易见的特征。这是一个想当然、很少人论述的观念;就个体而言，由于身体及其他感知尚不成熟，儿童被认为容易受惊吓。另外，这种易受惊吓的特征被描述成孩子们与生俱来的。\n\n孩子们容易受到惊吓，这种观念促使人们不断地夸大儿童所面临的威胁。我所称之为的“犯病的童年时代”已经获得其内在的逻辑性。墨尔本大学心理学家尼克·哈斯兰的研究中强调了这一趋势的重要性，他报告说，自20世纪80年代以来，社会心理学家使用的关键术语如“滥用”、“欺凌”和“创伤”已被应用于越来越多的体验中。具体而言,这些术语越来越多地被应用在先前被解释为令人不愉快但不会引起创伤的情境中。\n\n这一新观点反映了当前的趋势，即通过恐惧的视角来看待童年的几乎每个方面。但这些恐惧很少直接来自儿童的经历。它不是传统意义上的儿童焦虑，如在21世纪对恐惧的叙述中强调的对黑暗的恐惧或被父母抛弃的焦虑。相反，儿童的恐惧是成年人想象出来的，并且经常表达出潜藏在父母心中的焦虑。对身份不确定的恐惧、对失败的恐惧、对自卑的恐惧、对达不到标准的恐惧、对考试对学生心理健康的有害影响的恐惧、对竞争和竞技体育的恐惧以及对纪律的恐惧，都是教育辩论中反复出现的主题。通常，这些紫绕心头的恐惧会被放大，对弱小的儿童所产生的焦虑情绪变得活灵活现。\n\n那么，孩子比过去更充满恐惧了吗?不幸的是，这不是一个可以以任何程度的科学精度来回答的问题。然而，显而易见的是，与过去相比，现在人们更加频繁地谈论与童年相关的恐惧和脆弱性。儿童的恐惧和成年人因孩子而产生的恐惧经常交织在一起讨论现如今这两种恐惧带给人的痛苦超过以往任何时候。事实上，现在有真实的宣传资料将孩子的害怕归咎于父母的恐惧。几十年来，父母被建议保护孩子远离恐惧，如今却被指责对他们孩子的恐惧负有责任。\n\n充满恐惧的“直升机家长”经常受到批评，因为他们限制了孩子的健康发展。今年六月发表在《发展心理学》杂志上的一项研究得出的结论是，“受到家长过度控制的儿童可能缺乏能力成功应对人学以及适应学校环境等挑战”。其他人认为，“直升机育儿”会阻碍孩子满足“自主和能力这两种基本心理需求\n\n对直升机育儿的批评者忽视了迫使许多父母采用这种做法的强大文化压力。所谓的专家们应该宽容些，不要用不断的警告和建议来批评家长，而是反思一下他们提供的相互矛盾的建议带来的有悖常情的结果。如果社会学会信任父母，并且不再试图让他们如此恐惧，那么童年世界将会变得更加美好。\n\n\n\nUnit 11 Passage B : Will Tech Revolution Overwhelm Global System?\n\n当中国科学家贺建奎声称用一种先进的基因编辑技术(CRISPR)从一个新生儿身上去除了一种导致艾滋病病毒的基因时，包括中国的医疗机构在内的全世界都震惊了，谴责这种努力是“扮演上帝”。几天后，成千上万的韩国出租车司机走上街头抗议一个商业共享搭车应用程序，他们声称这种程序会破坏他们的工作并威胁他们的生计。\n\n这两个时刻都是分水岭，说明了一个毫无准备的世界中存在的潜在风险，因为一场新兴的技术革命正在超越管理它们所需的规则、规范和标准。\n\n在未来的20年里，世界上将出现更多的技术变革，大大超越过去20年中互联网和应用程序经济的崛起。被称为“第四次工业革命”的是人工智能/大数据/机器人技术3D打印、生物技术和新材料的数字融合，它将推动未来十年及以后的经济增长。它将改变工作的本质，改变我们打仗、生活和互动的方式。\n\n我们正在进人这样一个世界，这个世界里有自动驾驶的电动汽车，有物联网上以数十亿连接的传感器和设备，有自主武器、数字化贸易、芯片医学实验室、3D 印刷厂和精准农业等，不一而足。\n\n但危险正在聚集。因为这一技术变革是在支撑全球贸易、金融和政治稳定的整个国际经济和政治体系受到侵蚀之际展开的。\n\n首先，世界贸易组织及其“皇冠之宝”，即争端解决机制的未来正在受到质疑。大家一致认为，随着贸易保护主义在全球的兴起，世贸组织必须进行改革。最初的谈判引发了人们对其未来的担忧，而快速增长的数字商业的全面规则仍然难以实现。世界对人工智能和机器人技术、自动驾驶车辆和其他新兴技术将采用什么标准和道德规范?\n\n同样，如何解决生物科学、合成生物学和生物工程领域的突破所引发的伦理问题?为了达到效果，必须取得全球性的共识。我们知道移除一个基因将如何改变其他基因之间的相互作用吗?更大的问题仍将是有关21世纪经济的新的原材料–数据。谁拥有数据?什么是隐私权?少数几个主要是美国和中国的大型科技公司统治着数据世界。大技术应该像欧盟所寻求的那样，被拆分或监管吗?\n\n一些人担心能自我复制的人工智能机器人将控制或替代人类。这些担心很可能是被误导的。机器智能“深度学习”是基于神经网络，模拟大脑。我们至今仍然不清楚大脑中十亿个以上的神经元是如何工作的。因此，机器智能要具备人类智能的所有维度，很可能需要几十年的时间–如果能实现的话。\n\n然而，人工智能/机器人技术正开始影响未来的工作。随着自动驾驶汽车的普及出租车司机、卡车司机和公共汽车司机会怎么样呢?人们辩论着机器人将在多大程度上取代工人，以及机器人将如何创造新的工作岗位，让工人与机器人一起工作，有些人称之为“混合未来”。但这种技术变革势必要求所有国家重新考虑教育、培训、社会安全网，甚至\n\n\n\n1篇精读\n\nUnit 2 Passage A : World English: A Blessing or Curse?\n\n2000年,语言学家、威尔士人格兰维尔·普莱斯,在他编辑的《英国与爱尔兰的语言》中发表了如下的观点:\n\n因为英语是个杀手，正是英语，导致坎伯兰语、康沃尔语、诺恩语和马恩语灭亡。在那些岛屿的部分地区,还有较大规模的群体讲比英语更古老的当地语言。但是，现在日常生活中，英语无处不在，人人--或者说--几乎人人都懂英语。英语威胁到那三种遗留的凯尔特语:爱尔兰语、苏格兰盖尔语和威尔士语，……所以必须意识到，从长远来看，这三种语言的未来……十分危险。\n\n\n在此几年前，1992年，英国学者罗伯特·菲利普森(他如今在丹麦工作)在牛津大学出版了一本书，名为《语言领域的帝国主义》。在书中，他指出，主要的英语国家、世界范围内英语教学产业，尤其是英国文化委员会，实施的是语言扩张政策。他还把这种政策和他所称的“语言歧视”(这个情况类似于“种族歧视”“性别歧视”)联系在一起。在菲利普森看来，在以“白人”为主的英语世界中，起主导作用的机构和个人，或故意或无意，鼓励或者至少容忍英语大肆扩张，他们当然不反对英语的扩张。英语的扩张开始于大约三个世纪以前，最初的表现形式是经济与殖民扩张，\n\n菲利普森本人为英国文化委员会工作过几年。和他一样，还有一些母语为英语的学者，也试图强调英语作为世界语言的危险。在过去几十年里，人们从三个群体的角度，就英语的国际化进行了广泛的讨论。第一个群体是ENL国家，英语是母语(这个群体也叫“内部圈”);第二个群体是 ESL国家，英语是第二语言(“外部圈”);第三个群体是EFL国家，英语是外语(“扩展圈”)。二十世纪八十年代，这些词语开始流行。从那时起这第三圈实际上已扩展到全球范围。\n\n从来没有像英语这样的语言，既有利也有弊。曾经有许多“世界语言”，例如:阿拉伯语、汉语、希腊语、拉丁语和梵语。总的来说，我们现在认为这些语言比较好，经常以赞美、感激的语气谈论与它们相关的文化以及它们给世界带来的变化。我们这样的态度没有什么不妥，因为那些语言现在都不构成严重威胁。\n\n我们现在可以冷静地讨论古汉语对东亚或古拉丁语对西欧的影响。但是，我们与英语关系太紧密，无法同样冷静地分析、评价英语。在对英语的审判中，陪审团还没有露面，可能需要好几个世纪才能做出裁决。但即使如此，值此欧洲语言年，我们可以提出这个问题:普莱斯和菲利普森就我此时使用的语言对我们提出的警告是否有道理。\n\n当然，不难发现有这种情形:人们也许咒骂英语。澳大利亚就是一个例子。澳大利亚常被看成是不折不扣的英语国家。到那里的第一批欧洲人经常使用拉丁语描述、谈论这个地方。“澳大利亚”这个词就是拉丁语。显然当时没有人想到可以简单地称它为“南方(这就是“澳大利亚”的含义)。此外，在澳大利亚南部，有一大片土地叫“纳拉伯平原，其中，第一个词听起来像澳大利亚土著语言，但nullarbor是拉丁语，意思是“没有树木”最重要的是，早期的定居者把这个大陆称为“terra nullius”。1999年的《世界英语电子百科词典》是这样解释“terra nullius”这个拉丁词组的:\n\n…指这样一个想法和法律概念:第一批欧洲人到达澳大利亚时，这片土地不属于任何人，因此可以随意定居。这种观点已被判定是没有法律效力的。\n\n\n但是，只是最近才这样判定的。欧洲人刚来的时候，澳大利亚人口稀少–只不过有人居住而已–无论从哪个海岸到哪个海岸，无论从哪个方向。当时部落和语言都有几百种。其中许多语言现在已经灭亡了，而正在灭亡的更多。这些死亡的和正在死亡的语言，大都被多种皮钦英语或者通用的澳大利亚英语所取代。这或者是令人哀伤的损失，或者是进步的代价，看你怎么看了，\n\n但是，同时有一个问题:土著语言的灭亡能完全归咎于英语吗?最早发现澳大利亚的欧洲人是荷兰人，他们的语言本可以成为殖民与定居中使用的语言。任何定居者的语言都可能有同样的作用。例如，如果蒙古人能维持他们幅员辽阔的欧亚帝国，蒙古语可能就会成为世界语言，传播到澳大利亚。再例如，如果历史的车轮发生些许偏转的话，那么今天的世界语言有可能是阿拉伯语，一种在西亚和北非的通用语言，如今还影响着许多其他较小的语言，包括科普特语和柏柏尔语。西班牙语对所谓 “拉丁” 美洲的土著语言产生了消极影响，而俄语从欧洲传到西伯利亚太平洋地区。如果英语是个祸害，是个杀手，那可能仅仅是因为任何大的语言都可能会影响和威胁到较小的语言。\n\n但许多人认为英语是有益的。我这里暂不讨论任何世界语言具有的明显优势，例如庞大的交流网络、发达的文学与传媒体系、强大的文化与教育机构。让我们看看与此不同的一些问题:政治、司法与平等。这里我用南非为例来说明。十年前，南非结束了以种族隔离为原则的统治。在南非语(这种语言来源于荷兰语)中，这种制度叫“种族隔离(apartheid)”。出现这种制度，是因为欧洲血统的南非人群体–祖先主要是荷兰人的欧洲定居者–认为自己优于他们建立殖民地的当地人。说英语的、英国裔的南非人不是非常积极地反对种族隔离制度。在黑人的反对力量中，成员使用多种语言，他们起初缺少力量与组织。但是，使这种反对力量增强、更有组织性的语言是英语。对于他们来说，英语成为自由与团结的主要语言，而不是用来压迫他们的语言。今天，南非有十一种官方语言–英语、南非语和九种当地语言，包括祖鲁、恩德比利语和塞茨瓦纳语。但这九种语言中，南非黑人使用(或准备使用)哪一种作为本国通用语言呢?除了母语之外，他们希望子女还能熟练讲、写哪种呢?答案是，哪一种也不是。他们所希望的是英语，而且他们特别希望有一种合适的非洲化的英语。\n\n所以，对于澳大利亚土著人来说，英语是个祸害，而对南非的土著人来说，英语却有一些好处。……\n\n那么，在当今全球化而多样性受到威胁的世界里，我们应该怎样看待英语?在我看来，答案似乎很清楚。与很多事物一样，英语有时是福、有时是祸–对于个人、群 体、国家甚至国家联盟都是如此。东亚“阴”“阳”的象征意义也许能很好地说明这个问题。阴中有阳，阳中有阴。两者虽相反，但共存。就我们这里的问题来说，指的是在同一交流圈内。这种象征意义说明，使用世界通用语言的人应该努力尽可能用其利而避其弊。\n\n\n\nUnit 5 Passage A : A Beautiful Mind\n\n小约翰·福布斯·纳什–数学天才、理性行为理论创立者、预见会思考的机器出现的预言者，已经和来访者，也是一位数学家，共坐了将近半个小时。那是1959年春季一个工作日的傍晚时分，虽然才是5月，天气却很热，令人不太舒服。纳什颓然坐在医院会客室一角的扶手椅上，身上随意穿着的那件尼龙衬衫，松松垮垮地盖在他没有系皮带的长裤上。他的魁梧身躯现在就像一个布娃娃一样缺乏活力，他的轮优美细致的五官没有任何表情。他一直目光呆滞地盯着哈佛教授乔治·麦基左脚前方不远的地方，除了一次次重复着将垂在前额的略长的黑发拨开的动作，他几乎一动不动。麦基正襟危坐，被沉默压得透不过气来,并且非常清楚地意识到会客室的所有门都锁上了。麦基再也控制不住自己他尽量使语气温和，但听上去仍有些愠怒。“你，一个数学家,”他开始说道,“一个致力于研究理性和逻辑证明的人，怎么能相信外星人正在给你发送消息呢?怎么能相信你被来自太空的外星人选中要来拯救世界呢?怎么能……”\n\n纳什终于抬起头，用类似某种鸟类或者蛇一样冰冷而不动声色的目光，紧紧盯着麦基,“因为,”他慢慢地回答，带着南方人特有的慢条斯理的语气，好像自言自语一般“我的有关超自然生物的想法出现在我的脑海里的方式，是和我的数学思想一样的，所以我会认真对待。”\n\n这个来自西弗吉尼亚州布卢菲尔德的年轻天才–英俊、傲慢,而且非常古怪–在1948年闯人数学界。在接下来的十年，在那既以对人类理性抱有无上信念而著称，又以对人类生存怀有无尽忧虑而闻名的十年，纳什，用知名几何学家米克哈尔·格罗莫夫的话说，证明了自己是“20世纪后半叶最杰出的数学家”。策略博弈、经济竞争、计算机建筑学、宇宙的形状、虚构空间的几何学、素数的奥秘，都是他广阔的想象力涉猎的领域。他的想法属于那种非常深奥而又完全出人意料的类型，无疑会推动科学思维进入新的方向。\n\n数学家保罗·哈莫斯写道:“天才分为两种:一种就像我们大家一样，只是更为出色;另一种则是那些明显具备超凡人类灵感的人。我们都能跑步，有些人还能在四分钟内跑完一英里;但是我们大多数人所做的一切无论如何也无法与谱写出G小调赋格曲相提并论。”纳什的天分就属于那种常与音乐和艺术而非与最古老的科学紧密相连的神奇异禀。这不仅仅是指他的头脑运转更加灵敏，记忆力更加出众，或是他更能集中精力。事实上，直觉的火花稍纵即逝，不能用常理解释。就像其他伟大的数学直觉大师格奥尔格·费里德里希·伯恩哈德·黎曼、朱尔斯·亨利·庞加莱、斯里尼瓦萨·拉马努金一样，纳什先看到一个结论，然后才开始构筑耗费心力的证明过程。不过，即便在他尝试解释某个令人震惊的结论之后，对于那些企图跟随他的逻辑的人而言，他所选择的真正途径却始终是一个谜。20世纪50年代就在麻省理工学院认识纳什的唐纳德·纽曼曾经这样描述他:“其他人通常会在上山途中寻找攀登顶峰的道路。纳什却干脆爬上另外一座山，再反过来从那个遥远的山峰用探照灯搜寻上这座山峰的路。”\n\n没有人比纳什更对原创力着迷、更视权威、更珍惜自己的独立性。早在青年时代，他的身边就不乏 20世纪最伟大的科学权威，比如艾伯特·爱因斯坦、约翰·冯·诺伊曼、诺伯特·维纳，但是他没有加人任何一个学派，不是任何人的门徒，基本上是在既没有引导者，也没有跟随者的状况下前进。在他所做的从博弈论到几何学等多个学科的几乎所有工作之中，他对广为接受的知识、公认的方式以及根深蒂固的规律都持怀疑态度。他差不多一直是独立工作。通常他一边散步，不时用口哨吹出巴赫的作品，一边进行思考。纳什掌握的数学知识，主要并非来源于学习其他数学家已经取得的成果，而是自己重新发现这些成果中蕴藏的真理。他迫切希望取得一鸣惊人的成就，因此随时准备捕捉真正重大的问题。当他全神贯注地思考某个新的难题时，会留意到那些精通这个领域的人(他从来不认为自己已经精通某个领域)最初认为是幼稚或错误而不予考虑的角度。即便是在学生时代，他对旁人的怀疑、疑虑和嘲笑的漠视就已经到了令人畏惧的地步。\n\n纳什对理性以及纯粹思维的力量抱有旁人难以理解的绝对信念，即使是对一个非常年轻的数学家，即使是在计算机、空间旅行和核武器的新时代，都是如此。爱因斯坦就曾经责备他居然想不学物理学就修正相对论。他的偶像是牛顿和尼采这样的孤独的思想者和超人。计算机和科幻小说使他着迷。他把计算机称作“会思考的机器”，认为它在某些地方比人类优越。他一度被药物可能提高体力和智力水平的主意所蛊惑。他也曾沉迷于由超理性生物组成的外星人能够教会自己将所有感情置之度外的想法。他具有一种强迫性的理性，希望将生活中的决定–是搭乘第一部电梯还是等待下一部，到哪里存钱，接受什么样的工作，是否结婚–都转化为利弊得失的计算，转化为完全脱离感情、习俗和传统的算法法则或数学规则。即便是别人在走廊里随口和他打声招呼这样的小事情，也会引起他愤怒地发问:“你究竟为什么要向我打招呼?”\n\n他的同辈人基本上认为他实在不可理喻。他们说他“孤僻”、“傲慢”、“无情”“孤立”、“幽灵一般”、“隔绝”和“古怪”。他和同辈人只是混合在一起，却没有真正融合。他沉醉于自己的隐秘世界，根本不能理解别人操心的世俗事务。他的举止稍微有些冷淡有些高高在上，还有一点秘而不宜的样子,暗示了某种神秘而非自然的东西。他一贯冷漠但一时兴起也会喋喋不休地谈论外太空和地缘政治趋势，或做出孩子般的恶作剧，或者毫无征兆地勃然大怒。但是这些情感的进发总是和他的沉默一样神秘莫测。他和我们不一样”是人们常说的一句话。一位在普林斯顿高等研究院工作的数学家这样描述他在普林斯顿拥挤的学生舞会上第一次遇见纳什的情景:\n\n我从那里的一大群人当中一下子就注意到他。当时他坐在地上，身边围了半个圆圈的学生，正在讨论什么问题。他使我感到不安，给我一种奇怪的感觉。我觉察到一种特别陌生的东西，他在某些地方与众不同。我并不了解他究竞有多大本事也根本想不到后来他会做出那么大的贡献。\n\n\n但是他确实做出了贡献，而且非同凡响。而让人感到矛盾的是，他的许多想法本身并不晦涩。1958年，由于纳什在博弈论、代数几何学和非线性理论方面取得的成就,《财富》杂志推举他为同时活跃在纯粹数学和应用数学两个领域的新一代天才数学家中最杰出的人物。纳什对于人类竞争动态变化的洞察–他的理性竞争与合作理论–将会成为20世纪最具影响的思想理论之一。这一理论改变着新兴的经济学，其作用无异于孟德尔的基因遗传、达尔文的自然选择模式和牛顿的天体力学再造了当时的生物学和物理学。\n\n\n\nUnit 7 Passage A : Our Picture of the Universe\n\n一位著名的科学家(有人说是贝特兰·罗素)曾经做过一次有关天文学的演讲。他描述了地球如何围绕太阳运转，以及太阳如何进而围绕大量星群的中心运转，这些星群即所谓的银河系。演讲结束之时，一位坐在房间后排的矮个老妇人站起来说道:“你讲的一派胡言。这个世界实际上是驮在一只大乌龟背上的平板。”这位科学家不为所动，微笑着答道:“那么这只乌龟是站在什么上面的呢?”“你很聪明，年轻人，的确很聪明,”老妇人说，“但这就是一只乌龟驮着另一只一直驮下去的!”\n\n大部分人会觉得，把我们的字宙喻为一个无限的乌龟塔相当荒谬，可是我们凭什么自以为知道得更多一些呢?对于宇宙，我们了解多少，又是怎样知道的呢?宇宙从何而来,又将向何处去?宇宙有开端吗?如果有的话,在这之前发生了什么?时间的本质是什么?它会有一个终结吗?我们能回到过去吗?奇妙新技术的出现引发了物理学上的一些最新突破，为回答这些长期以来悬而未决的问题提供了建议。也许有一天这些答案会像我们认为地球绕着太阳运动那样显而易见–当然也可能像乌龟塔那般荒唐可笑。唯有时间(不管其含义如何)才能判断。\n\n依据一些早期的宇宙论的观点和犹太/基督/穆斯林教派传统的观点，宇宙起源于一个有限的并且不太遥远的过去的时间。对这样一个起源，有一种观点是感到必须有“第一原因”来解释宇宙的存在。(在宇宙中，你总可以将一个事件解释为由另一个更早的事件所引起，但是宇宙本身的存在只有当宇宙具有一个开端时才能被解释。)另一种观点是圣·奥古斯丁在他的《上帝之城》中提出的。他指出，文明在进步，我们将记住创造业绩和发展技术的人们。因此，人，也许宇宙，不可能已经存在了太长的时间。圣:奥古斯丁根据《创世记》一书，将公元前 5000年作为宇宙诞生的时间。(有趣的是，这和上一次的冰河时期结束的时间，大约公元前1万年相距不远。考古学家告诉我们，文明实际是从那时开始的。)\n\n另一方面，亚里士多德和大多数其他希腊哲学家不喜欢创生的思想，因为它带有太多神的干涉的味道。他们相信，人类及其周围的世界已经并将继续永远存在。古代的人们已经考虑到上述文明进步的论点，并用周期性洪水或其他灾难的重复出现使人类回到文明的起点，来回答上述问题。\n\n1781年,哲学家伊曼努尔·康德发表了里程碑般的(也是非常晦涩的)著作–《纯粹理性批判》。在这本书中，他深人地考察了关于宇宙在时间上是否有开端、空间上是否有限的问题。他称这些问题为纯粹理性的二律背反(也就是矛盾)。因为他感到存在同样令人信服的论据，来证明宇宙有开端的正命题，以及宇宙已经存在无限久的反命题。他对正命题的论证是:如果宇宙没有一个开端，则任何事件之前必有无限的时间。他认为这是荒谬的。他对反命题的论证是:如果宇宙有一开端，在它之前必有无限的时间，为何宇宙必须在某一特定的时刻开始呢?事实上，他对正命题和反命题用了同样的论证。它们都是基于他的未言明的假设，即不管宇宙是否存在了无限久，时间均可无限地倒溯回去。我们会看到，在宇宙开端之前时间概念是没有意义的。这一点是圣·奥古斯丁首先指出的。当他被问及:“上帝在创造宇宙之前在做什么?”奥古斯丁并没有回答说:“他正为问这类问题的人准备地狱。”而是说:“时间是上帝所创造的宇宙的一种产物,在宇宙开端之前不存在。\n\n在多数人都认为宇宙基本上是静态的而且是不变的情况下，探讨宇宙是否有一个起源确实是一个属于玄学或神学范畴的问题。人们可以用两种不同的理论解释他们所观察到的事物。一种理论是宇宙永存;而另外一种理论是宇宙在某一个有限的时间以一种特定的方式被启动，而这种方式又使得宇宙看上去曾经永远存在。但在1929年，埃德温·哈勃做出了一个具有里程碑意义的观测，即不管你往哪个方向看，远处的星系正急速地远离我们而去。换言之，宇宙正在膨胀。这意味着，在早先星体相互之间更加靠近。事实上，在过去的某一时刻，大约100亿至200亿年之前，所有星体都存在于同一地点，而那时候宇宙的密度是无限大。这个发现最终将宇宙起源的问题带进了科学的王国。\n\n哈勃的发现暗示存在一个叫作大爆炸的时刻，当时宇宙的尺度无穷小，而且无限紧密。在这种条件下，所有科学定律，所有预见将来的能力都失效了。如果在此时刻之前有过这些事件，它们也不可能影响现在所发生的一切。好在我们可以不理它们，因为它们并没有可观测的结果。由于更早的时间根本没有定义，所以在这个意义上人们可以说，时间在大爆炸时有一个开端。必须强调的是，这个时间的开端和早先考虑的非常不同。在一个不变的宇宙中，时间的起点必须由宇宙之外的存在物所赋予;宇宙的开端并没有物理的必要性。人们可以想象上帝创造宇宙发生在过去的任何时间。另一方面,如果宇宙在膨胀，宇宙的起源似乎就有了物理的原因。人们仍然可以想象,上帝是在大爆炸的瞬间创造宇宙或者在晚些时候，以使它看起来就像发生过大爆炸似的方式创造，但是设想在大爆炸之前创造宇宙是没有意义的。膨胀的宇宙并没有排斥造物主，但对他何时从事这项工作加上了时间限制!\n\n为了探讨宇宙的本质以及关于宇宙是否有始终等问题，你必须清楚什么是科学理论。我将采用一个简单的观点，即理论只不过是宇宙的模型或它的受限制的部分模型，是一组联结这模型的量和我们所做的观察的规则。它只存在于我们的头脑中，不具有任何的现实性(不管在任何意义上)。一个好的理论应满足两个要求。一是它必须能够用少数几个任意要素的模型来准确地描述人们所观察到的大量现象。二是它还必须能够对人们未来所能观察到的现象的结果加以明确的预测。例如亚里士多德相信恩培多克勒的理论，即任何东西都是由四种元素组成的:土、空气、火和水。这一理论足够简单，但它没有做出任何明确的预测。另一方面，牛顿的引力理论是基于甚至更为简单的模型，即两物体之间的相互吸引力与被称为质量的量成正比，与它们之间的距离的平方成反比。但是它能够以很高的精确性预言太阳、月亮和行星的运动。\n\n任何物理理论都只是假设，从这个意义上来讲，理论总是暂时的，永远不可能被证明。不管多少回实验的结果和某一理论相一致，你永远不可能断定下一次结果不会和它矛盾。另一方面，哪怕你只找到一个和理论预言不一致的观测事实，即可证明它的错误。正如科学哲学家卡尔·波帕所强调的，一个好的理论的特征是，它能给出许多原则上可以被观测所否定或证明有误的预言。如果新的实验中观测的结果与这预言相符，则这理论就幸存，我们对它的信心也随之增加。但是如果有一个新的观测与之不符，我们就只得抛弃或修正这理论。\n\n至少人们认为应该是这样的，但是你总是可以对做出观测的人的能力表示怀疑。\n\n实际上经常发生的是，创建的新理论是原先理论的推广。例如:对水星的非常精确的观测揭示出它的运动和牛顿理论预言之间存在很小差异。爱因斯坦的广义相对论所预言的运动则和牛顿理论的预言略有不同。爱因斯坦的预言和观测相符，而牛顿的预言与观测不相符，这一事实是这个新理论的一个关键证据。然而我们在大部分实际情况下仍用牛顿理论，因为在我们通常处理的情形下，两者差别非常小。(牛顿理论的另一个巨大优势在于，它比爱因斯坦理论容易得多!)\n\n科学的终极目标在于提供一个简单的理论去描述整个宇宙。然而，大部分科学家实际采用的方法是把问题分为两部分。第一，是一些告诉我们宇宙如何随时间变化的定律。(如果我们知道在任意时刻宇宙是什么样子，那么这些定律就能告诉我们在以后的任一时刻宇宙的样子。)第二,关于宇宙初始状态的问题。有些人认为科学只应过问第一部分他们认为初始状态的问题应是玄学或宗教的范畴。他们会说，全能的上帝可以随心所欲地启动宇宙。也许是这样的。但是，倘若那样，他也可以使宇宙以完全任意的方式演化。可是，看起来他却选择让宇宙以一种非常规则的、按照一定规律的方式演化。所以，看起来可以同样合理地假定，也存在着影响初始状态的定律。\n\n事实上，要想创立一个能够描述一切宇宙现象的理论是十分困难的。取代的办法是，我们可以把问题分割开来，进而创建一些局部理论。每个局部理论对特定有限范围的观测进行描述和预言，而忽略其他量的效应，或仅用简单的一组数字来代表它们。可能这种方法是完全错误的。如果宇宙中的每一个事物都非常依赖于其他的任何一个事物，就不可能通过隔离法研究问题的部分去找到完整的答案。尽管如此，这确实是我们在过去取得进展所用的方法。牛顿引力理论又是一个经典的例子，它告诉我们两个物体之间的引力只取决于与每个物体相关的一个数字–它的质量，而与物体由何物组成无关。这样，人们不需要太阳和行星结构及成分的理论就可以计算它们的轨道。\n\n因为除了在最极端的情况下，我们目前所掌握的局部理论已经足够进行精确的预测，因此很难找到现实的理由去探索宇宙的终极理论。(但是值得指出，类似的论点也可以用来攻击相对论和量子力学，而这些理论已给我们带来了核能和微电子学革命!)一套完整的统一理论的发现可能无法帮助我们种族的存活，甚至也不会影响我们的生活方式但是自从文明开始，人们就不甘于将事件看作是互不关联的，不可理解的。他们渴求理解世界的根本秩序。今天我们仍然渴望知道，我们为何在此?我们从何而来?人类求知的最深切的愿望足以为我们不断的探索提供正当的理由。而我们的目标恰恰正是对于我们生存其中的宇宙做出完整的描述。\n\n\n\nUnit 10 Passage A : Spell of the Rising Moon\n\n我家附近有座小山。晚上，我常爬上山去。\n\n此时，城市的喧器成了遥远的低语。在这黑夜的静谧中，我可以尽情分享蟋蟀的欢乐，感受猫头鹰的自信。可我上山是来看月出的，因为这可以让我重新得到在城市中被肆意挥霍掉的宁静与清新。\n\n在这座山上,我已欣赏过许多次月亮升起的景象。每一次月的姿容脾性都有所不同。秋天，满月如轮，充满自信;春天，月亮灰蒙蒙，羞羞;冬天，银白的月亮挂在漆黑的、悄无声息的夜空中，显得那般孤寂;夏天，橘黄的月似被烟尘笼罩，俯瞰干燥的田野。每一种月亮，都像美妙的音乐，激荡着我的心，抚慰着我的灵。\n\n观月自古有之。在远古的猎人眼里,月亮如同心跳一样准确无误。他们知道每 29 天月亮都要变得明亮饱满，然后萎缩、消失，然后再复活;他们知道，月盈期间，每经一次日落，头顶的月亮就会显得更高更大;他们还知道月亏期间，月亮每晚都要迟迟升起，待到日出才落。他们竟能从经验中了解到月亮的行踪变化，真可谓心深意广。\n\n但我们这些人却因深居室内，与月亮失去了联系。城市炫目的街灯、污浊的烟尘掩盖了夜晚的天空。虽然人类已在月亮上行走过，但月亮对于我们却更加陌生了。有几人能说得出今晚月亮会几时升起。\n\n但无论怎样，月亮依旧牵动我们的心灵。倘若我们偶尔遇见一轮黄灿灿的满月高悬中天，谁都会禁不住停下来凝神仰望她尊贵的姿容。而月亮也向注视她的人赐予厚礼。\n\n我了解到她的馈赠是在山间七月的一个夜晚。我的车突然熄火，将我孤身一人困在山中。太阳已经西沉，我看见东边山头涌出一团橘红色的明光，好像森林起火一般，忽而山头自己也似乎进出火焰，一会儿，大大的月亮涨红着脸，从密林中鬼魅似地钻了出来,夏天空气中弥漫的尘雾与汗气把它变得丑陋不堪。\n\n大地灼热的呼吸扭曲了它，它变得格外暴躁，不再完美。附近农舍的狗紧张地狂吠起来，以为这团奇怪的光亮叫醒了野草中的魔鬼。\n\n然而当月亮缓缓升起，离开山头，它变得坚定、威严;它的面孔也由红变成了橘红又变成金色，最后是平静的明黄色。它似乎从渐暗的大地中吸取了光明，因为随着它的升起，下面的丘陵山谷愈来愈黯淡朦胧。待到皓月当空，满月如盘，闪烁着象牙般乳白的清辉，山谷便成了风景中一片片幽深的阴影。那些狗明白了那团光原是它们熟悉的月亮，也安定下来，停止了吼叫。霎时间，我也觉得信心倍增，心情舒畅，近平笑了起来。\n\n这奇特的景观持续了一个小时。月出是缓慢的，充满微妙变化。观看月出，我们得回到从前那种对时间的耐心中去。观看月亮义无反顾地越升越高，就如同找到自己内心异乎寻常的宁静。我们的神思能让我们看到宇宙的广袤和大地的宽阔，能让我们意识到我们自身的存在是多么不可思议。我们觉得自身渺小，却又深受大自然的厚待。\n\n月色下，我们看不到生活中坚硬的棱角。山坡在月光中如同笼上了柔和的轻纱。一片银白;海水在月光下碧蓝而静谧;我们在月光下也不再像白日那般精于算计，而是更加沉醉于情感中。\n\n这种时候往往会发生奇特的事情。在那个七月的夜晚，我看了一两个小时的月景后，回到车中，转动钥匙点火，发动机居然响了起来，就像几个小时前熄火那般突然而神秘。我驱车沿着山路回家，肩上披着明月，心灵一片宁静。\n\n后来我常回到山上观月，尤其是在接踵而来的事使我身心疲惫、头晕眼花时。这种境况经常发生在秋天，这时我就登上那座小山，守候猎人的月亮出现，等着那金色的圆月俯照大地，为黑夜带来光明。\n\n一只猫头鹰自山头俯冲下来，静悄悄地如一团火焰闪过，一只蟋蟀在草丛长鸣我想起了诗人和音乐家，想起了贝多芬的“月光奏鸣曲”和莎士比亚笔下《威尼斯商人》中洛伦佐的话:“月光沉睡在这岸边多么轻柔!我们要坐在这里让音乐之声潜入我们的耳内。”我不知道他们的诗篇与音乐，连同蟋蟀的歌声，是否都可算作月的声音。想到这些我那些城市化的昏乱心绪也融化在了夜的幽静之中，\n\n恋人和诗人在夜里能找到生活更深刻的意义。其实我们都爱问一些更加深刻的问题–我们从哪来?命运又将把我们带到何方?我们沉溺于谜团中，而不是那些统治着白天世界的刻板的条条框框。在夜里，我们都成了哲人和神秘主义者。\n\n月出之时，当我们放慢自己的思想，让它跟随天国的脚步，一种心醉神迷的感觉就会流遍全身。我们会打开情感的窗口，会让白天被理智锁住的那部分思绪尽情奔涌。我们越过遥远的时空，听见远古猎人的低语，再次看到很久以前的恋人与诗人眼中的世界。\n\n\n词汇\n\n\n完型填空\n\nUnit 2 Passage A : World English: A Blessing or a Curse?\n\nA simplified form of the English language based on 850 key words was developed in the late 1920s by the English psychologist Charles Kay Ogden and (1)publicized by the English educator I. A. Richards. Known as Basic English, it was used mainly to teach English to non-English- speaking persons and (2)promoted as an international language. The complexities of English spelling and grammar, however, were major (3)obstacles to the adoption of Basic English as a second language.\n\nThe fundamental principle of Basic English was that any idea, (4)however complex, may be reduced to simple units of thought and expressed clearly by a limited number of everyday words. The 850-word primary vocabulary was (5)composed of 600 nouns (representing things or events), 150 adjectives (for qualities and (6)properties ), and 100 general “operational” words, mainly verbs and prepositions. Almost all the words were in (7)common use in English-speaking countries. More than 60 percent of them were one-syllable words. The basic vocabulary was created (8)in part by eliminating numerous words which have the same or similar meanings and by (9)experiencing the use of 18 “basic” verbs, such as make, get, do, have, and be. These verbs were generally combined with prepositions, such as up, among, under, in, and forward. For example, a Basic English student would use the expression “go up” (10)in case of “ascend”.\n\n参考译文：\n\n20世纪20年代末，英国心理学家查尔斯·凯·奥格登开发了一种基于850个关键字的英语简化形式，并由英国教育家I.A.理查兹推广。它被称为基础英语，主要用于向非英语母语人士教授英语，并被推广为一种国际语言。然而，英语拼写和语法的复杂性是采用基础英语作为第二语言的主要障碍。\n\n基础英语的基本原则是，任何想法，无论多么复杂，都可以简化为简单的思维单位，并通过有限数量的日常单词清晰地表达出来。850个单词的主要词汇由600个名词（表示事物或事件）、150个形容词（表示品质和属性）和100个通用的“操作”词组成，主要是动词和介词。几乎所有的单词在英语国家都很常用。其中60%以上是单音节单词。基本词汇的创建部分是通过消除许多具有相同或相似含义的单词，并体验18个“基本”动词的使用，如make、get、do、have和be。这些动词通常与介词结合，如up、between、under、in和forward。例如，一名基础英语学生会在“上升”的情况下使用“上升”一词。\n\n\n\nUnit 5 Passage A : A Beautiful Mind\n\ndistinguish, as to, unlike, case, necessary, strike, chronic, result in, fortunate, collection\n\nJohn Nash has the same mental illness that affects more than two million Americans: schizophrenia(精神分裂症).He has experienced the same symptoms as others (1)striken with the disease: illusions that messages are being sent to him through television or newspapers. What (2)distinguishes Nash from others is an uncommon amount of public attention. In 1994, Nash shared the Nobel Prize with two other economists.\n\nThe attention has (3)resulted in a long overdue education for the public about the illness and its treatments.”(4)Cases like Nash’s help us know that people may have mental illness but still can contribute to society,” says Roberto Gil.\n\nGil added that Nash’s recovery is not (5)necessarily a normal thing. Schizophrenia usually affects people in their late teens or early twenties.” (6)unlike Nash who didn’t slide into the illness until he was thirty. This gave him time to explore his theories and establish a social network that enabled him to survive later.Many patients who are diagnosed earlier in their lives are not as (7)fortunate.\n\nMuch debate continues (8)as to what exactly schizophrenia is and what causes it.One view suggests that it is an illness with many manifestations while another submits that it is a (9)collection of illnesses often lumped together. According to the National Institute of Mental Health, schizophrenia is”a (10)chronic and disabling brain disease that has no known single cause.\n\n参考译文：\n\nJohn Nash有与200多万美国人相同的精神疾病：精神分裂症。他经历了与其他患有这种疾病的人相同的症状：幻想信息是通过电视或报纸发送给他的。纳什与其他人的不同之处在于，他受到了不同寻常的公众关注。1994年，Nash与另外两位经济学家共同获得了诺贝尔奖。\n\n这种关注导致了公众对这种疾病及其治疗方法早就应该进行的教育。”像Nash这样的案例帮助我们知道，人们可能患有精神疾病，但仍然可以为社会做出贡献，”Roberto Gil说。\n\nJohn补充说，纳什的康复不一定是正常的事情。精神分裂症通常影响十几岁或二十出头的人。”不像Nash直到三十岁才病倒。这让他有时间探索自己的理论，并建立一个社交网络，使他能够在以后生存下来。许多在生命早期被诊断出的患者并没有那么幸运。\n\n关于精神分裂症的确切含义及其病因，仍存在许多争论。一种观点认为，它是一种具有多种表现形式的疾病，而另一种观点则认为，它通常是一系列疾病的集合。根据美国国家心理健康研究所的说法，精神分裂症是“一种慢性致残性脑部疾病，没有已知的单一病因。\n\n\n\nUnit 7 Passage A : Our Picture of the Universe\n\nIt is an interesting reflection on the general climate of thought before the twentieth century that no one had suggested that the universe was expanding or contracting. It was generally accepted that (1)either the universe had existed forever in an unchanging state, or that it had been (2)created at a finite time in the past more or less as we observe it today. In part this may have been (3)due to people’s tendency to believe in eternal truths, (4)as well as the comfort they found in the thought that even though they may grow old and die, the universe is (5)eternal and unchanging.\n\nEven those who realized that Newton’s theory of gravity showed that the universe could not be static did not think to suggest that it might be expanding. (6)Instead, they attempted to modify the theory by making the gravitational force repulsive at very large distances. This did not (7)significantly affect their predictions of the motions of the planets, but it allowed an infinite distribution of stars to remain in equilibrium—with the attractive forces between nearby stars (8)balanced by the repulsive forces from those that were farther away. However, we now believe such an equilibrium would be unstable: If the stars in some region got only slightly nearer each other, the attractive forces between them would become (9)stronger and dominate over the repulsive forces so that the stars would continue to fall toward each other.(10)On the other hand, if the stars got a bit farther away from each other, the repulsive forces would dominate and drive them farther apart.\n\n参考译文：\n\n这是对二十世纪之前总体思想氛围的一个有趣反思，即没有人提出宇宙在膨胀或收缩。人们普遍认为，要么宇宙以不变的状态永远存在，要么它或多或少是在我们今天观察到的有限时间内被创造出来的。在某种程度上，这可能是由于人们倾向于相信永恒的真理，以及他们在这样一种思想中找到的安慰，即即使他们可能会变老和死亡，宇宙也是永恒不变的。\n\n即使是那些意识到牛顿引力理论表明宇宙不可能是静止的人，也不认为它可能在膨胀。相反，他们试图通过使引力在非常大的距离上排斥来修改这一理论。这并没有显著影响他们对行星运动的预测，但它使恒星的无限分布保持平衡——附近恒星之间的吸引力与较远恒星的排斥力相平衡。然而，我们现在认为这样的平衡是不稳定的：如果某个区域的恒星只稍微靠近一点，它们之间的吸引力就会变得更强，并主导排斥力，这样恒星就会继续朝着彼此坠落。另一方面，如果恒星彼此相距更远，排斥力将占据主导地位，并使它们相距更远。\n\n\nUnit 10 Passage A : Spell of the Rising Moon\n\nThe Moon shows progressively different phases as it moves along its orbit around the Earth. Half the Moon is always in sunlight,(1)just as half of the Earth has day while the other half has night. Thus, there is no (2)permanent “dark side of the Moon”, which is sometimes confused with the Moon’s far side—the side that always faces away from the Earth. The phases of the Moon (3)depend on how much of the sunlit half can be seen at any one time. In the (4)phase called the new moon, the near side is completely in (5)shadow. About a week after a new moon, the Moon is in first quarter, (6)resembling a luminous half- circle; another week later, the full moon shows its fully lighted near side; a week afterward, in its last quarter, the Moon appears as a half-circle again. The entire cycle is repeated each (7)lunar month. The Moon is full when it is farther away from the Sun than the Earth; it is new when it is (8)closer. When it is more than half (9)illuminated, it is said to be in gibbous phase. The Moon is said to be (10)waning as it progresses from full to new, and to be waxing as it proceeds from new to full.\n\n参考译文：\n\n月球在绕地球运行的轨道上显示出逐渐不同的相位。月球的一半总是在阳光下，就像地球的一半有白天，另一半有黑夜一样。因此，没有永久的“月球黑暗面”，有时会将其与月球的远侧混淆，即始终背对地球的一侧。月球的相位取决于在任何时候可以看到多少被阳光照射的一半。在新月阶段，近侧完全处于阴影中。新月后大约一周，月亮在第一季度，像一个发光的半圆；又过了一周，满月显示出它完全照亮的近侧；一周后，在最后一个季度，月球再次出现半圆。整个周期在每个阴历月重复。当月亮离太阳比离地球更远时，它就是满月；当它靠近时，它是新的。当它被照亮一半以上时，据说它处于凸相。据说月亮在从满月到新月的过程中逐渐变弱，而在从新月到满月的过程中则逐渐变圆。\n\n\n\n翻译\n\nUnit 2 Passage A World English: A Blessing or a Curse\n\n\n\nFor English is a killer. It is English that has killed off Cumbric, Cornish, Norn and Manx. There are still parts of these islands where sizeable communities speak languages that were there before English. Yet English is everwhere in everyday use and understood by all or virtually all, constituting such a threat to the three remaining Celtic languages, Irish, Scottish Gaelic, and Welsh… that their long-term future must be consdered… very greatly at risk.\n\n译文1\n\n因为英语是个杀手。正是英语，导致坎伯兰语、康沃尔语、诺恩语和马恩语灭亡。在那些岛屿的部分地区，还有较大规模的群体讲比英语更古老的当地语言。但是，现在日常生活中，英语无处不在，人人–或者说–几乎人人都懂英语。英语威胁到那三种遗留的凯尔特语:爱尔兰语、苏格兰盖尔语和威尔士语，……所以必须意识到，从长远来看，这三种语言的未来……十分危险。\n\n\n\n译文2\n\nHe alos associated such policies with a prejudice which he calls linguicism ( a condition parallel to racism and sexism ). As Phillipson sees it, leading institutions and indiividuals within the predominantly “white” English-speaking world, have ( by design or default ) encouraged or at least tolerated – and certainly have not opposes – the hegemonic spread of English, a pread which began some three centuries ago as economic and colonial expansion.\n\n他还把这种政策和他所称的“语言歧视” 这个情况类似于“种族歧视”“性别歧视”联系在一起。在菲利普森看来，在以“白人”为主的英语世界中，起主导作用的机构和个人，或故意或无意，鼓励或者至少容忍英语大肆扩张，他们当然不反对英语的扩张。英语的扩张开始于大约三个世纪以前，最初的表现形式是经济与民扩张。\n\n\n\nBy and large, we now view them as more or less benign, and often talk with admiration and appreciation about the cultures associated wuth them and what they have given to the world. And it is fairly safe to do this, because none of them now poses much of a threat.\n\n译文3\n\n总的来说，我们现在认为这些语言比较好，经常以赞美、感激的语气谈论与它们相关的文化以及它们给世界带来的变化。我们这样的态度，没有什么不妥，因为那些语言现在都不构成严重威胁。\n\n\n\nEnglish however is probably too close for us to be able to analyze and judge it as dispassionately as we may now discuss the influence of Classical Chinese on East Asia or of Classical Latin on Western Europe. The jury is still out in te trial of the English language, and may take several centuries to produce its verdict, but evern so we can ask,in this European Year of Languages, whether Price and Phillipson are right to warn us all about the lanuage then I am using at this very moment.\n\n译文4\n\n我们现在可以冷静地讨论古汉语对东亚或古拉丁语对西欧的影响。但是，我们与英语关系太紧密，无法同样冷静地分析、评价英语。在对英语的审判中，陪审团还没有露面可能需要好几个世纪才能做出裁决。但即使如此，值此欧洲语言年，我们可以提出这个问题: 普莱斯和菲利普森就我此时使用的语言对我们提出的警告是否有道理。\n\n\n\nEnglish-speaking South Africans of British descent were not particularly strong in opposing the apartheid regime, and the black opposition, whose members had many languages ,was at first weak and disorganized.\n\n译文5\n\n说英语的、英国裔的南非人不是非常积极地反对种族隔离制度。在黑人的反对力量中成员使用多种语言，他们起初缺少力量与组织。\n\n\n\n译文6\n\nSuch symbolism suggests that the users of the world’s ligua franca should seek to benefit as fully as possible from the blessing and as far as possible avoid invoking the curse.\n\n这种象征意义说明，使用世界通用语言的人应该努力尽可能用其利而避其弊。\n\n\n\nUnit 5 Passage A : A Beautiful Mind（美丽心灵）\n\nJohn Forbes Nash, Jr. ——mathematical genius invemor of a theory of ratiohnal behavior, visionary of the thinking machine——had been sitting with his visitor, also a mathematician, for nearly an hour.\n\n译文1\n小约翰·福布斯·纳什–数学天才、理性行为理论的创立者、预见会思考的机器出现的预言者–已经和来访者，也是一位数学家，共坐了将近半个小时。\n\n\n\nHe had been staring dully at a spot immediately in front of the left foot of Harvard professor George Mackey, hardly moving except to brush his long dark hair away from his forehead in a fitful, repetitive.\n\n译文2\n\n他一直目光呆滞地盯着哈佛教授乔治·麦基左脚前方不远的地方，除了一次次重复着将垂在前额的略长的黑发拨开的动作，他几乎一动不动。\n\n\n\nOver the next decade, a decade as notable for its supremefaith in human rationality as for its dark anxieties about mankind’s survival, Nash proved himself, in the words of the eminent geometer Mikhail Gromov, “the most remarkable mathematician of the second half of the century\n\n译文3\n\n在接下来的十年，在那既以对人类理性抱有无上信念而著称，又以对人类生存怀有无尽忧虑而闻名的十年,纳什,用知名几何学家米克哈尔·格罗莫夫的话说,证明了自己是“20世纪后半叶最杰出的数学家”\n\n\n\n“Geniuses”, the mathematician PPaul Halmos wrote, “are of two kinds: the ones who are justlike all of us, but very much more os, and the ones ohw, apparentl, have an extra human spark. We can all run,m and some of us can run the mile in less than 4 minutes; but there is nothing that most of us can do that compares with the creation of the Great G-minor Fugue.” Nash’s genius was of that mysterious variety more often associated with music and ar than with the oldest of all sciences\n\n译文4\n\n数学家保罗·哈莫斯写道:“天才分为两种:一种就像我们大家一样，只是更为出色;另一种则是那些明显具备超凡人类灵感的人。我们都能跑步，有些人还能在四分钟内跑完一英里;但是我们大多数人所做的一切无论如何也无法与创作出G小调赋格曲相提并论。”纳什的天分就属于那种常与音乐和艺术而非与最古老的科学紧密相连的神奇异禀\n\n\n\nCompulsively rational, he wished to turn life’s decisions——whether to take the first elevator or wait for the next one, there to abnk his money, what job to accept, thether to marry——into calculations of advantage and disadvantage, algorithms or mathematial rules divorced for emotion, convention, and tradition.\n\n译文5\n\n他具有一种强迫性的理性，希望将生活中的决定–是搭乘第一班电梯还是等待下一班，到哪里存钱，接受什么样的工作，是否结婚–都转化为利弊得失的计算，转化为完全脱离感情、习俗和传统的算法法则或数学规则。\n\n\n\nHis remoteness was punctuated by flights of garrulousness about outer space and geopolitical trends, childish pranks, and unpredictable eruptions of anger. But these outbursts were, more often than not, as enigmatic as his silences.” He is not one of us” was a constant refrain.\n\n译文6\n\n他一贯冷漠，但一时兴起也会喋喋不休地谈论外太空和地缘政治趋势，或做出孩子般的恶作剧,或者毫无征兆地勃然大怒。但是这些情感的进发总是和他的沉默一样神秘莫测。“他和我们不一样”是人们常说的一句话。\n\n\n\nNash’s insight into the dynamics of human rivalry——his theory of rational conflict and cooperation——was to bacome one of the most influential ideas of the twentieth century, transforming the young science of economics the way that Mendel’s ideas of genetic transmission, Darwin’s model of natural selection, and Newton’s calestial mechanics reshaped biology and physics in their day.\n\n译文7\n\n纳什对于人类竞争动态变化的洞察–他的理性竞争与合作理论–将会成为20世纪最具影响的思想理论之一。这一理论改变着新兴的经济学，其作用无异于孟德尔的基因遗传、达尔文的自然选择模式和牛顿的天体力学再造了当时的生物学和物理学。\n\n\n\nUnit 7 Passage A : Our picture of the Universe\n\n\n\nA well-know scientist ( some say it was Bertrand Russell ) once gave a public lecture on astronomy. He described how the earth orbits around the sun and how the sun, in turn, orbits around the center of a vast collection of stars called our galaxy.\n\n译文1\n\n一位著名的科学家(有人说是伯特兰·罗素)曾经做过一次关于天文学的演讲。他描述了地球如何围绕太阳运转，以及太阳如何进而围绕大量星群的中心运转，这些星群即所谓的银河系。\n\n\n\nAccording to a number of early cosmologies and the Jewish/Christian/Muslim tradition, the universe started at a finite, and not very distant, time in the past.\n\n译文2\n\n依据一些早期的宇宙论的观点和犹太/基督,穆斯林教派传统的观点，字宙起源于一个特定的并且不太遥远的过去时间。\n\n\n\nwhen most people believed in an essentially static and unchanging universe, the question of whether or not it had a beginning was really one of metaphysics or theology. One could account for what was observed equally well on the theory that the univers had existed forever or on the theory that it was set in motion at some finite time in such a manner as to look as though it had existed forever.\n\n译文3\n\n在多数人都认为宇宙基本上是静态的而且是不变的情况下，探讨宇宙是否有一个起源确实是一个属于玄学或神学范畴的问题。人们可以用两种不同的理论解释他们所观察到的事物。一种理论是宇宙永存;而另外一种理论是宇宙在某一个有限的时间以一种特定的方式被启动，而这种方式又使得宇宙看上去曾经永远存在。\n\n\n\nIn order to talk about the nature of the universe and to discuss questions such as whether it has a beginning or an end.\n\n译文4\n\n为了探讨宇宙的本质以及宇宙是否有始有终等问题，你必须清楚什么是科学理论。\n\n\nA theory is a good theory if it satisfies two requirements. it must accurately deescribe a large class of observations on the basis of a model that contains only a few arbitrary elements, ans it must make definite predictions about the results of future observations.\n\n译文5\n\n一个好的理论应满足两个要求。一是它必须能够基于一个只包含少数几个任意要素的模型来准确地描述人们所观察到的大量现象。二是它还必须能够明确地预测人们未来所能观察到的现象的结果。\n\n\n\nIt turns out to be very difficult to devise a theory to describe the universe all in one go. Instead, we break the problem up into bits and invent a number of partial theories.\n\n译文6\n\n事实上，要想设计出一个能够描述一切宇宙现象的理论是十分困难的。取代的办法是，我们可以把问题分割开来，进而创建一些局部理论。\n\n\n\nUnit 10 Passage A : Spell of the Rising Moon（赏月）\n共7个\n\n\n\nStill,  it tugs at our minds. If we unexpectedly encounter the full moon, huge and yellow over the horizon, we are helpless but to stare back at its commanding presence.And the moon has gifts to bestow upon those who watch.\n\n译文1：\n\n但无论怎样，月亮依旧牵动我们的心灵。倘若我们偶尔遇见一轮黄灿灿的满月高悬中天，谁都会禁不住停下来凝神仰望她尊贵的姿容。而月亮也向注视她的人赐予厚礼。\n\n\n\nBut as the moon lifted off the ridge it gathered firmness and authority.Its complexion changed from red,to orange, to glod,to impassive yellow.It seemed to draw light out of the darkening earth, for asit rose,the hills andvalleys below grew dimmer.By the time the moonstood clear of the horizon, full chested and round and the color of ivory, the valleys were deep shadows in the landscape.\n\n译文2：\n\n然而当月亮缓缓升起，离开山头，它变得坚定、威严;它的面孔也由红变成了橘红又变成金色，最后是平静的明黄色。它似乎从渐暗的大地中吸取了光明，因为随着它的升起，下面的丘陵山谷愈来愈黯淡朦。待到皓月当空，满月如盘，闪烁着象牙般乳白的清辉，山谷便成了风景中一片片幽深的阴影。\n\n\n\nMoonrise is slow and serried with subtleties.To watch it, we must slip into an older,more patient sense of time.To watch the moon move inexorably higher is to find an unusual stillness within outselves.Our imaginations become aware of the vast distances of space,the immensity of the earth and the huge improbability of our own existence.We feel small but privileged.\n\n译文3：\n\n月出是缓慢的，充满微妙变化。观看月出，我们得回到从前那种对时间的耐心中去。观看月亮义无反顾地越升越高，就如同找到自己内心异乎寻常的宁静。我们的神思能让我们看到宇宙的广袤和大地的宽，能让我们意识到我们自身的存在是多么不可思议。我们觉得自身渺小，却又深受大自然的厚待。\n\n\n\nMoonlight shows us none of life’s harder edges. Hillsides seem silken and silvery,the oceans still and blue in its light. In moonlight we become less calculating, more drawn to our feelings.\n\n译文4：\n\n月色下，我们看不到生活中坚硬的棱角。山坡在月光中如同笼上了柔和的轻纱一片银白;海水在月光下碧蓝而静谧;我们在月光下也不再像白日那般精于算计，而是更加沉醉于情感中。\n\n\n\nI return often to the rising moon.I am draw especially when events crowd ease and clarity of vision into a small corner of my life.\n\n译文5：\n\n我经常回到月出的时刻。特别是当生活中的琐事将我的轻松和清晰的视野挤到一个小小的角落时，我更是被月出所吸引。\n\n\n\nLovers and poets find deeper meaning at night.We are all apt to pose deeper questions-about our originis and destinies.We indulge in riddles,rather than in the impersonal geometries that govern the daylit world.We become philosophers and mystics.\n\n译文6：\n\n恋人和诗人在夜里能找到生活更深刻的意义。其实我们都爱问一些更加深刻的问题–我们从哪来?命运又将把我们带到何方?我们沉于谜团中，而不是那些统治着白天世界的刻板的条条框框。在夜里，我们都成了哲人和神秘主义者。\n\n\n\nAt moonrise, as we slow our minds to the pace of the heavens, enchanlment steals over us.We open the vents of feeling and exercise parts of our minds that reason locks away by day.We hear,across the distances,murmurs of ancient hunters and see anew the visions of poets and lovers of long ago.\n\n译文7：\n\n月出之时，当我们放慢自己的思想，让它跟随天国的脚步，一种心醉神迷的感觉就会流遍全身。我们会打开情感的窗口，会让白天被理智锁住的那部分思绪尽情奔涌。我们越过遥远的时空，听见远古猎人的低语，再次看到很久以前的恋人与诗人眼中的世界。\n\n\n\n写作\n"
} ,
  
  {
    "title"    : "智能感知",
    "category" : "",
    "tags"     : " python, 期末考试",
    "url"      : "/intellisense",
    "date"     : "November 4, 2023",
    "excerpt"  : "  《智能感知》是一门专注于研究如何通过计算机技术和人工智能理论来感知和理解现实世界的课程。它涵盖了多个领域的知识，包括机器学习、深度学习、计算机视觉、自然语言处理等，旨在培养学生具备利用人工智能技术进行数据分析和解决实际问题的能力。\n\n\n  温馨提示：如果你觉得界面配色有些刺眼，你可以点击右上角的菜单，选择使用圆形按钮切换主题背景。\n\n\n\n\n\n\n前言\n  本博客针对，智能感知期末考试进行整理。材料内容由 TraSorrow同学亲情提供，本人只做整理排版工作。内容较多，祝你顺利通过考试，取...",
  "content"  : "  《智能感知》是一门专注于研究如何通过计算机技术和人工智能理论来感知和理解现实世界的课程。它涵盖了多个领域的知识，包括机器学习、深度学习、计算机视觉、自然语言处理等，旨在培养学生具备利用人工智能技术进行数据分析和解决实际问题的能力。\n\n\n  温馨提示：如果你觉得界面配色有些刺眼，你可以点击右上角的菜单，选择使用圆形按钮切换主题背景。\n\n\n\n\n\n\n前言\n  本博客针对，智能感知期末考试进行整理。材料内容由 TraSorrow同学亲情提供，本人只做整理排版工作。内容较多，祝你顺利通过考试，取得一个好成绩！。\n\n\n\n题目部分\n\n题目题型包含选择、判断、以及问答大题、编程题、以及设计题，本博客内容包含两套试卷的量，因此内容较多。\n\n\n  提示：选择判断的试题顺序与考试相同，来不及备考的同学可以直接背答案\n\n\n\n选择题\n\n1. 讯飞开放平台文字识别服务在处理大量文本时,可能遇到的主要问题是什么?(B)\n\nA. 识别准确率低\nB. 识别速度慢\nC. 无法处理特殊字符\nD. 所有选项都正确\n\n\n2. 以下哪个应用场景不属于图像识别技术的应用?(C)\n\nA. 自动驾驶\nB. 医学影像诊断\nC. 语音识别\nD. 人脸识别支付\n\n\n3. 讯飞开放平台的语音合成服务主要支持哪些语言?(B)\n\nA. 中文和英文\nB. 中文、英文和其他多种语言\nC. 仅支持中文\nD. 仅支持英文\n\n\n4. 在命名实体识别中,以下哪种方法不属于基于深度学习的方法?(D)\n\nA. 卷积神经网络(CNN)\nB. 循环神经网络(RNN)\nC. 长短时记忆网络(LSTM)\nD. 支持向量机(SVM)\n\n\n5. Flask中的路由装饰器是哪个?(B)\n\nA. @route()\nB. @app.route()\nC. @url_for()\nD. @request()\n\n\n6. 语音识别的输入实际上就是一段随时间播放的信号序列,而输出则是一段(A)\n\nA. 文本序列\nB. 语音序列\nC. 音频特征\nD. mel频谱\n\n\n7. 语音转写技术的准确性如何提高?(D)\n\nA. 增加训练数据量\nB. 优化算法模型\nC. 提高麦克风质量\nD. 所有以上方法\n\n\n8. 语音识别目前存在的主要问题不包括(B)\n\nA. 自由交谈风格\nB. 细微问题的发现\nC. 语言混合识别\nD. 多人说话重叠\n\n\n9. 提高语音识别健壮性的方法不包括(C)。\n\nA. 增加训练集样本\nB. 多样化录音设备\nC. 减小模型参数量\nD. 添加语音增强前处理\n\n\n10. 讯飞开放平台的语音合成服务可以用于哪些应用场景?(D)\n\nA. 智能客服机器人\nB. 语音助手\nC. 有声读物制作\nD. 所有以上选项答案\n\n\n11. 讯飞开放平台文字识别服务提供的API接口类型主要有哪些?(A)\n\nA. HTTP和HTTPS\nB. TCP和UDP\nC. MQTT和CoAP\nD. 所有选项都正确\n\n\n12. 图像识别技术中,卷积神经网络(CNN)的主要作用是什么?(C)\n\nA. 生成图像\nB. 分类图像\nC. 提取图像特征\nD. 压缩图像\n\n\n13. 讯飞开放平台语音合成服务在处理大量文本时,可能遇到的主要问题是什么?(A)\n\nA. 合成速度慢\nB. 合成质量低\nC. 无法处理特殊字符\nD. 所有选项都正确\n\n\n14. 命名实体识别(NER)的主要任务是什么?(C)\n\nA. 从文本中提取关键词\nB. 从文本中提取短语\nC. 从文本中识别并分类预定义的实体,如人名、地名、组织名等\nD. 从文本中提取情感倾向\n\n\n15. Flask中的路由装饰器是哪个?(B)\n\nA. @route()\nB. @app.route()\nC. @url_for()\nD. @request()\n\n\n16. 语音识别系统主要包含(D)以及解码搜索这些主要流程\n\nA. 特征提取\nB. 声学模型\nC. 语言模型\nD. 以上都是\n\n\n17. 在语音转写中,以下哪个参数对于识别准确性的影响较大?(D)\n\nA. 采样率\nB. 帧长\nC. 麦克风数量\nD. 语音质量\n\n\n18. 语音识别,又称自动语音识别技术,简称是(B)\n\nA. TTS\nB. ASR\nC. RAS\nD. SST\n\n\n19. 在语音识别任务中,过拟合的解决方法不包括（C）。\n\nA. 增加训练样本量\nB. 提前停止训练\nC. 增加网络层数\nD. L2正则化\n\n\n20. 海量歌曲数据中,找到音乐特征相似的歌曲,可以采用技术。(B)\n\nA. 分布式计算\nB. 推荐系统\nC. 数据挖掘\nD. 语音识别\n\n\n\n判断题\n\n\n  提示都是对错对对错\n\n\n\n  （✔）智能感知技术主要依赖于人工智能算法来实现对环境的感知和理解。\n  （✖）在智能感知技术中，计算机视觉和语音识别是两个独立的技术领域，它们之间没有交集。\n  （✔）在Flask中，可以使用AJAX技术实现前后端数据交互。\n  （✔）在Flask中，可以使用render_template()函数渲染HTML模板。\n  （✖）在Flask中，可以使用request对象实现用户会话管理。错\n  （✔）深度学习技术在智能感知技术中的应用主要体现在图像识别、语音识别和自然语言处理等领域。\n  （✖）感知技术在安防领域的应用仅限于人脸识别，无法实现行为分析等功能.错\n  （✔）Flask中的Jinja2模板引擎用于生成动态HTML页面。\n  （✔）在Flask中，可以使用redirect()函数实现页面重定向。\n  （✖）在Flask中，可以使用session对象获取HTTP请求的信息。\n\n\n\n\n问答题\n\n1.语音识别性别/年龄的原因有哪些 至少五个\n\n1. 声调\n2. 口音和方言\n3. 语音特征\n4. 背景噪音\n5. 基频\n\n\n\n\n2.人脸比对的功能,讯飞开放平台中的人脸对比对人脸的要求\n\n功能:人脸比对可以对比两张照片中的人脸信息，判断是否是同一个人\n要求:需要清晰的人脸照片，人脸大小不小于30*30像素，其中人脸俯仰角、左右偏航角、人脸翻转角60°以内识别效果更好。\n\n\n\n\n3.情感分析的功能,应用场景\n\n功能:情感分析即文本倾向性分析，就是计算机判断人们的看法或评论是属于对事物的积极、消极或中性意见。\n\n应用场景:\n\n1.\t电商平台\n2.\t社交平台\n3.\t客服平台\n4.\tChatbot\n\n\n\n\n4.语音合成和语音识别的概念和区别\n语音合成是通过将文本合成为声音音频的过程\n语言识别是将语音中的词汇转化为计算机的可读输入\n他们的区别是:\n语音合成是文本到声音的过程\n语音识别是将人的语音转化为计算机可读的文本信息\n\n\n\n\n编程题\n\n1.程序填空\n\n\n  注意这里只显示需要填写答案的部分，并不是完整的代码，请注意区分！\n\n\n    #判断图片是否存在\n    if not os.path.exists(image_path):\n    #读取图片数据\n    data = f.read()\n    #将api_key作为请求params中的参数,发送post请求\n    response=requests.post(url,headers=headers,data=data,params={‘api_key’:api_key})\n    #如果返回的状态码为200,请求成功\n    if response.status_code == 200:\n        #如果请求成功,解析返回的JSON数据\n        result = json.loads(response.text)\n\n\n2.程序填空:\n\n    from flask import Flask,url_for,redirect\n    app = Flask(__name__)\n    @app.route(‘/’)\n    def index():\n        return ‘Hello World’\t//\tA:Hello World\t\tB:success\n    #省略部分代码\n    @app.route(‘/login’)\t//\tA:’/login’\t\tB:’/register’\n    def login():\n        #模拟登录流程\n        flag = ‘success’\n        #如果登录成功,跳转到首页\n        if flag:\n            return redirect(url_for(‘index’))\n        return ‘登录页面’\n    if __name__ == ‘__main__’:\n        app.run(debug=True)\n\n\n\n\n设计题\n\n基于智能语音合成技术的虚拟导游系统\n\n(1)评估语音合成系统质量的指标\n\n自然度：评估合成语音的听起来自然程度，是否接近人类语音。\n清晰度：评估合成语音的发音是否清晰，是否易于理解。\n准确性：评估合成语音的发音是否准确，是否能够准确地传达信息。\n情感表达：评估合成语音是否能够表达出特定的情感，如愉快、悲伤、愤怒等。\n语种和语言能力：评估语音合成系统是否能够支持不同的语种和语言，以及其处理能力如何。\n时延：评估语音合成系统的响应速度，即从输入到输出的时间。\n稳定性：评估语音合成系统在各种情况下的运行稳定性，如在不同网络环境、不同设备、不同操作系统下的表现。\n\n\n(2)主要功能至少两个\n\n语音导览：根据旅游者的位置和需求，提供景点讲解、历史背景介绍等服务。\n路线规划：根据旅游者的需求和时间安排，为其规划合理的旅游路线，包括交通方式、景点顺序、餐饮等。\n信息咨询：为旅游者提供关于旅游信息、天气、文化等方面的咨询服务。\n语音交互：通过语音识别和语音合成技术，实现与旅游者的语音交互，解答其问题、提供建议等。\n个性化服务：通过分析旅游者的偏好和历史行为，为其提供个性化的导览服务、推荐景点等。\n\n\n(3)分别描述实现该功能的技术实现方法至少三个\n\n1.语音识别技术：通过语音识别技术，将旅游者的语音指令转化为文字，便于后续处理和分析。常见的语音识别技术包括基于深度学习和基于规则的方法等。\n2.自然语言处理技术：通过自然语言处理技术，对文字指令进行分析和理解，提取出关键信息，如景点名称、位置、历史背景等。常见的自然语言处理技术包括分词、词性标注、句法分析等。\n3.语音合成技术：通过语音合成技术，将文字指令转化为自然、清晰的语音，便于旅游者理解和接受。常见的语音合成技术包括基于规则的方法和基于深度学习的方法等。\n\n\n(4)描述系统可能会出现的问题及解决方案\t至少三个\n\n1.语音识别不准确：由于环境噪音、口音差异等因素影响，可能导致语音识别不准确。解决方案可以采用多模态识别技术，结合视觉、文本等信息提高识别准确性。\n2.自然语言处理错误：由于语义歧义、背景知识不足等因素影响，可能导致自然语言处理错误。解决方案可以采用上下文理解、多轮对话等方式提高语义理解准确性。\n3.语音合成不自然：由于语音合成的技术限制或参数设置不当等因素影响，可能导致语音合成不自然。解决方案可以采用更自然的语音合成技术或针对特定场景调整参数设置等方式提高语音合成质量。\n4.数据安全问题：由于数据传输、存储等方面存在安全漏洞，可能导致数据泄露或被篡改。解决方案可以采用加密传输、访问控制、备份数据等方式保障数据安全。\n5.系统稳定性不足：由于硬件设备故障、网络中断等因素影响，可能导致系统稳定性不足。解决方案可以采用高可用性设计、容错机制等方式提高系统稳定性。\n\n\n\n\n基于智能语音技术的智能家居控制系统\n\n  (1)(3)(4)同上\n\n(2) 主要功能(至少两个):\n\n1.语音控制：用户可以通过语音指令控制智能家居设备，如灯光、窗帘、空调、电视等。这种控制方式无需使用手机或遥控器，方便快捷。\n2.智能家居设备的控制：系统可以连接并控制多种智能家居设备，包括但不限于灯光、窗帘、空调、电视等。用户可以通过语音指令或手机应用程序对这些设备进行统一控制。\n3,定时控制：用户可以为智能家居设备设置定时任务，例如早晨自动开启窗帘和灯光，晚上自动关闭。\n4.远程控制：用户可以通过手机应用程序远程控制智能家居设备，无论身在何处，都能随时随地掌控家中各项设备的状态。\n\n\n\n\n回到顶部\n"
} ,
  
  {
    "title"    : "大数据可视化",
    "category" : "",
    "tags"     : " python, 大数据",
    "url"      : "/largedatavisualization",
    "date"     : "November 3, 2023",
    "excerpt"  : "  大数据可视化是指将庞大的数据集通过图表、地图、仪表盘等可视化工具呈现出来，使人们能够直观地理解和分析数据。它是数据分析和决策过程中的重要工具，有助于揭示数据背后的模式、趋势和关联关系，帮助用户更好地理解数据，并根据数据进行决策。\n\n\n  温馨提示：如果你觉得界面配色有些刺眼，你可以点击右上角的菜单，选择使用圆形按钮切换主题背景。\n\n\n\n\n\n目录\n\n\n  目录\n  前言\n  题目部分\n    \n      选择题\n        \n          1. 哪些图形适合显示多维数据:\n ...",
  "content"  : "  大数据可视化是指将庞大的数据集通过图表、地图、仪表盘等可视化工具呈现出来，使人们能够直观地理解和分析数据。它是数据分析和决策过程中的重要工具，有助于揭示数据背后的模式、趋势和关联关系，帮助用户更好地理解数据，并根据数据进行决策。\n\n\n  温馨提示：如果你觉得界面配色有些刺眼，你可以点击右上角的菜单，选择使用圆形按钮切换主题背景。\n\n\n\n\n\n目录\n\n\n  目录\n  前言\n  题目部分\n    \n      选择题\n        \n          1. 哪些图形适合显示多维数据:\n          2. 哪些图形适合显示时间序列数据:\n          3. 哪些图形适合显示分类数据:\n          4. 哪些图形适合显示离散数据:\n          5. 哪些图形适合显示二元数据:\n        \n      \n      填空题:\n        \n          1. 条形图通常显示哪些数据:\n          2. 散点图用于显示什么类型的数据:\n          3. 直方图用于显示什么类型的数据:\n          4. 饼图用于显示什么类型的数据:\n          5. 折线图用于显示什么类型的数据:\n        \n      \n      问答题\n        \n          1.简述数据可视化流程\n          2.简述数据可视化常用的工具\n          3.简述数据可视化可以用于哪些行业(至少五个)\n          4.简述可视化的意义(至少三条)\n          5.pandas中可以读取多种文件格式,常用的文件格式有哪几种\n          6.据清洗有哪些方法\n          7.异常值检测有哪些方法(两种基本方法):\n          8.可视化哪些图像适合对比,为什么适合\n          9. 编程题:\n            \n              9.1 阅读以上代码回答问题:\n              9.1.1 encoding\t是哪一个类型的参数:\n              9.1.2 如果要把data3和data4按照B列合并,请写出合并代码:\n              9.2 根据图表来回答问题:\n              9.2.1 请根据表的数据分析可以从哪几个角度可视化,并写出理由:\n              9.2.2 根据上题中选取一种可视化的需求,写出完整代码\n            \n          \n        \n      \n    \n  \n\n\n\n前言\n  本博客针对，大数据可视化期末考试进行整理。材料内容由 TraSorrow同学亲情提供，本人只做整理排版工作。内容不多，祝你取得一个好成绩！。\n\n\n\n题目部分\n\n  题型主要有，选择题、填空题、问答大题（包含编程题）组成。   内容如下仅供参考。\n\n\n\n选择题\n\n1. 哪些图形适合显示多维数据:\n\n直方图\n\n\n2. 哪些图形适合显示时间序列数据:\n\n折线图\n\n\n3. 哪些图形适合显示分类数据:\n\n条形图\n\n\n4. 哪些图形适合显示离散数据:\n\n散点图\n\n\n5. 哪些图形适合显示二元数据:\n\n散点图\n\n\n\n\n填空题:\n\n1. 条形图通常显示哪些数据:\n\n分类数据\n\n\n2. 散点图用于显示什么类型的数据:\n\n离散数据\n\n\n3. 直方图用于显示什么类型的数据:\n\n连续数据\n\n\n4. 饼图用于显示什么类型的数据:\n\n离散数据\n\n\n5. 折线图用于显示什么类型的数据:\n\n连续数据\n\n\n\n\n问答题\n\n1.简述数据可视化流程\n\n1. 采集数据\n2. 数据处理和变换\n3. 可视化映射\n4. 人机交互以及用户感知\n\n\n2.简述数据可视化常用的工具\n\n1. Tableau\n2. dataV\n3. ECharts\n4. FineBl\n5. Python numpy Matplotlib库\n6. Excel\n\n\n3.简述数据可视化可以用于哪些行业(至少五个)\n\n1. 金融行业\n2. 教育行业\n3. 天气预报\n4. 医疗行业\n5. 物流行业\n\n\n4.简述可视化的意义(至少三条)\n\n1. 通过图形化手段清晰有效地传达与沟通信息\n2. 帮助人更好的分析数据\n3. 帮助企业从信息中提取知识、从知识中收获价值\n\n\n5.pandas中可以读取多种文件格式,常用的文件格式有哪几种\n\n1. CSV文件\n2. Excel文件\n3. JSON文件\n4. 压缩文件(.zip等)\n5. 文本文件(.tsv,.txt等)\n\n\n6.据清洗有哪些方法\n\n1. 去除空值\n2. 缺失值填充\n3. 重复值处理\n4. 数据标准化\n\n\n7.异常值检测有哪些方法(两种基本方法):\n\n1. 箱线图法\n2. Z-Score法\n3. IQR法\n4. 散点图法\n5. 直方图\n6. 线图\n\n\n8.可视化哪些图像适合对比,为什么适合\n1.  柱状图 原因: 可以通过柱子的高度可以直观地展示数值之间的差异\n2.  饼图 原因: 可以通过扇形面积和角度来比较不同类别的数据\n3.  条形图 原因: 可以通过不同长度的条形可以清晰地比较各个类别的数值大小\n4.  线状图 原因: 通过线条的起伏变化可以反映出一个序列中的趋势和规律\n5.  散点图：原因散点图通过点的分布情况，可以直观地展示两个变量之间的关联程度。\n\n\n\n\n9. 编程题:\n\n\n    Import pandas as pd\n    \n    data1 = pd.read_csv(“F:\\\\tmp\\\\数据1.csv”,encoding=’gb18030’)\n    \n    data2 = pd.read_csv(“F:\\\\tmp\\\\数据2.csv”,encoding=’gb18030’)\n    data3 = pd.DataFrame({‘A’:[‘a1’,’a2’,’a3’],’B’:[‘b1’,’b2’,’b3’],’C’:[‘c1’,’c2’,’c3’]})\n    data4 = pd.DataFrame({’B’:[‘b2’,’b3’,’b4’],’D’:[‘d2’,’d3’,’d4’]})\n\n\n\n9.1 阅读以上代码回答问题:\n\n9.1.1 encoding\t是哪一个类型的参数:\n\n关键字参数\n\n\n9.1.2 如果要把data3和data4按照B列合并,请写出合并代码:\n\nmerged_data = pd.merge(data3, data4, on=&#39;B&#39;, how=&#39;outer&#39;)\n\n\n\n\n\n    \n    \n        \n    \n    \n\n\n9.2 根据图表来回答问题:\n\n9.2.1 请根据表的数据分析可以从哪几个角度可视化,并写出理由:\n\n可以选择两个角度考虑年度和指标\n在国民总收入,比较随着年度的变化,收入总量的变化趋势\n还可以根据某一年不同指标之间的比较来获取数据信息\n\n\n9.2.2 根据上题中选取一种可视化的需求,写出完整代码\n\n\n  注意本题代码老师并未透露。且题目也可能变化，为了避免误导此处不展示代码示例。\n\n\n回到顶部\n"
} ,
  
  {
    "title"    : "神经网络",
    "category" : "",
    "tags"     : " python, 人工智能, 期末考试",
    "url"      : "/artificialNetwork",
    "date"     : "June 21, 2023",
    "excerpt"  : "  人工神经网络（Artificial Neural Networks，简写为ANNs）也简称为神经网络（NNs）或称作连接模型（Connection Model），它是一种模仿动物神经网络行为特征，进行分布式并行信息处理的算法数学模型。这种网络依靠系统的复杂程度，通过调整内部大量节点之间相互连接的关系，从而达到处理信息的目的。\n\n\n\n前言\n  本博客针对神经网络期末考试课程整理，由于该授课老师对考试内容透露较少，因此整理的内容不一定能准确的压到，请做好心理准备。\n\n\n\n目录\n\n  前言\n...",
  "content"  : "  人工神经网络（Artificial Neural Networks，简写为ANNs）也简称为神经网络（NNs）或称作连接模型（Connection Model），它是一种模仿动物神经网络行为特征，进行分布式并行信息处理的算法数学模型。这种网络依靠系统的复杂程度，通过调整内部大量节点之间相互连接的关系，从而达到处理信息的目的。\n\n\n\n前言\n  本博客针对神经网络期末考试课程整理，由于该授课老师对考试内容透露较少，因此整理的内容不一定能准确的压到，请做好心理准备。\n\n\n\n目录\n\n  前言\n  目录\n  正文\n    \n      问答题\n        \n          1 神经网络的优化方案（5条）\n          2 过拟合的优化方案（5条）\n          3 对公式中的参数解释\n          4（必考）列举深度学习中最常见的激活函数并说明（3条）\n          5 CNN的基本结构，有哪些基本模块和功能\n          6 卷积神经网络相关问题\n            \n              6.1 卷积神经网络主要工作是什么？\n              6.2 池化层的池化作用\n              6.3简述两种池化方式\n            \n          \n          7 对一些名词的解释\n            \n              Epoch\n              Batch\n              interation\n            \n          \n        \n      \n      编程题\n        \n          A卷\n            \n              1 导入tensorflow模块并命名为tf\n              2 利用constent创建一个形状为2*2，数值分别为[1,2,3,4]，类型为float的常量tensor_a\n              3 创建一个形状为2*2的变量tensor_b，并且b中的每个元素的值为1\n              4 将两个tensor_a和tensor_b相加，定义为tensor_c\n              5 tensor_c的数值是多少\n            \n          \n          B卷\n            \n              1 导入tensorflow模块并命名为tf\n              2 利用constent创建一个形状为3*2，数值分别为[1,2,3,4,5,6]，类型为float的常量tensor_a\n              3 创建一个形状为2*2的变量tensor_b，并且b中的每个元素的值为1\n              4 将两个tensor_a 和tensor_b数乘，定义为tensor_c\n              5 tensor_c的数值是多少\n            \n          \n        \n      \n      计算大题\n        \n          卷积计算（灰度图像）\n            \n              1 根据卷积以上输入数据和卷积核给出每次卷积的过程。（12’）\n              2 最终的特征图是什么？(3’)\n            \n          \n          多通道（彩色图像）\n            \n              1 请给出每次卷积的过程。(12’)\n              2 最终的特征图是什么？(3’)\n            \n          \n        \n      \n      设计题（开放性题目）\n        \n          1_A 中文电影评论分类的目标是什么？并说明其意义。\n          1_B 垃圾邮件分类的目标是什么？并说明其意义。\n          2 设计一个基于循环神经网络分类器，要考虑哪些问题。（3点）\n            \n              2.1 电影评论的解法\n              2.2 垃圾邮件的解法\n            \n          \n          列举至少2个评估模型性能的指标，并说明原因。\n            \n              3.1 电影评论的解法\n              3.2 垃圾邮件的解法\n            \n          \n          4_a 请设计一种循环神经网络模型，用于中文电影评论情感分析，并且介绍你所设计模型的结构\n          4_b 请设计一种循环神经网络模型，用于中文电影评论情感分析，并且介绍你所设计模型的结构\n        \n      \n      选择题 \\&amp;amp; 判断\n        \n          重点掌握部分\n          非重点掌握部分\n        \n      \n    \n  \n\n\n\n\n正文\n\n问答题\n\n1 神经网络的优化方案（5条）\n\n\n  通过改变模型待优化的参数和神经网络层数来改变网络模型的复杂度。\n  选择更加合适的损失函数\n  优化学习率\n  选择更加合适的优化器\n  数据集增强\n  正则化\n  使用dropout防止过拟合\n\n\n\n\n2 过拟合的优化方案（5条）\n\n数据层面：\n  （1）获取更多的数据集：数据增强\n  （2）数据预处理：清洗数据，筛选更高质量的特征\n\n模型层面：\n  （1）选择简单的模型\n  （2）加入正则化：L1，L2正则化，降低模型的复杂度\n\n更多方法：\n  （1）加入噪声：减少频繁出现的无意义的模式\n  （2）dropout：随机去除一部分的神经元\n\n\n\n3 对公式中的参数解释\n\n\\[\\sum w_i*x_i + b = wx + b\\]\n\n  \\(w_i\\) :权重变量\n  \\(x_i\\) :数据输入变量\n  \\(b\\) :偏置\n\n\n\n4（必考）列举深度学习中最常见的激活函数并说明（3条）\n\n\n  sigmoid函数：取值范围为(0,1)，它可以将一个实数映射到(0,1)的区间。\n  tanh函数：tanh函数也叫也称为双切正切函数，取值范围为[-1,1]。\n  ReLU函数：将负数映射为0，将正数保留不变。\n  Softmax函数：将一组任意实数值映射到一个概率分布，其中每个值都是正的并且总和等于1。\n  Leaky ReLU函数：在负区域返回一个小的斜率而不是0。\n\n\n\n\n5 CNN的基本结构，有哪些基本模块和功能\n\n基本组成单元:\n  具有可学习的权重和偏置的神经元组成\n\n基本层级构造\n  输入层：数据的输入（通常是图像）\n  卷积层：使用卷积进行特征提取和映射\n  激活函数：增加非线性映射\n  池化层：下采样，对特征图稀疏处理，减少数据运算量\n  全连接层：通常在尾部，对数据重新拟合并输出分类结果\n\n\n\n6 卷积神经网络相关问题\n\n6.1 卷积神经网络主要工作是什么？\n  提取特征。\n\n6.2 池化层的池化作用\n\n  作用：降维,缩减模型大小。提高计算速度\n\n6.3简述两种池化方式\n\n最大池化：\n  输入张量中的每个窗口映射到该窗口中的最大值。它能够保留局部特征的最大值并压缩输入的空间维度\n\n均值池化：\n  将输入张量中的每个窗口映射到该窗口中的平均值。它能够对输入进行平滑处理并压缩输入的空间维度。\n\n\n\n7 对一些名词的解释\n\nEpoch\n  表示整个数据集的一次迭代。\n\nBatch\n  指的是不能一次性将整个数据集传递给神经网络，所以我们将数据集分成几个批处理，每一批称为Batch\n\ninteration\n  迭代的次数。例如我们有10000张图像作为数据，Batch大小为200。那么一个Epoch 应该运行50次Iteration(10,000除以200)。\n\n\n\n编程题\n\nA卷\n\n1 导入tensorflow模块并命名为tf\n\nimport tensorflow as tf\n\n\n2 利用constent创建一个形状为2*2，数值分别为[1,2,3,4]，类型为float的常量tensor_a\n\ntensor_a = tf.constent([[1,2,3,4]],shape=[2,2],dtype=tf.float32)\n\n\n3 创建一个形状为2*2的变量tensor_b，并且b中的每个元素的值为1\n\ntensor_b = tf.Variable(tf.ones([2,2]))\n\n\n4 将两个tensor_a和tensor_b相加，定义为tensor_c\n\nc = tf.add(tensor_a,tensor_b)\n\n\n5 tensor_c的数值是多少\n\n以下是完整的输出(你只需要写array中的内容即可)\n&amp;gt;&amp;gt;&amp;gt; c\n\n&amp;lt;tf.Tensor:shape=(2,2),dtype=float32,numpy=\narray([[2.,3.],\n       [4.,5.]], dtype=float32)&amp;gt;\n\n\n\n\nB卷\n\n1 导入tensorflow模块并命名为tf\n\nimport tensorflow as tf\n\n\n2 利用constent创建一个形状为3*2，数值分别为[1,2,3,4,5,6]，类型为float的常量tensor_a\n\ntensor_a = tf.constent([[1,2,3,4,5,6]],shape=[3,2],dtype=tf.float32)\n\n\n3 创建一个形状为2*2的变量tensor_b，并且b中的每个元素的值为1\n\ntensor_b = tf.Variable(tf.ones([2,2]))\n\n\n4 将两个tensor_a 和tensor_b数乘，定义为tensor_c\n\ntensor_c = tf.matmul(tensor_a,tensor_b)\n\n\n5 tensor_c的数值是多少\n\n以下是完整的输出(你只需要写array中的内容即可)\n\n&amp;gt;&amp;gt;&amp;gt; c\n\n&amp;lt;tf.Tensor:shape=(2,2),dtype=float32,numpy=\narray([[3.,3.],\n       [7.,7.],\n       [11.,11.]], dtype=float32)&amp;gt;\n\n\n\n\n计算大题\n\n\n  以下图片只是做一个示例，考试时请自行计算，要求，每一步都必须要写到位，每一个像素值都需要计算\n示例中空白的部分在考试时需要补全\n\n\n卷积计算（灰度图像）\n\n\n    \n    \n        \n    \n    \n\n\n1 根据卷积以上输入数据和卷积核给出每次卷积的过程。（12’）\n\n\n    \n    \n        \n    \n    \n\n\n2 最终的特征图是什么？(3’)\n\n\n    \n    \n        \n    \n    \n\n\n\n\n多通道（彩色图像）\n\n1 请给出每次卷积的过程。(12’)\n\n\n    \n    \n        \n    \n    \n\n\n2 最终的特征图是什么？(3’)\n\n\n    \n    \n        \n    \n    \n\n\n\n\n设计题（开放性题目）\n\n本题针对两个题面进行分析，分别是：“中文电影评论情感分析”、“垃圾邮件分类”。\n\n1_A 中文电影评论分类的目标是什么？并说明其意义。\n\n  目标：对电影评论进行分类。\n  意义：根据模型识别出电影的评论是正面的还是负面的，有助于对电影做出定性的分析。\n\n1_B 垃圾邮件分类的目标是什么？并说明其意义。\n\n  目标：对邮件进行分类\n  意义：将邮件分为，有用邮件和垃圾邮件，有助于对邮件做出定性的分析。\n\n\n\n2 设计一个基于循环神经网络分类器，要考虑哪些问题。（3点）\n\n2.1 电影评论的解法\n\n\n  数据的处理问题：需要收集电影评论数据并进行清洗、去重、分词等预处理操作。\n  模型的选择问题：选择双向LSTM神经网络，作为该神经网络的分类器。因为双向LSTM可以同时考虑历史和未来的信息，从而更好地预测当前时间步的输出。\n  训练方式的选择：使用监督学习的方式训练LSTM网络分类器。使用数据量较大时考虑使用采用批量训练的方式。\n  模型评估的方法选择：结合交叉验证来评估模型性能。\n  要防止过拟合的发生：采用一些正则化技术，如L1、L2正则化和dropout等方法来缓解。\n\n\n2.2 垃圾邮件的解法\n\n\n  数据的处理问题：需要收集邮件数据并进行清洗、去重、分词等预处理操作。\n  模型的选择问题：选择双向LSTM神经网络，作为该神经网络的分类器。因为双向LSTM可以同时考虑历史和未来的信息，从而更好地预测当前时间步的输出。\n  训练方式的选择：使用监督学习的方式训练LSTM网络分类器。使用数据量较大时考虑使用采用批量训练的方式。\n  模型评估的方法选择：结合交叉验证来评估模型性能。\n  要防止过拟合的发生：采用一些正则化技术，如L1、L2正则化和dropout等方法来缓解。\n\n\n列举至少2个评估模型性能的指标，并说明原因。\n\n3.1 电影评论的解法\n\n\n  准确率：它表示分类器正确预测样本标签的比例。在电影情感分析任务中，准确率可以告诉我们分类器正确预测情感极性评论的比例。\n  召回率：指实际为正例的样本中被分类器正确识别为正例的比例。在情感分析中，召回率可以衡量分类器正确捕捉到所有积极或消极评论的能力。\n  AUC值：AUC值越大，则分类器的性能越好，在正负样本不平衡时可以使用。\n  F1值：分数是准确率和召回率的加权平均值，它综合了两者的影响。F1分数越高，则分类器的性能越好。\n\n\n3.2 垃圾邮件的解法\n\n\n  准确率：它表示分类器正确预测样本标签的比例。在电影情感分析任务中，在垃圾邮件分类任务中，准确率可以告诉我们分类器正确预测垃圾邮件或非垃圾邮件的比例。。\n  召回率：指实际为正例的样本中被分类器正确识别为正例的比例。在垃圾邮件分类中，召回率可以衡量分类器正确捕捉到所有垃圾邮件的能力。\n  AUC值：AUC值越大，则分类器的性能越好，在正负样本不平衡时可以使用。\n  F1值：分数是准确率和召回率的加权平均值，它综合了两者的影响。F1分数越高，则分类器的性能越好。\n\n\n4_a 请设计一种循环神经网络模型，用于中文电影评论情感分析，并且介绍你所设计模型的结构\n\n这里选用LSTM循环神经网络\n\n\n  输入层：接受原始文本数据，即需要进行情感分类的中文电影评论，将每一个中文文本转化为词向量。\n  Embedding Layer（嵌入层）：使用预训练的中文词向量来初始化嵌入层参数。\n  LSTM层：按顺序处理每个词向量，并输出相应的隐藏状态向量和记忆状态向量。\n  全局最大池化层：提取整个序列的最大特征向量，减少模型复杂度并提高泛化性能。在此模型中，用全局最大池化来得到固定长度的特征向量。\n  全连接层：全连接层接收全局池化层的输出，可以进一步提取高级特征，并通过ReLU激活函数进行非线性映射。\n  Sigmoid层：输出层采用Sigmoid函数作为激活函数，将全连接层的输出映射到0~1之间。\n  Output（输出层）：生成最终的模型预测结果，即电影评论的正向与负向\n\n\n最后使用交叉熵损失函数作为目标函数，使用反向传播算法进行参数更新。\n\n4_b 请设计一种循环神经网络模型，用于中文电影评论情感分析，并且介绍你所设计模型的结构\n\n这里选用LSTM循环神经网络\n\n\n  输入层：接受原始文本数据，即需要进行分类的邮件信息，将每一个文本转化为词向量。\n  Embedding Layer（嵌入层）：使用预训练的词向量来初始化嵌入层参数。\n  LSTM层：按顺序处理每个词向量，并输出相应的隐藏状态向量和记忆状态向量。\n  全局最大池化层：提取整个序列的最大特征向量，减少模型复杂度并提高泛化性能。在此模型中，用全局最大池化来得到固定长度的特征向量。\n  全连接层：全连接层接收全局池化层的输出，可以进一步提取高级特征，并通过ReLU激活函数进行非线性映射。\n  Sigmoid层：输出层采用Sigmoid函数作为激活函数，将全连接层的输出映射到0~1之间。\n  Output（输出层）：生成最终的模型预测结果，即邮件是否为垃圾邮件的评定。\n\n\n最后使用交叉熵损失函数作为目标函数，使用反向传播算法进行参数更新。\n\n\n\n选择题 &amp;amp; 判断\n\n重点掌握部分\n\n1.【单选】\n以下关于深度学习描述正确的是\n\n\tA. 深度学习是机器学习的一个分支\n\tB. 深度学习与机器学习是互相包含的关系\n\tC. 深度学习与机器学习同属于人工智能但相互之间没有关系\n\tD. 以上都不对\n\n\n正确答案：A\n\n2.【单选】\n传统机器学习和深度学习是人工智能核心技术，在工程流程上略有差别，以下步骤在深度学习中不需要做的是\n\n\tA. 模型评估\n\tB. 特征工程\n\tC. 数据清洗\n\tD. 模型构建\n\n\n正确答案：B\n\n3.【单选】\n是指根据文本所表达的含义和情感信息将文本划分成褒扬的或贬义的两种或几种类型，是对文本作者倾向性和观点、态度的划分，因此有时也称倾向性分析。\n\n\tA. 语音识别\n\tB. 机器学习\n\tC. 自然语言处理\n\tD. 情感分类\n\n\n正确答案：D\n\n4.【单选】\n下列有关单层感知器的说法错误的是？（  ）\n\n\tA. 包含输入层、隐藏层和输出层\n\tB. 包含求和和激活操作\n\tC. 能够解决“与门”操作\n\tD. “与门”的线性分割线的斜率有权值决定\n\n\n正确答案：A\n\n5.【单选】\n若输入x1=1，x2=0，对应的权值分别为0.5，0.5，则经过过sign函数后的值是多少？（  ）\n\n\tA. 0\n\tB. 1\n\n\n正确答案：B\n\n6.【单选】\n如果我们希望预测n个类（p1，p2 … pk）的概率使得所有n的p的和等于1，那么下列哪个函数可以用作输出层中的激活函数？（  ）\n\n\tA. softmax\n\tB. ReLU\n\tC. Sigmoid\n\tD. Tanh\n\n\n正确答案：A\n\n7.【单选】\n将Sigmoid激活函数改为ReLu，将有助于克服梯度消失问题？（  ）\n\n\tA. 对\n\tB. 错\n\n\n正确答案：A\n\n8.【单选】\nSigmoid是神经网络中最常用到的一种激活函数，除非当梯度太大导致激活函数被弥散，这叫作神经元饱和。\n\n\n    \n    \n        \n    \n    \n\n\n这就是为什么ReLU会被提出来，因为ReLU可以使得梯度在正向时输出值与原始值一样。\n\n\n    \n    \n        \n    \n    \n\n\n这是否意味着在神经网络中ReLU单元永远不会饱和?（）\n\n\tA. 对的\n\tB. 错的\n\n\n正确答案：B\n\n9.【单选】\n您正在构建一个用于识别黄瓜（y=1）和西瓜（y=0）的二进制分类器。您建议将这些激活函数中的哪一个用于输出层？（  ）\n\n\tA. ReLU\n\tB. Leaky ReLU\n\tC. sigmoid\n\tD. tanh\n\n\n正确答案：C\n\n10.【单选】\n假定你在神经网络中的隐藏层中使用激活函数 X。在特定神经元给定任意输入，你会得到输出「-0.0001」。X 可能是以下哪一个激活函数？（  ）\n\n\tA. ReLU\n\tB. tanh（x）\n\tC. sigmoid\n\tD. 以上都不是\n\n\n正确答案：B\n\n11.【单选】\nDNN的全称是（）\n\n\tA. 深度神经网络\n\tB. 深度学习网络\n\tC. 动态神经网络\n\tD. 动态学习网络\n\n\n正确答案：A\n\n12.【单选】\n下列有关全连接网络说法正确的是（  ）：\n\n\tA. 每个神经元具有激活函数功能\n\tB. 每一个神经元与下一层的神经元完全连接\n\tC. 神经元之间不存在跨层连接\n\tD. 以上都正确\n\n\n正确答案：D\n\n13.【单选】\n在一个神经网络中，知道每一个神经元的权重和偏差是最重要的一步。如果知道了神经元准确的权重和偏差，便可以近似任何函数，但怎么获知每个神经的权重和偏移呢（  ）\n\n\tA. 搜索每个可能的权重和偏差组合，直到得到最佳值\n\tB. 赋予一个初始值，然后检查跟最佳值的差值，不断迭代调整权重\n\tC. 随机赋值\n\tD. 以上都不正确\n\n\n正确答案：B\n\n14.【单选】\n假设神经元的输入值为（1,2,3），对应的权重为4,5,6，神经元经过一个线性函数y=2x，最终的输出结果是多少（  ）\n\n\tA. 32\n\tB. 64\n\tC. 96\n\tD. 48\n\n\n正确答案：B\n\n15.【单选】\n\n下列声明哪些是正确的？（  ）\n\n声明1：可以通过将所有权重初始化为0来训练网络\n\n声明2：可以通过将偏差初始化为0来训练网络\n\n\tA. 1对2错\n\tB. 1错2对\n\tC. 1和2都对\n\tD. 1和2都错\n\n\n正确答案：B\n\n16.【单选】\n我们在训练神经网络过程中，使用梯度下降法不断更新哪种数值，进而使得损失函数最小化?（）\n\n\tA. 样本数目\n\tB. 特征值\n\tC. 超参数\n\tD. 参数\n\n\n正确答案：D\n\n17.【单选】\n在神经网络中，我们是通过以下哪个方法在训练网络的时候更新参数，从而最小化损失函数的?\n\n\tA. 正向传播算法\n\tB. 池化计算\n\tC. 卷积计算\n\tD. 反向传播算法\n\n\n正确答案：D\n\n18.【单选】\n单层感知器能够实现异或问题的分类，这句话是否正确？（  ）\n\n\tA. 正确\n\tB. 错误\n\n\n正确答案：B\n\n19.【单选】\n如果我们用了一个过大的学习速率会发生什么？（  ）\n\n\tA. 神经网络会收敛\n\tB. 不好说\n\tC. 都不对\n\tD. 神经网络不会收敛\n\n\n正确答案：D\n\n20.【单选】\n在下图中，我们可以观察到误差出现了许多小的”涨落”。 这种情况我们应该担心吗？（  ）\n\n\n    \n    \n        \n    \n    \n\n\n\tA. 需要，这也许意味着神经网络的学习速率存在问题\n\tB. 不需要，只要在训练集和交叉验证集上有累积的下降就可以了\n\tC. 不确定\n\n\n正确答案：B\n\n21.【单选】\n当神经网络的调参效果不好时，需要从哪些角度考虑？（ ）\n\n1 是否找到合适的损失函数\n\n2 batch size是否合适\n\n3 是否选择了和是的激活函数\n\n4 是否选择合适的学习率\n\n5 是否过拟合\n\n\tA. 1,3,4,5\n\tB. 1,2,3,4\n\tC. 全部都不是\n\tD. 全部都是\n\n\n正确答案：D\n\n22.【单选】\n学习率会影响待优化的参数的收敛吗？\n\n\tA. 会\n\tB. 不会\n\n\n正确答案：A\n\n23.【单选】\n在训练神经网络时，损失函数(loss)在最初的几个epochs时没有下降，可能的原因是？（  ）\n\n\n    \n    \n        \n    \n    \n\n\n\tA. 学习率太高\n\tB. 正则参数太高\n\tC. 陷入局部最小值\n\tD. 以上都有可能\n\n\n正确答案：D\n\n24.【单选】学习率（），会导致待优化的参数在最小值附近波动，不收敛；学习率（），会导致待优化的参数收敛缓慢。\n\n\tA. 过小；过大\n\tB. 过大；过小\n\tC. 过大；过大\n\tD. 过小；过小\n\n\n正确答案：B\n\n25.【单选】当训练一个神经网络来作图像识别任务时，通常会绘制一张训练集误差和交叉训练集误差图来进行调试。\n\n\n    \n    \n        \n    \n    \n\n\n在上图中，最好在哪个时间停止训练？（  ）\n\n\tA. A\n\tB. B\n\tC. C\n\tD. D\n\n\n正确答案：C\n\n26.【单选】\n在选择神经网络的深度时，下面哪些参数需要考虑？（  ）\n\n1 神经网络的类型(如MLP,CNN)\n\n2 输入数据\n\n3 计算能力(硬件和软件能力决定)\n\n4 学习速率\n\n5 映射的输出函数\n\n\tA. 1,2,3,5\n\tB. 2,3,4,5\n\tC. 都需要\n\tD. 1,3,4,5\n\n\n正确答案：C\n\n27.【单选】\nDropout对一个神经元随机屏蔽输入权重这句话是否正确？（  ）\n\n\tA. 正确的\n\tB. 错误的\n\n\n正确答案：B\n\n28.【单选】\n在一个神经网络中，下面哪种方法可以用来处理过拟合？（  ）\n\n\tA. dropout\n\tB. 分批归一化\n\tC. 正则化\n\tD. 以上都可以\n\n\n正确答案：D\n\n29.【单选】\n下列的哪种方法可以用来降低深度学习模型的过拟合问题？（  ）\n\n1 增加更多的数据\n\n2 使用数据扩增技术(data augmentation)\n\n3 使用归纳性更好的架构\n\n4 正规化数据\n\n5 降低架构的复杂度\n\n\tA. 1,4,5\n\tB. 1,2,3\n\tC. 1,3,4,5\n\tD. 所有都可以\n\n\n正确答案：D\n\n30.【单选】\n数据规一化(Normalization)的好处都有啥？（  ）\n\n\tA. 让每一层的输入的范围都大致固定\n\tB. 它将权重的归一化平均值和标准差\n\tC. 它是一种非常有效的反向传播(BP)方法\n\tD. 以上都不正确\n\n\n正确答案：A\n\n31.【单选】\n单层的神经网络反向传播算法也适用多层神经网络的反向传播，这句话正确吗？（  ）\n\n\tA. 正确\n\tB. 不正确\n\n\n正确答案：B\n\n32.【单选】前馈神经网络是指网络只能前向传播，不能后向传播，这句话是否正确（  ）\n\n\tA. 正确的\n\tB. 错误的\n\n\n正确答案：B\n\n33.【单选】\n“所谓的权值共享就是说，用一个卷积核去卷积一张图，这张图每个位置是被同样数值的卷积核操作的，权重是一样的”，这句话是否正确\n\n\tA. 正确\n\tB. 错误\n\tC. 不确定\n\n\n正确答案：A\n\n34.【单选】\nCNN是卷积神经网络，它的关键层有哪些？（ ）1 输入层2 卷积层3 激活层4 池化层5 全连接层\n\n\tA. 1,2,3,4\n\tB. 1,2,3,4,5\n\tC. 2,4\n\n\n正确答案：B\n\n35.【单选】\n关于循环神经网络以下说法错误的是?\n\n\tA. 循环神经网络可以根据时间轴展开\n\tB. LSTM 无法解决梯度消失的问题\n\tC. LSTM 也是一种循环神经网络\n\tD. 循环神经网络可以简写为 RNN\n\n\n正确答案：B\n\n36.【单选】\n关于循环神经网络，哪个不是LSTM的门?\n\n\tA. 输入门\n\tB. 遗忘门\n\tC. 输出门\n\tD. 更新门\n\n\n正确答案：D\n\n37.【单选】\n“门”的出现可以帮助防止在RNN中的梯度消失问题。（ ）\n\n\tA. 对\n\tB. 错\n\n\n正确答案：A\n\n38.【单选】\n以下关于标准 RNN 模型，说法正确的是?\n\n\tA. 不存在一对一的模型结构\n\tB. 反向传播时不考虑时间方向\n\tC. 不存在多对多的模型结构\n\tD. 会出现长时间传输记忆的信息衰减的问题\n\n\n正确答案：D\n\n39.【单选】深度学习可以用在下列哪些NLP任务中？（  ）\n\n\tA. 情感分析\n\tB. 问答系统\n\tC. 机器翻译\n\tD. 所有选项\n\n\n正确答案：D\n\n40.【单选】给定一个长度为n的不完整单词序列，我们希望预测下一个字母是什么。比如输入是“predictio”(9个字母组成)，希望预测第十个字母是什么。下面哪种神经网络结构适用于解决这个工作？（  ）\n\n\tA. 循环神经网络\n\tB. 卷积神经网络\n\tC. 全连接神经网络\n\tD. 以上都不是\n\n\n正确答案：A\n\n41.【单选】以下哪项任务优先选择使用卷积神经网络来实现\n\n\tA. 图像数据获取\n\tB. 图像预处理\n\tC. 图像特征提取\n\tD. 图像数据增强\n\n\n正确答案：C\n\n42.【单选】\n对于一个图像识别问题(在一张照片里找出一只猫)，下面哪种神经网络可以更好地解决这个问题？（  ）\n\n\tA. 循环神经网络\n\tB. 感知机\n\tC. 多层感知机\n\tD. 卷积神经网络\n\n\n正确答案：D\n\n43.【单选】\n在训练CNN时，可以对输入进行旋转、平移、缩放等预处理提高模型泛化能力。这么说是对，还是不对？（  ）\n\n\tA. 对\n\tB. 不对\n\n\n正确答案：A\n\n44.【单选】\n一个32X32大小的图像，通过步长为4，尺寸为4X4的池化运算后，尺寸变为\n\n\tA. 14X14\n\tB. 2X2\n\tC. 28X28\n\tD. 8X8\n\n\n正确答案：D\n\n45.【单选】\n图像卷积处理中，例如32X32，strides=1，padding=”VALID”，FILTER卷积核3*3，则经过卷积处理之后图像尺寸变为?\n\n\tA. 28X28\n\tB. 14X14\n\tC. 30X30\n\tD. 32X32\n\n\n正确答案：C\n\n\n\n非重点掌握部分\n\n1.【单选】给定一个长度为n的不完整单词序列，我们希望预测下一个字母是什么。比如输入是“predictio”(9个字母组成)，希望预测第十个字母是什么。下面哪种神经网络结构适用于解决这个工作？（  ）\n\n\tA. 循环神经网络\n\tB. 卷积神经网络\n\tC. 全连接神经网络\n\tD. 以上都不是\n\n\n正确答案：A\n\n2.【单选】关于循环神经网络，哪个不是LSTM的门?\n\n\tA. 输入门\n\tB. 遗忘门\n\tC. 输出门\n\tD. 更新门\n\n\n正确答案：D\n\n3.【单选】\n以下哪项任务优先选择使用卷积神经网络来实现\n\n\tA. 图像数据获取\n\tB. 图像预处理\n\tC. 图像特征提取\n\tD. 图像数据增强\n\n\n正确答案：C\n\n4.【单选】\n对于一个图像识别问题(在一张照片里找出一只猫)，下面哪种神经网络可以更好地解决这个问题？（  ）\n\n\tA. 循环神经网络\n\tB. 感知机\n\tC. 多层感知机\n\tD. 卷积神经网络\n\n\n正确答案：D\n\n5.【单选】\n若输入x1=1，x2=0，对应的权值分别为0.5，0.5，则经过过sign函数后的值是多少？（  ）\n\n\tA. 0\n\tB. 1\n\n\n正确答案：B\n\n6.【单选】\n在神经网络中，我们是通过以下哪个方法在训练网络的时候更新参数，从而最小化损失函数的?\n\n\tA. 正向传播算法\n\tB. 池化计算\n\tC. 卷积计算\n\tD. 反向传播算法\n\n\n正确答案：D\n\n7.【单选】单层的神经网络反向传播算法也适用多层神经网络的反向传播，这句话正确吗？（  ）\n\n\tA. 正确\n\tB. 不正确\n\n\n正确答案：B\n\n8.【单选】前馈神经网络是指网络只能前向传播，不能后向传播，这句话是否正确（  ）\n\n\tA. 正确的\n\tB. 错误的\n\n\n正确答案：B\n\n9.【单选】\n学习率（），会导致待优化的参数在最小值附近波动，不收敛；学习率（），会导致待优化的参数收敛缓慢。\n\n\tA. 过小；过大\n\tB. 过大；过小\n\tC. 过大；过大\n\tD. 过小；过小\n\n\n正确答案：B\n\n10.【单选】\n学习率会影响待优化的参数的收敛吗？\n\n\tA. 会\n\tB. 不会\n\n\n正确答案：A\n\n11.【单选】\n下列有关LSTM的细胞状态正确的是。（）\n\n\tA. LSTM决定从细胞状态中丢弃什么信息\n\tB. LSTM决定什么信息增加到细胞状态中\n\tC. LSTM决定从细胞状态中输出什么信息\n\tD. 以上都是\n\n\n正确答案：D\n\n12.【单选】\n关于循环神经网络，哪个不是LSTM的门?\n\n\tA. 输入门\n\tB. 遗忘门\n\tC. 输出门\n\tD. 更新门\n\n\n正确答案：D\n\n13.【单选】\n给定一个长度为n的不完整单词序列，我们希望预测下一个字母是什么。比如输入是“predictio”(9个字母组成)，希望预测第十个字母是什么。下面哪种神经网络结构适用于解决这个工作？（  ）\n\n\tA. 循环神经网络\n\tB. 卷积神经网络\n\tC. 全连接神经网络\n\tD. 以上都不是\n\n\n正确答案：A\n\n14.【单选】\n构建一个神经网络，将前一层的输出和它自身作为输入。\n\n\n    \n    \n        \n    \n    \n\n\n下列哪一种架构有反馈连接？（  ）\n\n\tA. 循环神经网络\n\tB. 卷积神经网络\n\tC. 限制玻尔兹曼机\n\tD. 以上都不正确\n\n\n正确答案：A\n\n15.【单选】\n“门”的出现可以帮助防止在RNN中的梯度消失问题。（ ）\n\n\tA. 对\n\tB. 错\n\n\n正确答案：A\n\n16.【单选】\n以下关于标准 RNN 模型，说法正确的是?\n\n\tA. 不存在一对一的模型结构\n\tB. 反向传播时不考虑时间方向\n\tC. 不存在多对多的模型结构\n\tD. 会出现长时间传输记忆的信息衰减的问题\n\n\n正确答案：D\n\n17.【单选】\n以下关于标准 RNN 模型，说法正确的是?\n\n\tA. 不存在一对一的模型结构\n\tB. 反向传播时不考虑时间方向\n\tC. 不存在多对多的模型结构\n\tD. 会出现长时间传输记忆的信息衰减的问题\n\n\n正确答案：D\n\n18.【单选】\n一个循环神经网络可以被展开成为一个完全连接的、具有无限长度的普通神经网络，这种说法是（  ）。\n\n\tA. 正确的\n\tB. 错误的\n\n\n正确答案：A\n\n19.【单选】\n输入图片大小为200×200，依次经过一层卷积（kernel size 5×5，same padding ，stride 2），pooling（kernel size 3×3，valid padding ，stride 1），又一层卷积（kernel size 3×3，same padding，stride 1）之后，输出特征图大小为（  ）\n\n\tA. 96\n\tB. 97\n\tC. 98\n\n\n正确答案：C\n\n20.【单选】\n增加卷积核的大小对于改进卷积神经网络的效果是必要的吗？（  ）\n\n\tA. 没听说过\n\tB. 是\n\tC. 否\n\tD. 不知道\n\n\n正确答案：C\n\n21.【单选】\n在训练CNN时，可以对输入进行旋转、平移、缩放等预处理提高模型泛化能力。这么说是对，还是不对？（  ）\n\n\tA. 对\n\tB. 不对\n\n\n正确答案：A\n\n22.【单选】\n当构建一个神经网络进行图片的语义分割时，通常采用下面哪种顺序？（  ）\n\n\tA. 先用卷积神经网络处理输入，再用反卷积神经网络得到输出\n\tB. 先用反卷积神经网络处理输入，再用卷积神经网络得到输出\n\tC. 不确定\n\n\n正确答案：A\n\n23.【单选】\n假设下方是传入最大池化层的一个输入，该层中神经元的池化大小为(3,3)\n\n\n    \n    \n        \n    \n    \n\n\n那么，该池化层的输出是多少？（  ）\n\n\tA. 3\n\tB. 7\n\tC. 5\n\tD. 5.5\n\n\n正确答案：B\n\n24.【单选】在一个神经网络中，下面哪种方法可以用来处理过拟合？（  ）\n\n\tA. dropout\n\tB. 分批归一化\n\tC. 正则化\n\tD. 以上都可以\n\n\n正确答案：D\n\n25.【单选】下列的哪种方法可以用来降低深度学习模型的过拟合问题？（  ）\n\n1 增加更多的数据\n\n2 使用数据扩增技术(data augmentation)\n\n3 使用归纳性更好的架构\n\n4 正规化数据\n\n5 降低架构的复杂度\n\n\tA. 1,4,5\n\tB. 1,2,3\n\tC. 1,3,4,5\n\tD. 所有都可以\n\n\n正确答案：D\n\n26.【多选】优化神经网络可以从哪些方面入手？（）\n\n\tA. 学习率的优化\n\tB. 梯度下降的优化\n\tC. 过拟合和欠拟合的优化\n\tD. 梯度的优化\n\n\n正确答案：A,B,C\n\n27.【单选】当神经网络的调参效果不好时，需要从哪些角度考虑？（ ）\n\n1 是否找到合适的损失函数\n\n2 batch size是否合适\n\n3 是否选择了和是的激活函数\n\n4 是否选择合适的学习率\n\n5 是否过拟合\n\n\tA. 1,3,4,5\n\tB. 1,2,3,4\n\tC. 全部都不是\n\tD. 全部都是\n\n\n正确答案：D\n\n28.【单选】过拟合和欠拟合的优化不包括以下哪种方法？（）\n\n\tA. Dropout\n\tB. Bagging\n\tC. 梯度下降法\n\tD. 正则化\n\n\n正确答案：C\n\n29.【单选】单层的神经网络反向传播算法也适用多层神经网络的反向传播，这句话正确吗？（  ）\n\n\tA. 正确\n\tB. 不正确\n\n\n正确答案：B\n\n30.【单选】一个完成的反向传播的步骤是（  ）\n\n1 将隐藏层误差反向传播给输入层，调节隐藏层到输入层的权值和阈值\n\n2 将输出层的误差反向传播给隐藏层，调整隐藏层到输出层的权值和阈值\n\n3 将隐藏层的误差反向传播给隐藏层，调节隐藏层到隐藏层的权值和阈值\n\n\tA. 1 2 3\n\tB. 2 1 3\n\tC. 1 3 2\n\tD. 2 3 1\n\n\n正确答案：D\n\n31.【单选】已知：\n\n\n  \n    大脑是有很多个叫做神经元的东西构成，神经网络是对大脑的简单的数学表达。\n  \n  \n    每一个神经元都有输入、处理函数和输出。\n  \n  \n    神经元组合起来形成了网络，可以拟合任何函数。\n  \n  \n    为了得到最佳的神经网络，我们用梯度下降方法不断更新模型\n  \n\n\n给定上述关于神经网络的描述，什么情况下神经网络模型被称为深度学习模型？（  ）\n\n\tA. 加入更多层，使神经网络的深度增加\n\tB. 有维度更高的数据\n\tC. 当这是一个图形识别的问题\n\tD. 以上都不正确\n\n\n正确答案：A\n\n32.【单选】前馈神经网络是指网络只能前向传播，不能后向传播，这句话是否正确（  ）\n\n\tA. 正确的\n\tB. 错误的\n\n\n正确答案：B\n\n33.【单选】反向传播算法一开始计算什么内容的梯度，之后将其反向传播？（  ）\n\n\tA. 预测结果与样本标签之间的误差\n\tB. 各个输入样本的平方差之和\n\tC. 各个网络权重的平方差之和\n\tD. 以上都不对\n\n\n正确答案：A\n\n34.【单选】下图中的数据是线性可分的么？（  ）\n\n\n    \n    \n        \n    \n    \n\n\n\tA. 是\n\tB. 否\n\n\n正确答案：B\n\n35.【单选】下列有关单层感知器的说法错误的是？（  ）\n\n\tA. 包含输入层、隐藏层和输出层\n\tB. 包含求和和激活操作\n\tC. 能够解决“与门”操作\n\tD. “与门”的线性分割线的斜率有权值决定\n\n\n正确答案：A\n\n36.【单选】神经网络结构的选择会影响训练模型的效果，神经元结构不包括哪方面的选择。（）\n\n\tA. depth\n\tB. width\n\tC. connectivity\n\tD. function\n\n\n正确答案：D\n\n37.【多选】神经网络模型的效果受神经元结构的影响，受哪方面的选择。（）\n\n\tA. depth\n\tB. width\n\tC. connectivity\n\tD. function\n\n\n正确答案：A,B,C\n\n38.【单选】传统机器学习和深度学习是人工智能核心技术，在工程流程上略有差别，以下步骤在深度学习中不需要做的是\n\n\tA. 模型评估\n\tB. 特征工程\n\tC. 数据清洗\n\tD. 模型构建\n\n\n正确答案：B\n\n39.【单选】如果我们用了一个过大的学习速率会发生什么？（  ）\n\n\tA. 神经网络不会收敛\n\tB. 不好说\n\tC. 都不对\n\tD. 神经网络会收敛\n\n\n正确答案：A\n\n40.【单选】过拟合和欠拟合的优化不包括以下哪种方法？（）\n\n\tA. Bagging\n\tB. Dropout\n\tC. 梯度下降法\n\tD. 正则化\n\n\n正确答案：C\n\n41.【多选】神经网络中优化方法有（）\n\n\tA. Adam\n\tB. 随机梯度下降法\n\tC. 随机下降法\n\tD. 梯度下降法\n\n\n正确答案：A,B,D\n\n42.【单选】在选择神经网络的深度时，下面哪些参数需要考虑？（  ）\n\n1 神经网络的类型(如MLP,CNN)\n\n2 输入数据\n\n3 计算能力(硬件和软件能力决定)\n\n4 学习速率\n\n5 映射的输出函数\n\n\tA. 都需要\n\tB. 2,3,4,5\n\tC. 1,2,3,5\n\tD. 1,3,4,5\n\n\n正确答案：A\n\n43.【单选】当训练一个神经网络来作图像识别任务时，通常会绘制一张训练集误差和交叉训练集误差图来进行调试。\n\n\n    \n    \n        \n    \n    \n\n\n在上图中，最好在哪个时间停止训练？（  ）\n\n\tA. C\n\tB. B\n\tC. D\n\tD. A\n\n\n正确答案：A\n\n44.【单选】当数据太大而不能同时在RAM中处理时，哪种梯度技术更有优势？（ ）\n\n\tA. 随机梯度下降(Stochastic Gradient Descent)\n\tB. 全批量梯度下降(Full Batch Gradient Descent )\n\n\n正确答案：A\n\n45.【单选】当神经网络的调参效果不好时，需要从哪些角度考虑？（ ）\n\n1 是否找到合适的损失函数\n\n2 batch size是否合适\n\n3 是否选择了和是的激活函数\n\n4 是否选择合适的学习率\n\n5 是否过拟合\n\n\tA. 1,3,4,5\n\tB. 全部都是\n\tC. 1,2,3,4\n\tD. 全部都不是\n\n\n正确答案：B\n\n46.【单选】下列的哪种方法可以用来降低深度学习模型的过拟合问题？（  ）\n\n1 增加更多的数据\n\n2 使用数据扩增技术(data augmentation)\n\n3 使用归纳性更好的架构\n\n4 正规化数据\n\n5 降低架构的复杂度\n\n\tA. 1,3,4,5\n\tB. 所有都可以\n\tC. 1,2,3\n\tD. 1,4,5\n\n\n正确答案：B\n\n47.【单选】在一个神经网络中，下面哪种方法可以用来处理过拟合？（  ）\n\n\tA. 分批归一化\n\tB. dropout\n\tC. 以上都可以\n\tD. 正则化\n\n\n正确答案：C\n\n48.【单选】下图中，红色曲线表示关于深度学习算法中每个时期的训练精度。绿色和蓝色曲线都表示验证的准确性。\n\n\n    \n    \n        \n    \n    \n\n\n哪条曲线表示过拟合overfitting？（  ）\n\n\tA. 绿色曲线\n\tB. 蓝色曲线\n\n\n正确答案：B\n\n49.【单选】以下词语中，与卷积神经网络的概念无关的是\n\n\tA. ImageNet\n\tB. 超平面\n\tC. BP算法\n\tD. 特征提取\n\n\n正确答案：B\n\n50.【单选】以下哪些是CNN网络常用的模型？（  ）\n\n1 LeNet-5\n\n2 AlexNet\n\n3 VGGNet\n\n4 Google Inception Net\n\n\tA. 1,2,3,4\n\tB. 1,2,3\n\tC. 2,3\n\n\n正确答案：A\n\n51.【单选】从图中趋势可见，如果增加神经网络的宽度，精确度会增加到一个特定阈值后，便开始降低。造成这一现象的可能原因是什么？（  ）\n\n\n    \n    \n        \n    \n    \n\n\n\tA. 即使增加卷积核的数量，只有少部分的核会被用作预测\n\tB. 当卷积核数量增加时，神经网络的预测能力（Power）会降低\n\tC. 当卷积核数量增加时，导致过拟合\n\tD. 以上都不正确\n\n\n正确答案：C\n\n52.【单选】输入图像已被转换为大小为28×28的矩阵和大小为7×7的步幅为1的核心/滤波器，填充方式是valid 。卷积矩阵的大小是多少？（  ）\n\n\tA. 22 X 22\n\tB. 21 X 21\n\tC. 28 X 28\n\tD. 7X 7\n\n\n正确答案：A\n\n53.【多选】借助池化，网络存储可以有效提升存储的利用率，池化操作通常有几种?\n\n\tA. 平均池化\n\tB. 卷积\n\tC. 最大池化\n\tD. 全连接\n\n\n正确答案：A,C\n\n54.【单选】在深度学习网络中，反向传播算法用于寻求最优参数，在反向传播算法中使用的什么法则进行逐层求导的?\n\n\tA. 链式法则\n\tB. 累加法则\n\tC. 对等法则\n\tD. 归一法则\n\n\n正确答案：A\n\n55.【单选】一个完成的反向传播的步骤是（  ）\n\n1 将隐藏层误差反向传播给输入层，调节隐藏层到输入层的权值和阈值\n\n2 将输出层的误差反向传播给隐藏层，调整隐藏层到输出层的权值和阈值\n\n3 将隐藏层的误差反向传播给隐藏层，调节隐藏层到隐藏层的权值和阈值\n\n\tA. 1 2 3\n\tB. 2 1 3\n\tC. 1 3 2\n\tD. 2 3 1\n\n\n正确答案：D\n\n56.【单选】前馈神经网络是指网络只能前向传播，不能后向传播，这句话是否正确（  ）\n\n\tA. 正确的\n\tB. 错误的\n\n\n正确答案：B\n\n57.【单选】反向传播算法一开始计算什么内容的梯度，之后将其反向传播？（  ）\n\n\tA. 预测结果与样本标签之间的误差\n\tB. 各个输入样本的平方差之和\n\tC. 各个网络权重的平方差之和\n\tD. 以上都不对\n\n\n正确答案：A\n\n58.【单选】单层的神经网络反向传播算法也适用多层神经网络的反向传播，这句话正确吗？（  ）\n\n\tA. 正确\n\tB. 不正确\n\n\n正确答案：B\n\n59.【单选】将Sigmoid激活函数改为ReLu，将有助于克服梯度消失问题？（  ）\n\n\tA. 对\n\tB. 错\n\n\n正确答案：A\n\n60.【单选】如果我们希望预测n个类（p1，p2 … pk）的概率使得所有n的p的和等于1，那么下列哪个函数可以用作输出层中的激活函数？（  ）\n\n\tA. softmax\n\tB. ReLU\n\tC. Sigmoid\n\tD. Tanh\n\n\n正确答案：A\n\n61.【单选】您正在构建一个用于识别黄瓜（y=1）和西瓜（y=0）的二进制分类器。您建议将这些激活函数中的哪一个用于输出层？（  ）\n\n\tA. ReLU\n\tB. Leaky ReLU\n\tC. sigmoid\n\tD. tanh\n\n\n正确答案：C\n\n62.【单选】下列哪个函数不可以做激活函数？（  ）\n\n\tA. y=tanh(x)\n\tB. y=sin(x)\n\tC. y=max(x,0)\n\tD. y=2x\n\n\n正确答案：D\n\n63.【单选】在输出层不能使用以下哪种激活函数来分类图像（  ）\n\n\tA. sigmoid\n\tB. Tanh\n\tC. ReLU\n\tD. If（x&amp;gt; 5,1,0）\n\n\n正确答案：C\n\n64.【单选】下列有关单层感知器的说法错误的是？（  ）\n\n\tA. 包含输入层、隐藏层和输出层\n\tB. 包含求和和激活操作\n\tC. 能够解决“与门”操作\n\tD. “与门”的线性分割线的斜率有权值决定\n\n\n正确答案：A\n\n65.【单选】神经网络最基本的结构不包括（）\n\n\tA. 输入层\n\tB. 激活层\n\tC. 隐藏层\n\tD. 输出层\n\n\n正确答案：B\n\n66.【单选】下列有关全连接网络说法正确的是（  ）：\n\n\tA. 每个神经元具有激活函数功能\n\tB. 每一个神经元与下一层的神经元完全连接\n\tC. 神经元之间不存在跨层连接\n\tD. 以上都正确\n\n\n正确答案：D\n\n67.【单选】单层感知器能够实现异或问题的分类，这句话是否正确？（  ）\n\n\tA. 正确\n\tB. 错误\n\n\n正确答案：B\n\n68.【单选】在一个简单的MLP模型中，输入层有8个神经元，隐藏层有5个神经元，输出层有1个神经元。隐藏输出层和输入隐藏层之间的权重矩阵的大小是多少（  ）\n\n\tA. [1 X 5]，[5 X 8]\n\tB. [8×5]，[1×5]\n\tC. [5×8]，[5×1]\n\tD. [5×1]，[8×5]\n\n\n正确答案：D\n\n69.【单选】以下关于深度学习描述正确的是\n\n\tA. 深度学习是机器学习的一个分支\n\tB. 深度学习与机器学习同属于人工智能但相互之间没有关系\n\tC. 深度学习与机器学习是互相包含的关系\n\tD. 以上都不对\n\n\n正确答案：A\n\n70.【单选】在输出层不能使用以下哪种激活函数来分类图像（  ）\n\n\tA. Tanh\n\tB. ReLU\n\tC. sigmoid\n\tD. If（x&amp;gt; 5,1,0）\n\n\n正确答案：B\n\n71.【单选】相比sigmoid激活函数，relu激活函数有什么优势？(  )\n\n\tA. 防止梯度消失\n\tB. ReLu函数简繁计算速度快\n\tC. 以上都是\n\tD. ReLu输出具有稀疏性\n\n\n正确答案：C\n\n72.【单选】下列哪个函数不可以做激活函数？（  ）\n\n\tA. y=tanh(x)\n\tB. y=2x\n\tC. y=max(x,0)\n\tD. y=sin(x)\n\n\n正确答案：B\n\n73.【单选】您正在构建一个用于识别黄瓜（y=1）和西瓜（y=0）的二进制分类器。您建议将这些激活函数中的哪一个用于输出层？（  ）\n\n\tA. Leaky ReLU\n\tB. tanh\n\tC. ReLU\n\tD. sigmoid\n\n\n正确答案：D\n\n74.【单选】若输入x1=1，x2=0，对应的权值分别为0.5，0.5，则经过过sign函数后的值是多少？（  ）\n\n\tA. 1\n\tB. 0\n\n\n正确答案：A\n\n75.【单选】如果我们希望预测n个类（p1，p2 … pk）的概率使得所有n的p的和等于1，那么下列哪个函数可以用作输出层中的激活函数？（  ）\n\n\tA. softmax\n\tB. Sigmoid\n\tC. Tanh\n\tD. ReLU\n\n\n正确答案：A\n\n76.【单选】将Sigmoid激活函数改为ReLu，将有助于克服梯度消失问题？（  ）\n\n\tA. 错\n\tB. 对\n\n\n正确答案：B\n\n77.【单选】您正在构建一个用于识别黄瓜（y=1）和西瓜（y=0）的二进制分类器。您建议将这些激活函数中的哪一个用于输出层？（  ）\n\n\tA. tanh\n\tB. Leaky ReLU\n\tC. ReLU\n\tD. sigmoid\n\n\n正确答案：D\n\n78.【单选】相比sigmoid激活函数，relu激活函数有什么优势？(  )\n\n\tA. ReLu输出具有稀疏性\n\tB. ReLu函数简繁计算速度快\n\tC. 防止梯度消失\n\tD. 以上都是\n\n\n正确答案：D\n\n79.【单选】以下关于深度学习描述正确的是\n\n\tA. 深度学习与机器学习是互相包含的关系\n\tB. 深度学习是机器学习的一个分支\n\tC. 深度学习与机器学习同属于人工智能但相互之间没有关系\n\tD. 以上都不对\n\n\n正确答案：B\n\n80.【多选】一般神经网络包括（）\n\n\tA. 输入层\n\tB. 隐藏层\n\tC. 激活层\n\tD. 输出层\n\n\n正确答案：A,B,D\n\n81.【单选】单层感知器能够实现异或问题的分类，这句话是否正确？（  ）\n\n\tA. 正确\n\tB. 错误\n\n\n正确答案：B\n\n82.【多选】已知全连接神经网络的某一层的参数总量为 330,则上一层和本层的神经元数量可能为?\n\n\tA. 33 和 10\n\tB. 9 和 33\n\tC. 32 和 10\n\tD. 10 和 33\n\n\n正确答案：A,D\n\n83.【单选】全连接神经网络，如果输入层为44X8矩阵，那么与它相连的第一级参数矩阵最有可能为\n\n\tA. 32X32矩阵\n\tB. 任意尺寸矩阵\n\tC. 32X4矩阵\n\tD. 8X5矩阵\n\n\n正确答案：D\n\n84.【多选】深度学习中常用的损失函数有\n\n\tA. 均方误差损失函数\n\tB. L1 损失函数\n\tC. 交叉熵误差损失函数\n\tD. 自下降损失函数\n\n\n正确答案：A,C\n\n85.【单选】若输入x1=1，x2=0，对应的权值分别为0.5，0.5，则经过过sign函数后的值是多少？（  ）\n\n\tA. 0\n\tB. 1\n\n\n正确答案：B\n\n86.【单选】梯度下降算法的正确步骤是什么？（  ）\n\n1 计算预测值和真实值之间的误差\n\n2 重复迭代，直至得到网络权重的最佳值\n\n3 把输入传入网络，得到输出值\n\n4 用随机值初始化权重和偏差\n\n5 对每一个产生误差的神经元，调整相应的（权重）值以减小误差\n\n\tA. 3，2，1，5，4\n\tB. 5，4，3，2，1\n\tC. 1，2，3，4，5\n\tD. 4，3，1，5，2 ​\n\n\n正确答案：D\n\n87.【单选】假设神经元的输入值为（1,2,3），对应的权重为4,5,6，神经元经过一个线性函数y=2x，最终的输出结果是多少（  ）\n\n\tA. 64\n\tB. 32\n\tC. 48\n\tD. 96\n\n\n正确答案：A\n\n88.【单选】我们在训练神经网络过程中，使用梯度下降法不断更新哪种数值，进而使得损失函数最小化?（）\n\n\tA. 样本数目\n\tB. 特征值\n\tC. 参数\n\tD. 超参数\n\n\n正确答案：C\n\n89.【单选】神经元的网络计算公式中，各参数代表的含义错误的是（）\n\n\n    \n    \n        \n    \n    \n\n\n\tA. b 为偏置值\n\tB. z 为真实结果\n\tC. x 为输入\n\tD. w 为权重\n\n\n正确答案：B\n\n90.【单选】在神经网络中，我们是通过以下哪个方法在训练网络的时候更新参数，从而最小化损失函数的?\n\n\tA. 反向传播算法\n\tB. 池化计算\n\tC. 正向传播算法\n\tD. 卷积计算\n\n\n正确答案：A\n\n91.【单选】优化器是训练神经网络的重要组成部分，使用优化器的目的不包含以下哪项\n\n\tA. 加快算法收敛速度\n\tB. 避过局部极值\n\tC. 减少手工参数的设置难度\n\tD. 避过过拟合问题\n\n\n正确答案：D\n\n92.【单选】神经网络最基本的结构不包括（）\n\n\tA. 隐藏层\n\tB. 输出层\n\tC. 输入层\n\tD. 激活层\n\n\n正确答案：D\n\n93.【单选】DNN的全称是（）\n\n\tA. 动态神经网络\n\tB. 深度学习网络\n\tC. 动态学习网络\n\tD. 深度神经网络\n\n\n正确答案：D\n\n94.【单选】下列有关全连接网络说法正确的是（  ）：\n\n\tA. 每个神经元具有激活函数功能\n\tB. 神经元之间不存在跨层连接\n\tC. 以上都正确\n\tD. 每一个神经元与下一层的神经元完全连接\n\n\n正确答案：C\n\n95.【单选】下列有关张量和和变量的说法正确的是（  ）\n\n\tA. 张量可以简单理解为多维度数组\n\tB. 在TensorFlow中所有的数据都是通过张量的形式表示“\n\tC. 变量是一种特殊的张量\n\tD. 以上都是\n\n\n正确答案：D\n\n96.【单选】TensorFlow的说法哪些是正确的（  ）\n\nA  TensorFlow是由谷歌在2015年年底推出的一款开源框架\n\nB  TensorFlow是基于DistDelief进行研发的第二代人工智能系统，用来快速实现深度学习（DL）和卷积神经网络（CNN）等各种算法\n\nC  TensorFlow名字描述了执行的原理：Tensor（张量）意味着N维数组，Flow（流）意味着基于数据流图的计算\n\nD  以上都是\n\n\tA. A\n\tB. D\n\tC. B\n\tD. C\n\n\n正确答案：B\n\n97.【单选】深度学习与机器学习算法之间的区别在于，深度学习过程中无需进行特征提取工作，也就是说，我们建议在进行深度学习过程之前要首先完成特征提取的工作。这种说法是（  ）\n\n\tA. 正确的\n\tB. 错误的\n\n\n正确答案：B\n\n98.【单选】有关数据的流向机制描述正确的是（  ）\n\n\tA. 注入机制是feed，取出机制是fetch\n\tB. 取出机制，即向模式中输入数据\n\tC. 注入机制，即从模式中得到结果\n\tD. 注入机制是fetch，取出机制是feed\n\n\n正确答案：A\n\n99.【单选】有关“图”描述错误的是（  ）\n\n\tA. “图”会在会话中被启动\n\tB. 使用Graph函数生成新的计算图\n\tC. 一个“图”代表一个或多个计算任务\n\tD. 不同计算图上的张量和运算不共享\n\n\n正确答案：C\n\n100.【单选】Dropout对一个神经元随机屏蔽输入权重这句话是否正确？（  ）\n\n\tA. 正确的\n\tB. 错误的\n\n\n正确答案：B\n\n101.【单选】当神经网络的调参效果不好时，需要从哪些角度考虑？（ ）\n\n1 是否找到合适的损失函数\n\n2 batch size是否合适\n\n3 是否选择了和是的激活函数\n\n4 是否选择合适的学习率\n\n5 是否过拟合\n\n\tA. 1,3,4,5\n\tB. 1,2,3,4\n\tC. 全部都不是\n\tD. 全部都是\n\n\n正确答案：D\n\n102.【单选】学习率（），会导致待优化的参数在最小值附近波动，不收敛；学习率（），会导致待优化的参数收敛缓慢。\n\n\tA. 过小；过大\n\tB. 过大；过小\n\tC. 过大；过大\n\tD. 过小；过小\n\n\n正确答案：B\n\n103.【单选】学习率会影响待优化的参数的收敛吗？\n\n\tA. 会\n\tB. 不会\n\n\n正确答案：A\n\n104.【单选】在训练神经网络时，损失函数(loss)在最初的几个epochs时没有下降，可能的原因是？（  ）\n\n\n    \n    \n        \n    \n    \n\n\n\tA. 学习率太高\n\tB. 正则参数太高\n\tC. 陷入局部最小值\n\tD. 以上都有可能\n\n\n正确答案：D\n\n105.【单选】下列哪个不是自适应学习率优化器？()\n\n\tA. AdamGrad优化器\n\tB. Adam 优化器\n\tC. 梯度下降优化器\n\tD. RMSDrop优化器\n\n\n正确答案：C\n\n106.【单选】如果我们用了一个过大的学习速率会发生什么？（  ）\n\n\tA. 神经网络会收敛\n\tB. 不好说\n\tC. 都不对\n\tD. 神经网络不会收敛\n\n\n正确答案：D\n\n107.【单选】当训练一个神经网络来作图像识别任务时，通常会绘制一张训练集误差和交叉训练集误差图来进行调试。\n\n\n    \n    \n        \n    \n    \n\n\n在上图中，最好在哪个时间停止训练？（  ）\n\n\tA. A\n\tB. B\n\tC. C\n\tD. D\n\n\n正确答案：C\n\n108.【单选】当数据太大而不能同时在RAM中处理时，哪种梯度技术更有优势？（ ）\n\n\tA. 全批量梯度下降(Full Batch Gradient Descent )\n\tB. 随机梯度下降(Stochastic Gradient Descent)\n\n\n正确答案：B\n\n109.【单选】过拟合和欠拟合的优化不包括以下哪种方法？（）\n\n\tA. Dropout\n\tB. Bagging\n\tC. 梯度下降法\n\tD. 正则化\n\n\n正确答案：C\n\n110.【单选】下列的哪种方法可以用来降低深度学习模型的过拟合问题？（  ）\n\n1 增加更多的数据\n\n2 使用数据扩增技术(data augmentation)\n\n3 使用归纳性更好的架构\n\n4 正规化数据\n\n5 降低架构的复杂度\n\n\tA. 1,4,5\n\tB. 1,2,3\n\tC. 1,3,4,5\n\tD. 所有都可以\n\n\n正确答案：D\n\n111.【单选】在一个神经网络中，下面哪种方法可以用来处理过拟合？（  ）\n\n\tA. dropout\n\tB. 分批归一化\n\tC. 正则化\n\tD. 以上都可以\n\n\n正确答案：D\n\n112.【多选】优化神经网络可以从哪些方面入手？（）\n\n\tA. 学习率的优化\n\tB. 梯度下降的优化\n\tC. 过拟合和欠拟合的优化\n\tD. 梯度的优化\n\n\n正确答案：A,B,C\n\n113.【多选】神经网络中优化方法有（）\n\n\tA. 梯度下降法\n\tB. 随机梯度下降法\n\tC. Adam\n\tD. 随机下降法\n\n\n正确答案：A,B,C\n\n114.【单选】如图所示，当开始训练时，误差一直很高，这是因为神经网络在往全局最小值前进之前一直被卡在局部最小值里。为了避免这种情况，我们可以采取下面哪种策略？（  ）\n\n\n    \n    \n        \n    \n    \n\n\n\tA. 改变学习速率，比如一开始的几个训练周期不断更改学习率速率\n\tB. 一开始将学习速率减小10倍，然后用动量项(momentum)\n\tC. 增加参数数目，这样神经网络就不会卡在局部最优处\n\tD. 以上都不对\n\n\n正确答案：A\n\n115.【单选】在深度学习网络中，反向传播算法用于寻求最优参数，在反向传播算法中使用的什么法则进行逐层求导的?\n\n\tA. 链式法则\n\tB. 累加法则\n\tC. 对等法则\n\tD. 归一法则\n\n\n正确答案：A\n\n116.【单选】前馈神经网络是指网络只能前向传播，不能后向传播，这句话是否正确（  ）\n\n\tA. 正确的\n\tB. 错误的\n\n\n正确答案：B\n\n117.【单选】反向传播算法一开始计算什么内容的梯度，之后将其反向传播？（  ）\n\n\tA. 预测结果与样本标签之间的误差\n\tB. 各个输入样本的平方差之和\n\tC. 各个网络权重的平方差之和\n\tD. 以上都不对\n\n\n正确答案：A\n\n118.【单选】单层的神经网络反向传播算法也适用多层神经网络的反向传播，这句话正确吗？（  ）\n\n\tA. 正确\n\tB. 不正确\n\n\n正确答案：B\n\n119.【单选】一个完成的反向传播的步骤是（  ）\n\n1 将隐藏层误差反向传播给输入层，调节隐藏层到输入层的权值和阈值\n\n2 将输出层的误差反向传播给隐藏层，调整隐藏层到输出层的权值和阈值\n\n3 将隐藏层的误差反向传播给隐藏层，调节隐藏层到隐藏层的权值和阈值\n\n\tA. 1 2 3\n\tB. 2 1 3\n\tC. 1 3 2\n\tD. 2 3 1\n\n\n正确答案：D\n"
} ,
  
  {
    "title"    : "网络爬虫",
    "category" : "",
    "tags"     : " python, 爬虫, 期末考试",
    "url"      : "/crawler",
    "date"     : "June 20, 2023",
    "excerpt"  : "网络爬虫（Web Crawler）是一种自动化程序，它可以在互联网上浏览和收集信息。它们可以发现和抓取网站上的所有内容，包括文本、图片、视频、音频等，并将这些数据保存到数据库或文件中。\n\n\n\n目录\n\n\n  目录\n  前言\n  正文\n    \n      选择题部分\n        \n          1 下列选项中，不能用于解析网页数据的是（）\n          2 下列选项中，用于匹配任意字符数字的是（）\n          3 下列选项中，用于在Xpath中选取属性节点的是（）\n ...",
  "content"  : "网络爬虫（Web Crawler）是一种自动化程序，它可以在互联网上浏览和收集信息。它们可以发现和抓取网站上的所有内容，包括文本、图片、视频、音频等，并将这些数据保存到数据库或文件中。\n\n\n\n目录\n\n\n  目录\n  前言\n  正文\n    \n      选择题部分\n        \n          1 下列选项中，不能用于解析网页数据的是（）\n          2 下列选项中，用于匹配任意字符数字的是（）\n          3 下列选项中，用于在Xpath中选取属性节点的是（）\n          4 列选项中，关于re模块的说法错误的是（）\n          5 下列选项中，关于lxml说法错误的是（）\n          6 下列选项中，关于Selenium描述错误的是（）\n          7 下列选项中，属于Chrome浏览器驱动程序的是（）\n          8 下列选项中，用于根据指定URL地址访问页面的方法是（）\n          9 下列选项中，通过类名定位元素的方法是（）\n          10 下列选项中，关于显式等待和隐式等待描述错误的是（）\n        \n      \n      简答题 \\&amp;amp; 论述题\n        \n          1 什么是网络爬虫？\n            \n              理论定义：\n              分类：\n            \n          \n          2 网页的分类（简答题问法）\n          3 网络爬虫的应用场景有哪些？\n          4 网络爬虫合法性研究\n            \n              4.1论述题的考法\n                \n                  网络爬虫是否合法？\n                  合法合规的爬虫是什么样的？\n                  你认为不合法合规的爬虫是什么样的？\n                \n              \n              4.2简答题的问法\n                \n                  什么是robots.txt协议？\n                \n              \n            \n          \n          5 防爬虫的应对策略有哪些？\n          6 http和https 的区别？\n          7 网页的分类（论述题问法）\n            \n              7.1静态网页，动态网页是什么？\n              7.2静态网页的特点\n              7.3动态网页的特点\n              7.4动态网页采集技术类型有哪些？你最喜欢用哪一个\n            \n          \n        \n      \n      综合应用题\n        \n          1 Scrapy-Redis架构\n          2 scrapy.Spider类的常用属性和方法\n        \n      \n      程序题部分\n        \n          程序填空\n          程序解释题\n        \n      \n    \n  \n\n\n\n\n前言\n\n  本博客针对，网络爬虫期末考试进行整理。部分整理针对题型进行整理。祝你取得一个好成绩！。\n\n\n\n正文\n\n选择题部分\n\n\n  针对平时测试所整理，有概率考到\n\n\n1 下列选项中，不能用于解析网页数据的是（）\n\nA. LXML     \nB. Beautiful Soup  \nC. JSONPath   \nD. Requests\n\n\n  正确答案：D\n\n2 下列选项中，用于匹配任意字符数字的是（）\n\nA. \\w    \nB. \\d   \nC. \\D    \nD. \\W\n\n\n  正确答案：B\n\n3 下列选项中，用于在Xpath中选取属性节点的是（）\n\nA. /     \nB. //    \nC. @   \nD. #\n\n\n  正确答案：C\n\n4 列选项中，关于re模块的说法错误的是（）\n\nA. re模块是Python中可操作正则表达式的模块\nB. re模块中的compile( )函数用于对正则表达式进行编译\nC. 使用findall( )方法或finditer( )方法可以获取所有与正则表达式匹配的内容\nD. 使用finditer( )方法返回的是列表，使用findall( )方法返回的是迭代器\n\n\n  正确答案：D\n\n5 下列选项中，关于lxml说法错误的是（）\n\nA. Element类的find( )方法用于从根节点开始查找，并以列表形式返回匹配的节点\nB. 使用lxml库可以对HTML文档或XML文档中的节点进行定位和提取\nC. ElementTree类的对象可以理解为HTML文档或XML文档的树节点\nD. 使用lxml库可以对HTML文档缺少的&amp;lt;html&amp;gt;和&amp;lt;body&amp;gt;元素自动补全\n\n\n  正确答案：D\n\n6 下列选项中，关于Selenium描述错误的是（）\n\nA. Selenium是一个开源的便携式自动化测试工具\nB. Selenium可以直接在浏览器上运行\nC. Selenium自身携带浏览器，并支持浏览器的功能\nD. Selenium可以根据指令自动加载网页或判断网页上是否发生动作\n\n\n  正确答案：C\n\n7 下列选项中，属于Chrome浏览器驱动程序的是（）\n\nA. ChromeDriver\nB. geckodriver\nC. operachromiumdriver\nD. IEDriverServer\n\n\n  正确答案：A\n\n8 下列选项中，用于根据指定URL地址访问页面的方法是（）\n\nA. get()\nB. Post()\nC. head()\nD. put()\n\n\n  正确答案：A\n\n9 下列选项中，通过类名定位元素的方法是（）\n\nA. find_element_by_name()\nB. find_element_by_class_name()\nC. find_element_by_id()\nD. find_element_by_tag_name()\n\n\n  正确答案：B\n\n10 下列选项中，关于显式等待和隐式等待描述错误的是（）\n\nA. 隐式等待就是设置一个全局的最大等待时间\nB. 显式等待会先指定某个条件，再设置最长等待时间\nC. 隐式等待可作用于单个元素\nD. 显式等待只能作用于单个元素\n\n\n  正确答案：C\n\n\n\n简答题 &amp;amp; 论述题\n\n1 什么是网络爬虫？\n\n本题考察简答题 5&#39;\n\n\n理论定义：\n\n  网络爬虫就是一个模拟真人浏览万维网行为的程序，这个程序可以代替真人自动请求万维网，并接收从万维网返回的数据。与真人浏览万维网相比，网络爬虫能够浏览的信息量更大，效率也更高。（重点）\n\n分类：\n\n  通用网络爬虫、聚焦网络爬虫、增量式网络爬虫、深层网络爬虫。\n\n  通用网络爬虫:是指访问全互联网资源的网络爬虫。它是搜索引擎（如百度、谷歌、雅虎等）抓取系统的重要组成部分，主要用于将互联网中的网页下载到本地，形成一个互联网内容的镜像备份。（重点）\n\n  聚焦网络爬虫:是指有选择性地访问那些与预定主题相关网页的网络爬虫，它根据预先定义好的目标，有选择性地访问与目标主题相关的网页，获取所需要的数据。\n\n  增量式网络爬虫:是指对已下载的网页采取增量式更新，只抓取新产生或者已经发生变化的网页的网络爬虫。\n\n  深层网络爬虫:是指抓取深层网页的网络爬虫，它要抓取的网页层次比较深，需要通过一定的附加策略才能够自动抓取，实现难度较大。\n\n\n\n2 网页的分类（简答题问法）\n\n本题考察简答题 5&#39;\n\n\n  主要分为表层网页，深层网页。\n\n  表层网页是指传统搜索引擎可以索引的页面，主要以超链接可以到达的静态网页构成的网页。\n  深层网页是指大部分内容无法通过静态链接获取的，只能通过用户提交一些关键词才能获取的网页，如用户注册后内容才可见的网页。\n\n\n\n3 网络爬虫的应用场景有哪些？\n\n本题考察简答题 5&#39;\n\n\n  搜索引擎、舆情分析与监测、聚合平台、出行类软件等。\n\n  搜索引擎：如百度、谷歌、雅虎等。\n\n  舆情分析与监测：例如用于过滤敏感词汇。发掘舆情热点，跟踪目标话题。\n\n  运用网络爬虫技术对一些电商平台上的商品信息进行采集，将所有的商品信息放到自己的平台上展示，并提供横向数据的比较。\n\n  出行类软件，比如飞猪、携程、去哪儿等，也是网络爬虫应用比较多的场景。\n\n\n\n4 网络爬虫合法性研究\n\n本题考察简答题 5&#39; &amp;amp; 论述题 16&#39;\n\n\n4.1论述题的考法\n\n网络爬虫是否合法？\n  （1）爬虫本身不违法。\n  （2）如果爬虫程序采集到会侵犯到有关公民信息，以及商业机密等内容，并将之用于非法途径的，则肯定构成非法获取公民个人信息的违法行为。\n  （3）部分公司提供公开API接口允许爬取其数据。爬取这样的数据并不违法。\n  （4）网络爬虫在遵守法律政策和网站协议的情况下是合法的。\n\n合法合规的爬虫是什么样的？\n\n  （1）遵守robots.txt协议\n  （2）不断请求而不会影响网站的正常运行\n  （3）不获取敏感信息\n  （4）不会对目标网站造成安全隐患\n  （5）网站公开数据允许收集\n  （6）爬虫有明确用户使用场景\n\n你认为不合法合规的爬虫是什么样的？\n\n  （1）爬取未公开、未经许可、且带有敏感信息的数据。\n  （2）使用技术手段不克制，造成提供信息的平台的服务资源损失。\n  （3）出售个人信息，将爬取的信息用在了不正当商业行为中。\n  （4）不遵循数据许可协议，超出约定的使用。\n  （5）无限制地抓取网页。\n  （6）使用爬虫，模拟用户行为欺瞒网站。\n\n4.2简答题的问法\n\n什么是robots.txt协议？\n\n  Robots协议又称爬虫协议，它是国际互联网界通行的道德规范，用于保护网站数据和信息不受侵犯。网站管理员通常会在网页根目录下放置一个符合Robots协议的robots.txt文件，用于告知哪些数据允许爬取，哪些数据不允许爬取。\n\n\n\n5 防爬虫的应对策略有哪些？\n\n  添加User-Agent字段、降低访问频率、设置代理服务、识别验证码。\n\n  1. 添加User-Agent字段:浏览器在访问网站时会携带固定的User-Agent，向网站表明自己的真实身份。所以可以在请求网页时携带User-Agent，将自己伪装成一个浏览器。\n\n  2. 降低访问频率:同一账户在较短的时间内多次访问了网页可能会被封禁。所以可以每抓取一次页面数据就休息几秒钟，或者限制每天抓取的页面数据的数量。\n\n  3. 设置代理服务:反复使用同一IP地址进行访问，则极易被网站认出是爬虫。所以可以在网络爬虫和Web服务器之间设置代理服务器。\n\n  4. 识别验证码:有些网站可能会要求该客户端进行登录验证，并随机提供一个验证码，为了应对这种发情况可以将爬虫像人类一样通过滑动或点击行为识别验证码。\n\n\n\n6 http和https 的区别？\n\n本题考察简答题 5&#39;\n\n\n  HTTP协议全称为超文本传输协议，它用于将Web服务器的超文本资源传送到浏览器中。\n\n  HTTPS协议是一种超文本传输安全协议。\n\n  两者的不同：\n  HTTP中浏览器与Web服务器的连接是一种一次性连接，它限制每次连接只能处理一个请求。\n  HTTPS在HTTP协议基础上添加了安全套接字协议，完成互联网数据传输加密，实现互联网传输安全保护。\n\n\n\n7 网页的分类（论述题问法）\n\n本题考察论述题 16&#39;\n\n\n7.1静态网页，动态网页是什么？\n\n  静态网页中包含的诸如文本、图像、FLASH动画、超链接等内容，在编写网页源代码时已经确定，基本上不会发生变化，除非更改源码。\n\n  动态网页有数据库支撑、包含程序以及提供与用户交互功能，如用户登录、用户注册、信息查询等功能，这些功能根据用户传入不同参数网页会显示不同数据。\n\n7.2静态网页的特点\n\n  1. 静态网页的内容相对稳定，一经上传至网站服务器，无论是否有用户访问内容都会一直保存在网站服务器上。\n  2. 静态网页的访问速度快，访问过程中无须连接数据库。\n  3. 静态网页没有数据库的支持，内容更新与维护比较复杂。\n  4. 静态网页的交互性较差，在功能方面有较大的限制。\n\n7.3动态网页的特点\n\n  1. 动态网页一般以数据库技术为基础。\n  2. 动态网页并不是独立存在于服务器上的网页文件，只有当用户请求时服务器才会返回一个完整的网页。\n  3. 采用动态网页技术的网站可以实现更多的功能，如用户注册、用户登录、在线调查、用户管理、订单管理等。\n\n7.4动态网页采集技术类型有哪些？你最喜欢用哪一个\n\n  1. 基于浏览器自动化工具（如Selenium）的采集技术。\n  2. 基于HTML请求模拟采集技术。\n  3. 基于无界面浏览器的采集技术。\n  4. 基于API接口调用的采集技术。\n\n  我最喜欢用浏览器自动化工具Selenium，因为使用Selenium，对于动态网页的数据可以直接使用模拟浏览器运行的方式进行实现，这样做就可以不用管网页内部是如何使用JavaScript渲染页面的，在浏览器中看到是什么样的内容，抓取的结果便是什么样的内容。\n\n\n\n综合应用题\n\n\n  本题型一张试卷只有一题，16分，一题分多个小点\n\n\n1 Scrapy-Redis架构\n\n  绘制以下一张完整的图像。统一要求对关键名称写中文。\n\n\n    \n    \n        \n    \n    \n\n\n  注意这里A卷中，与画图题一起考的还有一个多选题，请排除第二个选项\n\n\n\n2 scrapy.Spider类的常用属性和方法\n\n  1. name属性：设置爬虫文件的名称。\n  2. allowed_domains属性：设置爬虫允许抓取的域名范围。\n  3. start_urls属性：表示需要提交的初始URL地址。\n  4. init()方法：负责初始化爬虫名称和初始URL列表。\n  5. start_requests()方法：负责生成Requests对象，交给Scrapy下载。\n  6. parse(response)方法：负责解析Response，并返回Item或Requests。\n  7. log(message[level, component])方法：负责发送日志信息。\n\n这个大题下面有关知识点的整理（不用背）（会考多选题和判断题）：\n\n  该文件中可以定义多个管道，这些管道会按照定义的顺序依次处理Item对象。（✔）\n\n  CrawlSpider类由于继承了Spider类，所以继承了Spider类的所有公有成员。此外，CrawlSpider类自身也定义了一些属性。在这里，我们着重了解一下rules属性。rules属性是一个包含一个或多个Rule对象给续会介绍的列表。每个Rule对象对抓取网站的动作定义了特定表现。如果多个Rule对象匹配了同一个链接，则根据它们在本属性中定义的顺序，使用第一个Rule对象。\n\n\n\n程序题部分\n\n程序填空\n\n以下代码要求掌握，共计13点\n\n  text = etree.HTML(html)\n\n\n  # 文章标题\n  title = node.xpath(&#39;./a[1]/text()&#39;)[0]\n  # 文章链接\n  url = node.xpath(&#39;./a[1]/@href&#39;)[0]\n  # 文章作者\n  author = node.xpath(&#39;./div[@class=&quot;foruminfo&quot;]//a/span/text()&#39;)[0]\n\n\n  item = {\n    &quot;文章标题&quot;: title,\n    &quot;文章链接&quot;: url,\n    &quot;文章作者&quot;: author,\n    &#39;发布时间&#39;: release_time,\n  }\n  items.append(item)\n\n\n  options = webdriver.ChromeOptions()\n\n\n  # text属性 : 获取当前dd节点以及它的子节点和后代节点的文本内容\n  one_film_info_list = dd.text.split(&#39;\\n&#39;)\n\n\n  item[&#39;name&#39;] = one_film_info_list[1].strip()\n  item[&#39;star&#39;] = one_film_info_list[2].strip()\n  item[&#39;time&#39;] = one_film_info_list[3].strip()\n  item[&#39;score&#39;] = one_film_info_list[4].strip()\n\n\n  def get_html(self, url):\n    html = requests.get(url=url, headers=self.headers).text\n\n\n  p = etree.HTML(html)\n\n\n  item[&#39;name&#39;] = dd.xpath(&#39;.//p[@class=&quot;name&quot;]/a/@title&#39;)[0].strip()\n  item[&#39;star&#39;] = dd.xpath(&#39;.//p[@class=&quot;star&quot;]/text()&#39;)[0].strip()\n  item[&#39;time&#39;] = dd.xpath(&#39;.//p[@class=&quot;releasetime&quot;]/text()&#39;)[0].strip()\n\n\n  item[&#39;score&#39;] = &#39;&#39;.join(dd.xpath(&#39;.//p[@class=&quot;score&quot;]/i/text()&#39;))\n\n\n  name = &#39;itcast&#39;\t\t# 这个是试卷上会给的\n  allowed_domains = [&#39;itcast.cn&#39;]\n\n\n  # 创建MyspiderItem类的对象\n  item = MyspiderItem()\n\n\n  # 将每个讲师的信息封装成MyspiderItem类的对象\n  item[&quot;name&quot;] = name[0]\n  item[&quot;level&quot;] = level[0] 在浏览器中看到是什么样的内容，抓取的结果便是什么样的内容\n  item[&quot;resume&quot;] = resume[0]\n  items.append(item)\n\n\n\n\n程序解释题\n\n这里可能会有干扰项\n\n  以下为我个人作答并不一定是参考答案\n\n\ndef load_page(url):\n    &#39;&#39;&#39;\n    作用:根据url发送请求，获取服务器响应文件\n    url：需要爬取的url地址\n    &#39;&#39;&#39;\n    headers = {&quot;User-Agent&quot;: &quot;Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident / 5.0;&quot;}\n    request = requests.get(url, headers=headers)\n    return request.text\n\n\n答：根据url，封装请求头，使用get方法发送请求。获取服务器响应文件，并返回文件内容。\n\n\n\n  print(&quot;正在保存&quot; + filename)\n  with open(filename, &#39;w&#39;, encoding=&#39;utf-8&#39;) as file:\n    file.write(html)\n\n\n答：以打印需要保存的文件名信息；将以读的形式打开（如果不存在就创建）文件，并写入对应的内容\n\n\n\n  url = f&#39;http://bbs.itheima.com/forum-425-{page}.html&#39;\n  file_name = &quot;第&quot; + str(page) + &quot;页.html&quot;\n  html = load_page(url)\n  save_file(html, file_name)\n\n\n答：获取page信息，拼接url；给获取到的url命名为“第”+page+“页.html”；传递url参数，调用load_page函数获取网页信息，调用save_file函数保存获取到的信息。\n\n\n\n  html = json.loads(response.text)\n  count = html[&#39;Data&#39;][&#39;Count&#39;]\n  total = count // 10 if count % 10 == 0 else count // 10 + 1\n\n\n答：json.loads是将响应内容中的json数据转为字典；count是从字典中获取职位总条数，total是计算得到的所要获取的页数。\n\n\n\ndef detail_page(self, response):\n    &quot;&quot;&quot;一级页面解析函数：提取每页中10个职位的postid&quot;&quot;&quot;\n    one_html = json.loads(response.text)\n    for one_job_dict in one_html[&#39;Data&#39;][&#39;Posts&#39;]:\n      post_id = one_job_dict[&#39;PostId&#39;]\n      # 拼接二级页面URL地址,再次交给调度器入队列\n      two_url = &#39;https://careers.tencent.com/tencentcareer/api/post/ByPostId?timestamp=1593656158948&amp;amp;postId={}&amp;amp;language=zh-cn&#39;.format(post_id)\n      yield scrapy.Request(url=two_url, callback=self.get_job_info)   #将所有的信息交给自定义函数self.get_job_info处理\n\n\n\n答：two_url拼接二级页面URL地址,再次交给调度器入队列；yield scrapy.Request将所有的信息交给自定义函数self.get_job_info处理\n\n\n\ndef get_job_info(self, response):\n  &quot;&quot;&quot;提取每个职位的具体信息&quot;&quot;&quot;\n  two_html = json.loads(response.text)\n  item = TencentItem()\n  item[&#39;job_name&#39;] = two_html[&#39;Data&#39;][&#39;RecruitPostName&#39;]\n  item[&#39;job_address&#39;] = two_html[&#39;Data&#39;][&#39;LocationName&#39;]\n  item[&#39;job_type&#39;] = two_html[&#39;Data&#39;][&#39;CategoryName&#39;]\n  item[&#39;job_time&#39;] = two_html[&#39;Data&#39;][&#39;LastUpdateTime&#39;]\n  item[&#39;job_responsibility&#39;] = two_html[&#39;Data&#39;][&#39;Responsibility&#39;]\n  item[&#39;job_requirement&#39;] = two_html[&#39;Data&#39;][&#39;Requirement&#39;]\n\n  # 至此,一个职位完整信息抓取完成,交给管道文件处理\n  yield item\n\n\n答：调用json.loads方法提取每个职位的具体信息；yield item至此,一个职位完整信息抓取完成,交给管道文件处理。\n\n\n\ndriver = webdriver.Chrome()   # 创建一个浏览器对象，并打开\ndriver.maximize_window()    # 最大化窗口\ndriver.get(url=&#39;https://mail.qq.com/&#39;)  # 调用get方法发起请求\n\ndriver.switch_to.frame(&#39;login_frame&#39;)# 切换iframe子页面\n\n\n# 2、用户名、密码、登录\ndriver.find_element_by_id(&#39;u&#39;).send_keys(&#39;2621470058&#39;)  # 这个不用管\ndriver.find_element_by_id(&#39;p&#39;).send_keys(&#39;zhanshen001&#39;) # 这个不用管\ndriver.find_element_by_id(&#39;login_button&#39;).click()   # 查找登录按钮的位置，并调用click方法单击此按钮。\n\n\n以上注解已写在程序当中\n"
} ,
  
  {
    "title"    : "毛概期末整理",
    "category" : "",
    "tags"     : " 毛概, 期末考试",
    "url"      : "/maogai",
    "date"     : "June 11, 2023",
    "excerpt"  : "  毛概是毛泽东思想和中国特色社会主义理论体系概论的简称。学习毛概有利于刚进入大学的学生思想的转变，更好的完成大学期间学习任务，提高大学生自我素质，增加应对现实中各种挑战的能力，尽快适应新的学习生活环境，完成大学期间的各项发展任务，成为社会发展的有用之才。\n\n\n\n前言\n  本次博客整理，针对毛概期末考试，知识点较多，请提前准备。\n  其中选择题部分可以在，学习通中找到对应的答案。本博客也对此作出整理\n\n\n\n目录\n\n\n  前言\n  目录\n  正文\n    \n      选择题\n       ...",
  "content"  : "  毛概是毛泽东思想和中国特色社会主义理论体系概论的简称。学习毛概有利于刚进入大学的学生思想的转变，更好的完成大学期间学习任务，提高大学生自我素质，增加应对现实中各种挑战的能力，尽快适应新的学习生活环境，完成大学期间的各项发展任务，成为社会发展的有用之才。\n\n\n\n前言\n  本次博客整理，针对毛概期末考试，知识点较多，请提前准备。\n  其中选择题部分可以在，学习通中找到对应的答案。本博客也对此作出整理\n\n\n\n目录\n\n\n  前言\n  目录\n  正文\n    \n      选择题\n        \n          导论部分\n          第一章\n          第二章\n          第三章\n          第四章\n          第五章\n          第六章\n          第七章\n          第八章\n          新思想第一章\n          新思想第二章\n          新思想第三章\n          新思想第四章\n          新思想第五章\n          新思想第六章\n        \n      \n      大题部分\n        \n          1.马克思主义中国化时代化的科学内涵及其三层意思※\n          2 马克思主义中国化时代化的原因※\n          3 马克思主义中国化时代化的理论成果及其关系※\n          4 近代中国社会的性质、主要矛盾※\n          5 过渡时期社会的性质、经济成分、阶级构成和主要矛盾※\n          6 社会主义改造的历史经验※\n          7 社会主义改造完成后社会主要矛盾※\n          8 社会主义建设道路初步探索的意义和经验教训※\n          9 中国特色社会主义进入新时代的社会主要矛盾※\n          10 邓小平理论首要的基本的理论问题和精髓※\n          11 4.\t社会主义的本质※\n          12 “三个代表”重要思想回答的重大问题和核心观点及其关系※\n          13 科学发展观回答的重大问题和科学内涵※\n          14 习近平新时代中国特色社会主义思想回答的重大时代课题※\n          15 习近平新时代中国特色社会主义思想的历史地位※\n          16 中国式现代化的内涵、中国特色和本质要求※\n          17 新发展格局的内涵，构建新发展格局的意义和重点任务※\n        \n      \n    \n  \n\n\n\n正文\n\n选择题\n\n导论部分\n1\n【单选题】马克思主义中国化的第一个理论成果是（ ）。\n\nA、毛泽东思想\nB、邓小平理论\nC、“三个代表”重要思想\nD、科学发展观\n\n\n正确答案： A\n\n2\n【单选题】马克思主义中国化的命题是（ ）提出的。\n\nA、马克思\nB、列宁\nC、毛泽东\nD、邓小平\n\n\n正确答案： C\n\n3\n【单选题】在毛泽东思想的指导下，党领导人民完成了新民主主义革命，建立了中华人民共和国，中华民族从此（ ）了。\n\nA、站起来\nB、富起来\nC、强起来\nD、大起来\n\n\n正确答案： A\n\n4\n【单选题】100年来，中国共产党团结带领中国人民进行的一切奋斗、一切牺牲、一切创造，归结起来就是一个主题（ ）。\n\nA、实现民族独立、人民解放\nB、实现中华民族伟大复兴\nC、实现现代化\nD、实现共同富裕\n\n\n正确答案： B\n\n5\n【单选题】马克思主义中国化最新成果是（ ）。\n\nA、邓小平理论\nB、“三个代表”重要思想\nC、科学发展观\nD、习近平新时代中国特色社会主义思想\n\n\n正确答案： D\n\n1\n【多选题】马克思主义中国化的原因包括（ ）。\n\nA、解决中国实际问题的客观需要\nB、马克思主义理论发展的内在要求\nC、马克思主义理论提供了解决中国问题的现成答案\nD、马克思主义只能在中国发展\n\n\n正确答案： AB\n\n2\n【多选题】马克思主义中国化的两大理论成果是（ ）。\n\nA、毛泽东思想\nB、邓小平理论\nC、中国特色社会主义理论体系\nD、习近平新时代中国特色社会主义思想\n\n\n正确答案： AC\n\n3\n【多选题】中国特色社会主义理论体系包括（ ）。\n\nA、邓小平理论\nB、“三个代表”重要思想\nC、科学发展观\nD、习近平新时代中国特色社会主义思想\n\n\n正确答案： ABCD\n\n4\n【多选题】中国共产党百年创造的伟大成就是（ ）。\n\nA、创造了新民主主义革命的伟大成就\nB、创造了社会主义革命和建设的伟大成就\nC、创造了改革开放和社会主义现代化建设的伟大成就\nD、创造了新时代中国特色社会主义的伟大成就\n\n\n正确答案： ABCD\n\n5\n【多选题】学习本课程的目的是（ ）。\n\nA、准确把握马克思主义中国化进程中形成的理论成果\nB、深刻认识中国共产党领导人民进行的革命、建设、改革的历史进程、历史变革、历史成就\nC、透彻理解中国共产党在新时代坚持的基本理论、基本路线、基本方略\nD、切实提升运用马克思主义立场、观点和方法认识问题、分析问题和解决问题能力\n\n\n正确答案： ABCD\n\n\n\n第一章\n\n1\n【单选题】毛泽东思想形成的时代背景是（ ）。\n\nA、和平与发展\nB、战争与革命\nC、改革开放\nD、信息革命\n\n\n正确答案： B\n\n2\n【单选题】毛泽东思想形成的实践基础是（ ）。\n\nA、党领导的革命和建设的实践\nB、党领导的改革开放\nC、党领导的新民主主义革命\nD、党领导的社会主义建设\n\n\n正确答案： A\n\n3\n【单选题】把毛泽东思想确立为党的指导思想并写入党章是在（ ）。\n\nA、中共六大\nB、中共七大\nC、中共八大\nD、中共九大\n\n\n正确答案： B\n\n4\n【单选题】毛泽东思想围绕的主题是（ ）。\n\nA、中国革命和建设\nB、中国改革开放\nC、中国特色社会主义建设\nD、中华民族伟大复兴\n\n\n正确答案： A\n\n5\n【单选题】党的根本工作路线是（ ）。\n\nA、实事求是\nB、群众路线\nC、独立自主\nD、为人民服务\n\n\n正确答案： B\n\n1\n【多选题】毛泽东思想是（ ）。\n\nA、马克思主义中国化的第一个理论成果\nB、马克思列宁主义在中国的运用和发展\nC、关于中国革命和建设的正确理论原则和经验总结\nD、中国共产党集体智慧的结晶\n\n\n正确答案： ABCD\n\n2\n【多选题】毛泽东思想的主要内容包括新民主主义革命理论、社会主义革命和社会主义建设理论，还有（ ）。\n\nA、革命军队建设和军事战略的理论\nB、政策和策略的理论\nC、思想政治工作和文化工作的理论\nD、党的建设理论\n\n\n正确答案： ABCD\n\n3\n【多选题】毛泽东的哲学著作有（ ）。\n\nA、《反对本本主义》\nB、《实践论》\nC、《矛盾论》\nD、《人的正确思想是从哪里来的？》\n\n\n正确答案： ABCD\n\n4\n【多选题】毛泽东思想活的灵魂包括（ ）。\n\nA、实事求是\nB、群众路线\nC、独立自主\nD、与时俱进\n\n\n正确答案： ABC\n\n5\n【多选题】关于毛泽东的评价正确的是（ ）。\n\nA、毛泽东是伟大的马克思主义者，伟大的无产阶级革命家、战略家和理论家\nB、毛泽东晚年犯了严重错误，他的错误是第一位的，功绩是第二位的\nC、他为中国共产党和中国人民解放军的创立和发展做出了不可磨灭的贡献\nD、他对中国革命的功绩远远大于他的过失\n\n\n正确答案： ACD\n\n\n\n第二章\n\n1\n【单选题】新民主主义革命的性质是（ ）。\n\nA、无产阶级社会主义革命\nB、资产阶级民主主义革命\nC、农民革命\nD、土地革命\n\n\n正确答案： B\n\n2\n【单选题】新民主主义国家的国体是（ ）。\n\nA、资产阶级专政\nB、无产阶级专政\nC、人民民主专政\nD、各革命阶级联合专政\n\n\n正确答案： D\n\n3\n【单选题】近代中国革命斗争的主要形式是（ ）。\n\nA、工人罢工\nB、商人罢市\nC、学生罢课\nD、武装斗争\n\n\n正确答案： D\n\n4\n【单选题】新民主主义革命时期加强党的建设，必须把（ ）放在首位。\n\nA、思想建设\nB、组织建设\nC、作风建设\nD、制度建设\n\n\n正确答案： A\n\n5\n【单选题】新民主主义革命的道路是（ ）。\n\nA、城市包围农村，武装夺取政权\nB、农村包围城市，武装夺取政权\nC、城市包围农村，和平夺取政权\nD、农村包围城市，和平夺取政权\n\n\n正确答案： B\n\n1\n【多选题】新民主主义革命的对象包括（ ）。\n\nA、帝国主义\nB、封建主义\nC、民族资本主义\nD、官僚资本主义\n\n\n正确答案： ABD\n\n2\n【多选题】新民主主义革命的动力包括（ ）。\n\nA、无产阶级\nB、农民阶级\nC、城市小资产阶级\nD、民族资产阶级\n\n\n正确答案： ABCD\n\n3\n【多选题】近代中国无产阶级的特殊优点有（ ）。\n\nA、富于组织纪律性\nB、革命最坚决最彻底\nC、分布集中，便于组织和团结\nD、和农民有天然联系，便于结成工农联盟\n\n\n正确答案： BCD\n\n4\n【多选题】新民主主义的经济纲领是（ ）。\n\nA、没收封建地主阶级的土地归农民所有\nB、没收官僚资产阶级的垄断资本归新民主主义的国家所有\nC、没收民族工商业\nD、保护民族工商业\n\n\n正确答案： ABD\n\n5\n【多选题】新民主主义革命的三大法宝是（ ）。\n\nA、统一战线\nB、武装斗争\nC、党的建设\nD、土地革命\n\n\n正确答案： ABC\n\n\n\n第三章\n\n1\n【单选题】过渡时期我国社会的性质是（ ）。\n\nA、半殖民地半封建社会\nB、新民主主义社会\nC、资本主义社会\nD、社会主义社会\n\n\n正确答案： B\n\n2\n【单选题】新民主主义社会的主要矛盾是（ ）。\n\nA、地主阶级和农民阶级矛盾\nB、资产阶级和无产阶级矛盾\nC、无产阶级和小资产阶级矛盾\nD、农民阶级和小资产阶级矛盾\n\n\n正确答案： B\n\n3\n【单选题】中国共产党在过渡时期总路线的主体是（ ）。\n\nA、实现国家的社会主义工业化\nB、实现国家对农业的社会主义改造\nC、实现国家对手工业的社会主义改造\nD、实现国家对资本主义工商业的社会主义改造\n\n\n正确答案： A\n\n4\n【单选题】我国农业社会主义改造的道路是（ ）。\n\nA、直接没收\nB、和平赎买\nC、互助合作\nD、自愿上交\n\n\n正确答案： C\n\n5\n【单选题】社会主义制度在中国确立的标志是（ ）。\n\nA、1949年新中国成立\nB、1952年民主革命任务完成\nC、1954年《中华人民共和国宪法》颁布\nD、1956年底社会主义改造基本完成\n\n\n正确答案： D\n\n1\n【多选题】新民主主义社会的阶级构成是（ ）。\n\nA、工人阶级\nB、农民阶级\nC、小资产阶级\nD、民族资产阶级\n\n\n正确答案： ABCD\n\n2\n【多选题】我国农业社会主义改造步骤有（ ）。\n\nA、农业生产互助组\nB、初级农业生产合作社\nC、高级农业生产合作社\nD、社会主义集体农庄\n\n\n正确答案： ABC\n\n3\n【多选题】我国能够采取赎买的方式对资本主义工商业进行和平改造的原因有（ ）。\n\nA、在社会主义革命阶段，民族资产阶级既有剥削工人取得利润的一面，又有拥护宪法、愿意接受社会主义改造的一面\nB、中国共产党与民族资产阶级长期保持着统一战线的关系\nC、我国已经有了以工人阶级为领导、工农联盟为基础的人民民主专政的国家政权\nD、建立了强大的社会主义国营经济并掌握了国家的经济命脉\n\n\n正确答案： ABCD\n\n4\n【多选题】我国社会主义改造的历史经验有（ ）。\n\nA、社会主义工业化建设与社会主义改造同时并举\nB、采取积极引导、逐步过渡的方式\nC、用和平方法进行改造\nD、走互助合作的道路\n\n\n正确答案： ABC\n\n5\n【多选题】1956年底，我国社会主义改造基本完成，标志着（ ）。\n\nA、社会主义制度在我国已经确立\nB、我国进入了社会主义初级阶段\nC、我国步入了社会主义改革时期\nD、我国实现了新民主主义向社会主义过渡\n\n\n正确答案： ABD\n\n\n\n第四章\n1\n【单选题】毛泽东在《论十大关系》中提出社会主义建设的基本方针是（ ）。\n\nA、多快好省地建设社会主义\nB、以经济建设为中心\nC、以阶级斗争为纲\nD、调动一切积极因素为社会主义事业服务\n\n\n正确答案：D\n\n2\n【单选题】我国社会主义社会基本矛盾性质是（ ）。\n\nA、对抗性的矛盾\nB、非对抗性的矛盾\nC、适应性的矛盾\nD、非适应性的矛盾\n\n\n正确答案：B\n\n3\n【单选题】毛泽东指出，解决人民内部矛盾的方法是（ ）。\n\nA、民主方法\nB、专政方法\nC、法律制裁方法\nD、劳动改造方法\n\n\n正确答案：A\n\n4\n【单选题】毛泽东强调，社会主义国家政治生活的主题是（ ）。\n\nA、阶级斗争\nB、革命\nC、正确处理人民内部矛盾\nD、经济建设\n\n\n正确答案：C\n\n5\n【单选题】中国共产党强调，我国实现四个现代化关键在于（ ）。\n\nA、农业现代化\nB、工业现代化\nC、国防现代化\nD、科学技术现代化\n\n\n正确答案：D\n\n1\n【多选题】我国社会主义社会存在两类不同性质矛盾是指（ ）。\n\nA、主要矛盾\nB、基本矛盾\nC、敌我矛盾\nD、人民内部矛盾\n\n\n正确答案：CD\n\n2\n【多选题】处理人民内部矛盾的民主方法有（ ）。\n\nA、讨论的方法\nB、批评的方法\nC、说服教育的方法\nD、强迫劳动的方法\n\n\n正确答案：ABC\n\n3\n【多选题】毛泽东关于走中国工业化道路的思想包括（ ）。\n\nA、把重工业作为我国经济建设的重点\nB、必须充分注意发展农业和轻工业\nC、以农业为基础，以工业为主导，以农轻重为序发展国民经济的总方针\nD、一整套“两条腿走路”的工业化发展思路\n\n\n正确答案：ABCD\n\n4\n【多选题】毛泽东提出，社会主义可以分为两个阶段（ ）。\n\nA、不发达的社会主义\nB、比较发达的社会主义\nC、社会主义初级阶段\nD、社会主义高级阶段\n\n\n正确答案：AB\n\n5\n【多选题】我国社会主义建设道路初步探索的意义有（ ）。\n\nA、巩固和发展了我国的社会主义制度\nB、为开创中国特色社会主义提供了宝贵经验、理论准备、物质基础\nC、丰富了科学社会主义的理论和实践\nD、为其他国家的社会主义建设提供了经验和借鉴\n\n\n正确答案：ABCD\n\n\n\n第五章\n\n1\n【单选题】当今时代主题是（ ）。\n\nA、和平与发展\nB、战争与革命\nC、改革与开放\nD、创新与变革\n\n\n正确答案：A\n\n2\n【单选题】我国发展新的历史方位是（ ）。\n\nA、中国特色社会主义进入了新时代\nB、中国特色社会主义进入了新阶段\nC、中国特色社会主义进入了新时期\nD、中国特色社会主义进入了新征程\n\n\n正确答案：A\n\n3\n【单选题】中国特色社会主义理论体系形成发展的实践基础是（ ）。\n\nA、党领导的新民主主义革命\nB、党领导的社会主义改造\nC、党领导的社会主义建设\nD、党领导的改革开放和社会主义现代化建设\n\n\n正确答案：D\n\n4\n【单选题】提出了“建设有中国特色的社会主义”的重大命题是（ ）。\n\nA、毛泽东\nB、邓小平\nC、江泽民\nD、胡锦涛\n\n\n正确答案：B\n\n5\n【单选题】（ ）把习近平新时代中国特色社会主义思想确立为党的指导思想。\n\nA、党的十七大\nB、党的十八大\nC、党的十九大\nD、党的二十大\n\n\n正确答案：C\n\n1\n【多选题】百年未有之大变局是指（ ）。\n\nA、当前国际格局和国际体系正在发生深刻调整\nB、全球治理体系正在发生深刻变革\nC、国际力量对比正在发生近代以来最具革命性的变化\nD、世界范围呈现出影响人类历史进程和趋向的重大态势\n\n\n正确答案：ABCD\n\n2\n【多选题】习近平新时代中国特色社会主义思想回答的时代课题是（ ）。\n\nA、什么是马克思主义中国化时代化，怎样推进马克思主义中国化时代化\nB、新时代坚持和发展什么样的中国特色社会主义、怎样坚持和发展中国特色社会主义\nC、建设什么样的社会主义现代化强国、怎样建设社会主义现代化强国\nD、建设什么样的长期执政的马克思主义政党、怎样建设长期执政的马克思主义政党\n\n\n正确答案：BCD\n\n3\n【多选题】习近平新时代中国特色社会主义思想的主要内容是（ ）。\n\nA、“十个明确”\nB、“十四个坚持”\nC、“十三个方面成就”\nD、“十个结合”\n\n\n正确答案：ABC\n\n4\n【多选题】习近平新时代中国特色社会主义思想的历史地位是（ ）。\n\nA、当代中国马克思主义、21世纪马克思主义\nB、中华文化和中国精神的时代精华\nC、中国特色社会主义理论体系的重要组成部分\nD、实现中华民族伟大复兴的行动指南\n\n\n正确答案：ABCD\n\n5\n【多选题】中国特色社会主义理论体系是（ ）。\n\nA、马克思主义中国化时代化的重大理论成果\nB、全党全国各族人民团结奋斗的共同思想基础\nC、坚持和发展中国特色社会主义的行动指南\nD、全面推进中华民族伟大复兴的根本指针\n\n\n正确答案：ABCD\n\n\n\n第六章\n\n1\n【单选题】邓小平理论回答的首要的基本理论问题是（ ）。\n\nA、什么是马克思主义中国化，怎样马克思主义中国化\nB、什么是社会主义，怎样建设社会主义\nC、建设什么样的党，怎样建设党\nD、实现什么样的发展，怎样发展\n\n\n正确答案： B\n\n2\n【单选题】邓小平理论的精髓是（ ）。\n\nA、解放思想、实事求是\nB、与时俱进、求真务实\nC、改革开放、自力更生\nD、发展生产、共同富裕\n\n\n正确答案： A\n\n3\n【单选题】社会主义的根本任务是（ ）。\n\nA、消灭剥削\nB、改革开放\nC、发展生产力\nD、实现共同富裕\n\n\n正确答案： C\n\n4\n【单选题】社会主义社会发展的直接动力是（ ）。\n\nA、革命\nB、创新\nC、开放\nD、改革\n\n\n正确答案： D\n\n5\n【单选题】中国特色社会主义理论体系的开篇之作是（ ）。\n\nA、邓小平理论\nB、“三个代表”重要思想\nC、科学发展观\nD、习近平新时代中国特色社会主义思想\n\n\n正确答案： A\n\n1\n【多选题】社会主义的本质是（ ）。\n\nA、解放生产力，发展生产力\nB、消灭剥削，消除两极分化\nC、最终达到共同富裕\nD、按劳分配\n\n\n正确答案： ABC\n\n2\n【多选题】党在社会主义初级阶段的基本路线中“两个基本点”是指（ ）。\n\nA、坚持党的领导\nB、坚持四项基本原则\nC、坚持改革开放\nD、坚持独立自主，自力更生\n\n\n正确答案： BC\n\n3\n【多选题】邓小平提出的“三步走”发展战略是（ ）。\n\nA、从1981年到1990年实现国民生产总值比1980年翻一番，解决人民的温饱问题\nB、从1991年到20世纪末，使国民生产总值再翻一番，达到小康水平\nC、到建党一百周年时，全面建成小康社会\nD、到21世纪中叶，国民生产总值再翻两番，达到中等发达国家水平，基本实现现代化\n\n\n正确答案： ABD\n\n4\n【多选题】社会主义市场经济理论的要点有（ ）。\n\nA、计划经济和市场经济不是划分社会制度的标志，计划经济不等于社会主义，市场经济也不等于资本主义\nB、计划和市场都是经济手段，对经济活动的调节各有优势和长处，社会主义实行市场经济要把两者结合起来\nC、市场经济作为资源配置的一种方式本身不具有制度属性，可以和不同的社会制度结合，但它和不同社会制度结合具有不同的性质\nD、计划经济是社会主义的基本特征，市场经济是资本主义特有的东西\n\n\n正确答案： ABC\n\n5\n【多选题】邓小平提出的“两手抓”的思想有（ ）。\n\nA、一手抓工业，一手抓农业\nB、一手抓物质文明，一手抓精神文明\nC、一手抓建设，一手抓法制\nD、一手抓改革开放，一手抓惩治腐败\n\n\n正确答案： BCD\n\n\n\n第七章\n\n1\n【单选题】“三个代表”重要思想回答的重大问题是（ ）。\n\nA、什么是马克思主义中国化，怎样马克思主义中国化\nB、什么是社会主义，怎样建设社会主义\nC、建设什么样的党，怎样建设党\nD、实现什么样的发展，怎样发展\n\n\n正确答案： C\n\n2\n【单选题】党执政兴国的第一要务是（ ）。\n\nA、发展\nB、改革\nC、开放\nD、创新\n\n\n正确答案： A\n\n3\n【单选题】党的十四大确立了我国经济体制改革的目标是（ ）。\n\nA、建立公有制为主体，多种所有制经济共同发展的经济制度\nB、实行按劳分配为主体，多种分配方式并存的收入分配制度\nC、建立完善的社会保障体系\nD、建立社会主义市场经济体制\n\n\n正确答案： D\n\n4\n【单选题】党领导人民治理国家的基本方略是（ ）。\n\nA、依法治国\nB、以德治国\nC、依人治国\nD、以仁治国\n\n\n正确答案： A\n\n5\n【单选题】标志着我国对外开放进入了一个新的阶段是（ ）。\n\nA、创办经济特区\nB、加入世界贸易组织\nC、建立自贸区\nD、建立自由港\n\n\n正确答案： B\n\n1\n【多选题】“三个代表”重要思想的核心观点是（ ）。\n\nA、始终代表中国先进生产力的发展要求\nB、始终代表中国先进文化的前进方向\nC、始终代表中国最广大人民的根本利益\nD、始终代表发展中国家利益\n\n\n正确答案： ABC\n\n2\n【多选题】正确认识和处理改革、发展、稳定的关系，要（ ）。\n\nA、把改革的力度、发展的速度和社会可承受的程度统一起来\nB、把不断改善人民生活作为处理改革发展稳定关系的重要结合点\nC、在社会稳定中推进改革发展，通过改革发展促进社会稳定\nD、坚持发展是第一要务，为了发展可以牺牲稳定\n\n\n正确答案： ABC\n\n3\n【多选题】党的十五大把“三步走”战略的第三步进一步具体化，提出了三个阶段性目标是（ ）。\n\nA、21世纪第一个10年，实现国民生产总值比2000年翻一番，使人民的小康生活更加富裕，形成比较完善的社会主义市场经济体制\nB、到建党100周年时，全面建成小康社会\nC、到建党100周年时，使国民经济更加发展，各项制度更加完善\nD、到21世纪中叶新中国成立100周年时，基本实现现代化，建成富强民主文明的社会主义国家\n\n\n正确答案： ACD\n\n4\n【多选题】在党的十六大报告中，江泽民把社会主义（ ）一起确立为社会主义现代化全面发展的三大基本目标。\n\nA、物质文明\nB、政治文明\nC、社会文明\nD、精神文明\n\n\n正确答案： ABD\n\n5\n【多选题】江泽民提出领导干部要“三讲”，是指（ ）。\n\nA、讲纪律\nB、讲学习\nC、讲政治\nD、讲正气\n\n\n正确答案： BCD\n\n\n\n第八章\n\n1\n【单选题】科学发展观回答的重大问题是（ ）。\n\nA、什么是马克思主义中国化，怎样马克思主义中国化\nB、什么是社会主义，怎样建设社会主义\nC、建设什么样的党，怎样建设党\nD、实现什么样的发展，怎样发展\n\n\n正确答案： D\n\n2\n【单选题】科学发展观的核心立场是（ ）。\n\nA、发展\nB、以人为本\nC、全面协调可持续\nD、统筹兼顾\n\n\n正确答案： B\n\n3\n【单选题】转变经济发展方式的重大战略决策（ ）。\n\nA、实施创新驱动发展战略\nB、全面深化经济体制改革\nC、促进区域协调发展\nD、推动城乡发展一体化\n\n\n正确答案： A\n\n4\n【单选题】社会主义民主政治的本质和核心要求（ ）。\n\nA、党的领导\nB、人民当家作主\nC、依法治国\nD、自由人权\n\n\n正确答案： B\n\n5\n【单选题】（ ）是中国特色社会主义的本质属性。\n\nA、繁荣富强\nB、民主法治\nC、社会和谐\nD、生态优美\n\n\n正确答案： C\n\n1\n【多选题】科学发展观的基本要求是（ ）。\n\nA、全面\nB、共享\nC、协调\nD、可持续\n\n\n正确答案： ACD\n\n2\n【多选题】社会主义核心价值体系的基本内容包括（ ）。\n\nA、马克思主义指导思想\nB、中国特色社会主义共同理想\nC、以爱国主义为核心的民族精神和以改革创新为核心的时代精神\nD、社会主义荣辱观\n\n\n正确答案： ABCD\n\n3\n【多选题】构建社会主义和谐社会的总要求是（ ）。\n\nA、民主法治、公平正义\nB、诚信友爱、充满活力\nC、安定有序、人与自然和谐相处\nD、共建共享\n\n\n正确答案： ABC\n\n4\n【多选题】建设社会主义生态文明必须树立的生态文明理念有（ ）。\n\nA、改造自然\nB、尊重自然\nC、顺应自然\nD、保护自然\n\n\n正确答案： BCD\n\n5\n【多选题】新形势下，党面临的考验有（ ）。\n\nA、执政考验\nB、改革开放考验\nC、市场经济考验\nD、外部环境考验\n\n\n正确答案： ABCD\n\n\n\n新思想第一章\n\n1\n【单选题】马克思主义中国化时代化的最新理论成果是（ ）。\n\nA、邓小平理论\nB、“三个代表”重要思想\nC、科学发展观\nD、习近平新时代中国特色社会主义思想\n\n\n正确答案： D\n\n2\n【单选题】新时代我国社会主要矛盾是（ ）。\n\nA、人民对于建立先进的工业国的要求同落后的农业国的现实之间的矛盾\nB、人民对于经济文化迅速发展的需要同当前经济文化不能满足人民需要的状况之间的矛盾\nC、人民日益增长的物质文化需要同落后的社会生产之间的矛盾\nD、人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾\n\n\n正确答案： D\n\n3\n【单选题】习近平新时代中国特色社会主义思想始终坚持以（ ）为中心。\n\nA、经济\nB、人民\nC、发展\nD、改革\n\n\n正确答案： B\n\n4\n【单选题】习近平新时代中国特色社会主义思想的主要创立者是（ ）。\n\nA、习近平\nB、江泽民\nC、胡锦涛\nD、邓小平\n\n\n正确答案： A\n\n5\n【单选题】（ ）把习近平新时代中国特色社会主义思想确立为党的指导思想。\n\nA、党的十七大\nB、党的十八大\nC、党的十九大\nD、党的二十大\n\n\n正确答案： C\n\n1\n【多选题】坚持和发展中国特色社会主义的总任务是（ ）。\n\nA、实现社会主义现代化\nB、实现中华民族伟大复兴\nC、实现共同富裕\nD、实现全面小康\n\n\n正确答案： AB\n\n2\n【多选题】习近平新时代中国特色社会主义思想回答的时代课题是（ ）。\n\nA、什么是马克思主义中国化时代化，怎样推进马克思主义中国化时代化\nB、新时代坚持和发展什么样的中国特色社会主义、怎样坚持和发展中国特色社会主义\nC、建设什么样的社会主义现代化强国、怎样建设社会主义现代化强国\nD、建设什么样的长期执政的马克思主义政党、怎样建设长期执政的马克思主义政党\n\n\n正确答案： BCD\n\n3\n【多选题】习近平新时代中国特色社会主义思想的主要内容包括（ ）。\n\nA、“十个明确”\nB、“十四个坚持”\nC、“十三个方面成就”\nD、“三个务必”\n\n\n正确答案： ABC\n\n4\n【多选题】习近平新时代中国特色社会主义思想的世界观和方法论是（ ）。\n\nA、必须坚持人民至上和自信自立\nB、必须坚持守正创新和问题导向\nC、必须坚持改革开放和独立自主\nD、必须坚持系统观念和胸怀天下\n\n\n正确答案： ABD\n\n5\n【多选题】习近平新时代中国特色社会主义思想的历史地位是（ ）。\n\nA、当代中国马克思主义、21世纪马克思主义\nB、中国特色社会主义理论体系的开篇之作\nC、中华文化和中国精神的时代精华\nD、实现中华民族伟大复兴的行动指南\n\n\n正确答案： ACD\n\n\n\n新思想第二章\n\n1\n【单选题】从2020年到2035年，我国发展目标是（ ）。\n\nA、解决温饱问题\nB、全面建成小康社会\nC、基本实现现代化\nD、建成社会主义现代化强国\n\n\n正确答案： C\n\n2\n【单选题】决定当代中国命运的关键一招是（ ）。\n\nA、实现国家统一\nB、党的自我革命\nC、改革开放\nD、全面依法治国\n\n\n正确答案： C\n\n3\n【单选题】全面深化改革要坚持的原则是（ ）。\n\nA、坚持和完善中国特色社会主义制度\nB、坚持党对改革的集中统一领导\nC、坚持人民立场\nD、坚持社会主义市场经济改革方向\n\n\n正确答案： B\n\n4\n【单选题】（ ）是伟大的自我革命。\n\nA、全面建设社会主义现代化国家\nB、全面深化改革\nC、全面依法治国\nD、全面从严治党\n\n\n正确答案： D\n\n5\n【单选题】全面从严治党，要把（ ）摆在首位。\n\nA、政治建设\nB、思想建设\nC、组织建设\nD、作风建设\n\n\n正确答案： A\n\n1\n【多选题】“四个全面”战略布局中战略举措是（ ）。\n\nA、全面深化改革\nB、全面依法治国\nC、全面从严治党\nD、全面建设社会主义现代化国家\n\n\n正确答案： ABC\n\n2\n【多选题】全面深化改革的总目标是（ ）。\n\nA、完善和发展中国特色社会主义制度\nB、推进国家治理体系和治理能力现代化\nC、建立完善的社会主义市场经济体制\nD、建立完善的社会治理体制\n\n\n正确答案： AB\n\n3\n【多选题】全面依法治国的总目标是（ ）。\n\nA、完善和发展中国特色社会主义制度\nB、推进国家治理体系和治理能力现代化\nC、建设中国特色社会主义法治体系\nD、建设社会主义法治国家\n\n\n正确答案： CD\n\n4\n【多选题】走中国特色社会主义法治道路（ ）。\n\nA、是学习西方先进法治经验的必然结果\nB、是历史的必然结论\nC、是由我国社会主义国家性质所决定的\nD、是立足我国基本国情的必然选择\n\n\n正确答案： BCD\n\n5\n【多选题】中国特色社会主义法治道路的核心要义是（ ）。\n\nA、坚持党的领导\nB、坚持中国特色社会主义制度\nC、维护公平正义\nD、贯彻中国特色社会主义法治理论\n\n\n正确答案： ABD\n\n\n\n新思想第三章\n\n1\n【单选题】新发展格局是指（ ）。\n\nA、以国内大循环为主体、以国际大双循环为辅助\nB、以国际大循环为主体、以国内大双循环为辅助\nC、以国内大循环为主体、国内国际双循环相互促进\nD、以国际大循环为主体、国内国际双循环相互促进\n\n\n正确答案： C\n\n2\n【单选题】我国的根本政治制度是（ ）。\n\nA、人民代表大会制度\nB、中国共产党领导的多党合作和政治协商制度\nC、民族区域自治制度\nD、基层群众自治制度\n\n\n正确答案： A\n\n3\n【单选题】（ ）是中国社会主义民主政治中独特的、独有的、独到的民主形式。\n\nA、选举民主\nB、协商民主\nC、人民民主\nD、全面民主\n\n\n正确答案： B\n\n4\n【单选题】（ ）是一个国家、一个民族发展中更基本、更深沉、更持久的力量。\n\nA、道路自信\nB、理论自信\nC、制度自信\nD、文化自信\n\n\n正确答案： D\n\n5\n【单选题】我国社会建设的重点是（ ）。\n\nA、保障和改善民生\nB、创新社会管理\nC、建设平安中国\nD、建设美丽中国\n\n\n正确答案： A\n\n1\n【多选题】我国进入了新发展阶段的依据是（ ）。\n\nA、从理论依据来看，新发展阶段是社会主义初级阶段中的一个阶段\nB、从历史依据来看，新发展阶段是我们党带领人民迎来从站起来、富起来到强起来历史性跨越的新阶段\nC、从现实依据来看，我们已经拥有开启新征程、实现新的更高目标的雄厚物质基础\nD、从国际比较来看，我国已经进入世界发达国家行列\n\n\n正确答案： ABC\n\n2\n【多选题】新时代爱国统一战线的组成包括（ ）。\n\nA、全体社会主义劳动者\nB、社会主义事业的建设者\nC、拥护社会主义的爱国者\nD、拥护祖国统一和致力于中华民族伟大复兴的爱国者\n\n\n正确答案： ABCD\n\n3\n【多选题】社会主义核心价值观的基本内容是（ ）。\n\nA、富强、民主、文明、和谐\nB、自由、平等、公正、法治\nC、自强、弘毅、求是、拓新\nD、爱国、敬业、诚信、友善\n\n\n正确答案： ABD\n\n4\n【多选题】经济发展与改善民生的关系是（ ）。\n\nA、经济发展是改善民生的前提\nB、抓民生可以促进经济发展\nC、经济发展为改善民生提供物质基础\nD、改善民生是经济发展的目的\n\n\n正确答案： ABCD\n\n5\n【多选题】关于绿水青山就是金山银山理解正确的是（ ）。\n\nA、阐述了经济发展和生态环境保护的关系\nB、揭示了保护生态环境就是保护生产力、改善生态环境就是发展生产力的道理\nC、绿水青山既是自然财富、生态财富，又是社会财富、经济财富\nD、保护生态环境就是保护自然价值和增值自然资本，就是保护经济社会发展潜力和后劲，使绿水青山持续发挥生态效益和经济社会效益\n\n\n正确答案： ABCD\n\n\n\n新思想第四章\n\n1\n【单选题】（ ）是安邦定国的重要基石。\n\nA、社会和谐\nB、国家安全\nC、民族团结\nD、国家统一\n\n\n正确答案： B\n\n2\n【单选题】总体国家安全观是（ ）提出的。\n\nA、邓小平\nB、江泽民\nC、胡锦涛\nD、习近平\n\n\n正确答案： D\n\n3\n【单选题】维护国家安全和社会安定的根本保证是（ ）。\n\nA、坚持推进国家安全体系和能力现代化\nB、坚持统筹发展和安全\nC、坚持党对国家安全工作的绝对领导\nD、坚持中国特色国家安全道路\n\n\n正确答案： C\n\n4\n【单选题】坚持总体国家安全观，要以（ ）为宗旨。\n\nA、人民安全\nB、政治安全\nC、经济安全\nD、文化安全\n\n\n正确答案： A\n\n5\n【单选题】坚持总体国家安全观，把（ ）放在首要位置。\n\nA、人民安全\nB、政治安全\nC、经济安全\nD、文化安全\n\n\n正确答案： B\n\n1\n【多选题】关于总体国家安全观理解正确的是（ ）。\n\nA、关键在“总体”\nB、强调打总体战\nC、突出的是大安全理念\nD、强调科学统筹\n\n\n正确答案： ABCD\n\n2\n【多选题】中华优秀传统文化中蕴含着丰富的国家安全战略思想有（ ）。\n\nA、安而不忘危，存而不忘亡，治而不忘乱\nB、民为邦本，本固邦宁\nC、内事文而和，外事武而义\nD、亲人善邻，国之宝也\n\n\n正确答案： ABCD\n\n3\n【多选题】做好国家安全工作要加强科学统筹，做到（ ）。\n\nA、统筹发展和安全\nB、统筹开放和安全\nC、统筹传统安全和非传统安全\nD、统筹自身安全和共同安全\n\n\n正确答案： ABCD\n\n4\n【多选题】政治安全的核心是政权安全和制度安全，最根本的就是（ ）。\n\nA、维护中国共产党的领导和执政地位\nB、维护中国特色社会主义制度\nC、维护国家主权和安全\nD、维护最广大人民的根本利益\n\n\n正确答案： AB\n\n5\n【多选题】总体国家安全观是（ ）。\n\nA、党历史上第一个被确立为国家安全工作指导思想的重大战略思想\nB、马克思主义国家安全理论中国化的最新成果\nC、习近平新时代中国特色社会主义思想的重要组成部分\nD、新时代国家安全工作的根本遵循和行动指南\n\n\n正确答案： ABCD\n\n\n新思想第五章\n\n1\n【单选题】中国坚持以（ ）为底线维护国家主权、安全、发展利益。\n\nA、国际责任\nB、国家核心利益\nC、世界和平\nD、独立自主\n\n\n正确答案： B\n\n2\n【单选题】中国坚持以（ ）为理念引领全球治理体系改革。\n\nA、平等互信\nB、合作共赢\nC、公平正义\nD、相互尊重\n\n\n正确答案： C\n\n3\n【单选题】中国坚持以（ ）为原则推动“一带一路”建设。\n\nA、共商共建共享\nB、互利共赢\nC、公平正义\nD、独立自主\n\n\n正确答案： A\n\n4\n【单选题】中国外交政策的宗旨是（ ）。\n\nA、维护世界和平和促进共同发展\nB、维护国家主权和利益\nC、建立国际政治经济新秩序\nD、反对霸权主义和强权政治\n\n\n正确答案： A\n\n5\n【单选题】“一带一路”倡议是（ ）提出的。\n\nA、邓小平\nB、江泽民\nC、胡锦涛\nD、习近平\n\n\n正确答案： D\n\n1\n【多选题】习近平外交思想是（ ）。\n\nA、习近平新时代中国特色社会主义思想的重要组成部分\nB、马克思主义基本原理同中国特色大国外交实践相结合的重大理论结晶\nC、以习近平同志为核心的党中央治国理政思想在外交领域的集中体现\nD、新时代我国对外工作的根本遵循和行动指南\n\n\n正确答案： ABCD\n\n2\n【多选题】新型国际关系“新”在（ ）。\n\nA、共建共享\nB、相互尊重\nC、公平正义\nD、合作共赢\n\n\n正确答案： BCD\n\n3\n【多选题】构建人类命运共同体的核心是（ ）。\n\nA、政治上，要相互尊重、平等协商，坚决摒弃冷战思维和强权政治，走对话而不对抗、结伴而不结盟的国与国交往新路\nB、安全上，要坚持以对话解决争端、以协商化解分歧，统筹应对传统和非传统安全威胁，反对一切形式的恐怖主义\nC、经济上，要同舟共济，促进贸易和投资自由化便利化，推动经济全球化朝着更加开放、包容、普惠、平衡、共赢的方向发展\nD、文化上，要尊重世界文明多样性，以文明交流超越文明隔阂、文明互鉴超越文明冲突、文明共存超越文明优越\nE、生态上，要坚持环境友好，合作应对气候变化，保护好人类赖以生存的地球家园\n\n\n正确答案： ABCDE\n\n4\n【多选题】“一带一路”是指（ ）。\n\nA、“丝绸之路经济带”\nB、“21世纪海上丝绸之路”\nC、长江经济带\nD、中欧铁路\n\n\n正确答案： AB\n\n5\n【多选题】丝绸之路精神的核心是（ ）。\n\nA、和平合作\nB、开放包容\nC、互学互鉴\nD、互利共赢\n\n\n正确答案： ABCD\n\n\n\n新思想第六章\n\n1\n【单选题】中国特色社会主义最本质的特征是（ ）。\n\nA、党的领导\nB、人民当家作主\nC、依法治国\nD、社会和谐\n\n\n正确答案： A\n\n2\n【单选题】中国特色社会主义制度的最大优势是（ ）。\n\nA、人民当家作主\nB、协商民主\nC、党的领导\nD、法律面前人人平等\n\n\n正确答案： C\n\n3\n【单选题】我国最高政治领导力量是（ ）。\n\nA、全国人民代表大会\nB、中国共产党\nC、国务院\nD、中国人民政治协商会议\n\n\n正确答案： B\n\n4\n【单选题】实现中华民族伟大复兴关键在（ ）。\n\nA、改革开放\nB、依法治国\nC、以人民为中心\nD、党\n\n\n正确答案： D\n\n5\n【单选题】我国的根本领导制度是（ ）。\n\nA、党的领导制度\nB、人民代表大会制度\nC、民族区域自治制度\nD、基层群众自治制度\n\n\n正确答案： A\n\n1\n【多选题】中国共产党的性质是（ ）。\n\nA、中国工人阶级的先锋队\nB、中国人民先锋队\nC、中华民族的先锋队\nD、全体中国人的先锋队\n\n\n正确答案： ABC\n\n2\n【多选题】党的领导是中国特色社会主义制度的最大优势，是因为（ ）。\n\nA、中国特色社会主义制度是党领导人民创建的\nB、党的领导是充分发挥中国特色社会主义制度优势的根本保障\nC、中国特色社会主义制度本身固有的\nD、党的自身优势是中国特色社会主义制度优势的主要来源\n\n\n正确答案： ABD\n\n3\n【多选题】党的领导决策核心是（ ）。\n\nA、中央委员会\nB、中央政治局\nC、中央政治局常委会\nD、全国代表大会\n\n\n正确答案： ABC\n\n4\n【多选题】党是最高政治领导力量，原因是（ ）。\n\nA、与生俱来的\nB、由国家性质所决定的\nC、由国家宪法所确立的\nD、被中国革命、建设、改革伟大实践所证明的\n\n\n正确答案： BCD\n\n5\n【多选题】民主和集中的关系是（ ）。\n\nA、两者互为条件、相辅相成、缺一不可\nB、两者互为前提、相互促进\nC、民主是正确集中的前提和基础\nD、集中是民主的必然要求和归宿\n\n\n正确答案： ACD\n\n\n\n大题部分\n\n1.马克思主义中国化时代化的科学内涵及其三层意思※\n\n  （1）内涵：\n  马克思主义中国化时代化就是立足中国国情和时代特点，坚持把马克思主义基本原理同中国具体实际相结合、同中华优秀传统文化相结合，深入研究和解决中国革命、建设、改革不同历史时期的实际问题，真正搞懂面临的时代课题，不断吸收新的时代内容，科学回答时代提出的重大理论和实践课题，创造新的理论成果。\n\n  （2）三层意思：\n  ①运用马克思主义的立场、观点和方法，观察时代、把握时代、引领时代，解决中国革命、建设、改革中的实际问题。\n  ②总结和提炼中国革命、建设、改革的实践经验并将其上升为理论，不断丰富和发展马克思主义的理论宝库，赋予马克思主义以新的时代内涵。\n  ③运用中国人民喜闻乐见的民族语言来阐述马克思主义，使其植根于中华优秀.\n  传统文化的土壤之中，具有中国特色、中国风格、中国气派。\n\n2 马克思主义中国化时代化的原因※\n\n  一是马克思主义理论本身发展的内在要求\n  二是解决中国实际问题的客观需要。\n\n\n\n3 马克思主义中国化时代化的理论成果及其关系※\n\n  （1）理论成果：毛泽东思想、邓小平理论、“三个代表”重要思想、科学发展观、习近平新时代中国特色社会主义思想。\n\n  （2）关系：一脉相承又与时俱进的关系：\n①一方面，毛泽东思想所蕴含的马克思主义的立场、观点和方法，为中国特色社会主义理论体系提供了基本遵循。\n②另一方面，中国特色社会主义理论体系在新的历史条件下进一步丰富和发展了毛泽东思想。\n③毛泽东思想和中国特色社会主义理论体系都是马克思列宁主义在中国的发展和运用，都以独创性的理论成果丰富和发展了马克思主义的理论宝库\n\n\n\n4 近代中国社会的性质、主要矛盾※\n  ①近代中国社会的性质：半殖民地半封建社会\n  ②主要矛盾：帝国主义和中华民族的矛盾，封建主义和人民大众的矛盾。\n\n\n\n5 过渡时期社会的性质、经济成分、阶级构成和主要矛盾※\n  ①社会性质：新民主主义社会\n  ②经济成分：社会主义性质的国营经济、半社会主义性质的合作社经济、农民和手工业者的个体经济、私人资本主义经济、国家资本主义经济\n  ③阶级构成：工人阶级、农民阶级、其他小资产阶级、民族资产阶级。\n  ④主要矛盾：三种基本经济成分及与之相联系的三种基本的阶级力量之间的矛盾集中表现为社会主义和资本主义两条道路，工人阶级和资产阶级两个阶级的矛盾\n\n\n\n6 社会主义改造的历史经验※\n  第一，坚持社会主义工业化建设与社会主义改造同时并举\n  第二，采取积极引导，逐步过渡的方式\n  第三，用和平方法进行改造\n\n\n\n7 社会主义改造完成后社会主要矛盾※\n  人民对于经济文化迅速发展的需要，同当前经济文化不能满足人民需要的状况之间的矛盾\n\n\n\n8 社会主义建设道路初步探索的意义和经验教训※\n\n  （1）初步探索的意义:\n  ①巩固和发展了我国的社会主义制度。\n  ②为开创中国特色社会主义提供了宝贵经验、理论准备、物质基础。\n  ③丰富了科学社会主义的理论和实践。\n\n  （2）经验教训:\n  ①必须把马克思主义与中国实际相结合，探索符合中国特点的社会主义建设道路。\n  ②必须正确认识社会主义社会的主要矛盾和根本任务，集中力量发展生产力。\n  ③必须从实际出发进行社会主义建设，建设规模和速度要与国力相适应，不能急于求成。\n  ④必须发展社会主义民主，健全社会主义法制。\n  ⑤必须坚持党的民主集中制和集体领导制度，加强执政党建设。\n  ⑥必须坚持对外开放，借鉴和吸收人类文明成果建设社会主义，不能关起门来搞建设。\n\n\n\n9 中国特色社会主义进入新时代的社会主要矛盾※\n\n  人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾。\n\n\n\n10 邓小平理论首要的基本的理论问题和精髓※\n\n  首要的基本的理论问题：建设什么样的社会主义，怎样建设社会主义\n  精髓：解放思想，实事求是，是邓小平理论的精髓\n\n\n\n11 4.\t社会主义的本质※\n  社会主义的本质是解放生产力，发展生产力，消灭剥削，消除两极分化，最终达到共同富裕\n\n\n\n12 “三个代表”重要思想回答的重大问题和核心观点及其关系※\n\n  ①三个代表重要思想回答的重大问题是建设什么样的党？怎样建设党的问题\n\n  ②核心观点：我们党始终代表中国先进生产力的发展要求，代表中国先进文化的前进方向，代表中国最广大人民的根本利益\n\n  ③关系：代表中国先进生产力的发展要求，代表中国先进文化的前进方向，代表中国最广大人民的根本利益是统一的，整体相互关系相互促进发展先进生产力是发展先进文化，实现最广大人民根本利益的基础条件，人民群众是先进生产力和先进文化的创造主体，也是实现自身利益的根本力量，不断发展先进生产力和先进文化，归根到底都是为了满足人民日益增长的物质文化生活需要，不断实现最广大人民的根本利益。(不确定)\n\n\n\n13 科学发展观回答的重大问题和科学内涵※\n\n  科学发展观回答的重大问题是:实现什么样的发展，怎样进行发展的问题\n\n  科学内涵：\n  一，推动经济社会发展是科学发展观的第一要义\n  二，以人为本是科学发展观的核心立场\n  三，全面协调可持续是科学发展观的基本要求\n  四，统筹兼顾是科学发展观的根本方法\n\n\n\n14 习近平新时代中国特色社会主义思想回答的重大时代课题※\n\n  一、新时代坚持和发展什么样的中国特色社会主义、怎样坚持和发展中国特色社会主义\n  二、建设什么样的社会主义现代化强国、怎样建设社会主义现代化强国\n  三、建设什么样的长期执政的马克思主义政党、怎样建设长期执政的马克思主义政党\n\n\n\n15 习近平新时代中国特色社会主义思想的历史地位※\n  一、开辟马克思主义中国化时代化的新境界\n  二、实现中华民族伟大复兴的行动指南\n  三、建设美好世界的中国智慧和中国方案\n\n\n\n16 中国式现代化的内涵、中国特色和本质要求※\n  ①内涵：中国式现代化，是中国共产党领导的社会主义现代化，既有各国现代化的共同特征，更有基于自己国情的中国特色。\n  ②中国特色：中国式现代化是人口规模巨大的现代化、是全体人民共同富裕的现代化、是物质文明和精神文明相协调的现代化、是人与自然和谐共生的现代化、是走和平发展道路的现代化。\n  ③本质要求：坚持中国共产党领导，坚持中国特色社会主义，实现高质量发展，发展全过程人民民主，丰富人民精神世界，实现全体人民共同富裕，促进人与自然和谐共生，推动构建人类命运共同体，创造人类文明新形态\n\n\n\n17 新发展格局的内涵，构建新发展格局的意义和重点任务※\n  ①内涵：立足新发展阶段，贯彻新发展理念，要致力构建以国内大循环为主体、国内国际双循环相互促进的新发展格局。\n\n  ②意义：构建新发展格局是重塑我国国际合作和竞争新优势的战略抉择是把握未来发展主动权的战略性布局和先手棋。\n\n  ③重点任务：\n  构建新发展格局的关键在于经济循环的畅通无阻，必须坚持深化供给侧结构性改革这条主线，继续完成“三去一降一补”的重要任务，实现经济在高水平上的动态平衡。\n  构建新发展格局的最本质特征是实现高水平的自立自强，必须更加强调自主创新，集合优势资源，有力有序推进创新攻关的新体制机制。\n  构建新发展格局要释放内需潜力，必须充分发挥市场资源优势，以巨大国内市场形成构建新发展格局的雄厚支撑。\n  构建新发展格局要实行高水平对外开放，必须具备强大的国内经济循环体系和稳固的基本盘，并以此形成对全球要素资源的强大吸引力、在激烈国际竞争中的强大竞争力、在全球资源配置中的强大推动力。\n\n\n"
} ,
  
  {
    "title"    : "大数据技术原理与应用",
    "category" : "",
    "tags"     : " big data, java, 期末考试",
    "url"      : "/bigdata",
    "date"     : "June 5, 2023",
    "excerpt"  : "  “大数据技术原理与应用”是一门介绍大数据技术的课程。通过学习这门课程，学生可以深入了解大数据技术的原理和应用，并学会如何使用各种工具和技术来处理和管理大数据。此外，该课程还涵盖了大数据架构、设计和性能优化等方面的内容，这些知识对于开展大规模数据处理和分析项目非常重要。因此，“大数据技术原理与应用”对于计算机科学和数据科学领域的学生和从业人员，以及对大数据感兴趣的其他人士都有很大的意义。\n\n\n前言\n  本博客是本人反复听了上课的28分钟录音，听了8个小时左右辛苦肝出来的。如果你可以看到这...",
  "content"  : "  “大数据技术原理与应用”是一门介绍大数据技术的课程。通过学习这门课程，学生可以深入了解大数据技术的原理和应用，并学会如何使用各种工具和技术来处理和管理大数据。此外，该课程还涵盖了大数据架构、设计和性能优化等方面的内容，这些知识对于开展大规模数据处理和分析项目非常重要。因此，“大数据技术原理与应用”对于计算机科学和数据科学领域的学生和从业人员，以及对大数据感兴趣的其他人士都有很大的意义。\n\n\n前言\n  本博客是本人反复听了上课的28分钟录音，听了8个小时左右辛苦肝出来的。如果你可以看到这篇博客，说明我对你有足够的信任，请不要辜负这份信任。\n\n\n  未经本人允许，请不要分享本博客出去，分享方式包括但不限于分享链接，截图等。\n\n\n\n考题整理\n\n客观题部分（50分）\n\n1. Hadoop运行模式有哪些？\n\n\n  单机模式\n  伪分布式模式\n  完全分布式模式\n\n\n\n\n2. 单机模式和伪分布式模式的区别\n\n  单机模式：Hadoop只在一台机器上运行，存储采用本地文件系统，没有采用分布式文件系统HDFS。\n  伪分布式：Hadoop存储采用分布式文件系统HDFS，而且HDFS的名称结点和数据结点位于集群的不同机器上。\n\n\n\n3. 伪分布式的安装\n\n3.1 Hadoop的开发和运行需要什么环境？\n\n  需要Java环境在hadoop-env.sh 中配置\n\n3.2 伪分布式的安装需要修改哪些配置文件？\n\n  需要修改文件：core-site.xml hdfs-site.xml\n\n3.3有关fs.defaultFS的配置的两种问法\n\n3.3.1问法一：fs.defaultFS的参数在哪一个配置文件中进行配置？\n\n  在core-site.xml中配置\n\n3.3.3问法二：配置NameBode地址时由哪一个参数指定的\n\n  由core-site.xml中的dfs.namenode.dir参数指定\n\n\n\n4 Hadoop的核心功能组件\n\n\n  可能会考填空或简答。\n\n\n4.1 填空的问法：请列举出两个除hdfs和MapReduce之外的两个文件\n\n\n  HBase\n  Hive\n  Pig\n  Mahout\n  ZooKeeper\n  Flume\n  Sqoop\n  Ambari\n\n\n4.2 简答题的问法：请举两个核心组件并说明其作用\n\n\n  HBase：是一个提供高可靠性、高性能、可伸缩、实时读写、分布式的列式数据库\n  Hive：是一个基于hadoop数据仓库工具\n  Pig：是一种数据流语言和运行环境\n  Mahout：是一个开源的项目，它提供了一些可扩展的机器学习领域经典算法的实现\n  ZooKeeper：是一个高效和可靠的协同工作系统。\n\n\n\n\nNamenode\n\n\n  Datanode会定时的为Namenode发送心跳\n\n\n5.1用于存储数据块信息的目录结构的是哪一个结点？\n\n  Namenode\n\n5.2 从功能的角度分析Namenode主要用于存储什么信息（不确定）\n\n  NameNode存储着文件系统树以及文件树中所有的文件和文件夹的元数据信息\n\n5.3在HDFS中保存着两个数据结构，请说明这两个数据结构是什么，有什么用？\n\n  这两个数据结构分别是FsImage和Editlog。\n  FsImage用于维护文件系统树以及文件树中所有的文件和文件夹的元数据。\n  EditLog用于操作日志文件以及记录了所有针对文件的创建、删除、重命名等操作。\n\n\n\n6 DataNode的主要功能是什么？\n\n  负责管理它所在结点上存储的数据的读写,及存储数据（存放数据）\n\n\n  DataNode和DataNode之间会进行进程通信\n\n\n\n\n7 Hadoop集群主要瓶颈是什么？\n\n  不是CPU，主要瓶颈是磁盘IO\n\n\n\n8 ssh免密登录是为了什么/目的是什么？\n\n\n  启动集群不需要输入密码\n  进程之间可以免密通信\n  免密登录不是必须的\n\n\n\n\n9 Hadoop的启停命令\n\n\n  start-all.sh：启动所有的Hadoop守护进程\n  stop-all.sh：停止所有的Hadoop守护进程\n  start-dfs.sh：启动Hadoop HDFS守护进程NameNode、SecondaryNameNode和DataNode\n  stop-dfs.sh：停止Hadoop HDFS守护进程NameNode、SecondaryNameNode和DataNode\n  单独启动某个进程：hadoop-daemons.sh start name\n  单独关闭某个进程：hadoop-daemons.sh stop name\n  启动YARN命令：start-yarn.sh\n  关闭YARN命令：stop-yarn.sh\n\n\n\n\n10 Hadoop是否支持随机读取\n\n  不支持\n\n\n\n11 ：指令相关\n\n11.1列举两个HDFS常用的shell命令\n\n\n  Hadoop fs -ls  用于展示在指定目录下的文件详细信息\n  Hadoop fs -cat  将指定文件的内容输出到标准输出\n  Hadoop fs -mkdir [-p]  创建一个或多个文件夹，-p选型用于递归的创建子文件夹\n  Hadoop fs -cp   将文件从源路径复制到目标路径\n\n\n11.2 列举两个常用的java API\n\n\n  org.apache.hadoop.fs.FSDataInputStream：文件输入流，用于读Hadoop文件\n  org.apache.hadoop.fs.FSDataOutputStream:文件输出流，用于写Hadoop文件\n  org.apache.hadoop.fs.Path：用于表示hadoop文件系统中一个文件或者目录的路径\n\n\n\n\n12 Hadoop的特性\n\n12.1 简答题的写法（写5个，不需要解释）：\n\n\n  高可靠性\n  高效性\n  高可扩展性\n  高容错性\n  成本低\n  运行的在linux系统上\n  支持各种编程语言\n\n\n12.2 填空题的写法（挑两个即可）：\n\n\n  高可靠性\n  高效性\n  高可扩展性\n  高容错性\n  成本低\n  运行的在linux系统上\n  支持各种编程语言\n\n\n\n\n综合应用（50分）\n\n13 Hive\n\n  大致题面：br\n\n  给你一段数据（两种数据）：\n\n  第一种：100 \\t zhansan \\t 18\n  第二种：100，zhansan，18\n\n13.1 使用HQL语言创建一个数据库,并指定路径\n\n  create database database_name location ‘path’;\n\n13.2 在指定的数据库中创建表\n\n  use 指定的数据库;\n  如果是第一种数据则写：\n  create table table_name(hight int, name string,age int) ROW FORMAT DELIMITED FIELDS TERMINATED BY ‘\\t’\n\n  如果是第二种数据则写：\n  create table table_name(hight int, name string,age int) ROW FORMAT DELIMITED FIELDS TERMINATED BY ‘,’\n\n13.3 装载数据\n\n  load data [local] inpath &amp;lt; path路径&amp;gt; into table \n\n\n  这里local表示在本地文件中获取，即如果在本地才需要加上\n\n\n13.4 删除（非空）数据库\n\n  drop database  cascade\n\n\n\n14 Hbase\n14.1 设计逻辑结构\n  题面：给你一个json串，设计一个逻辑结构\n\n\n    \n    \n        \n    \n    \n\n\n   答\n\n\n    \n    \n        \n    \n    \n\n\n14.2 如何确定一个单元格？\n\n  以下面这个为例。\n\n\n    \n    \n        \n    \n    \n\n\n   现在以确定一个姓名为LiuJun的人为例：\n行键“201505002”，列族“info”限定符“email”和时间戳“1230016521”这四个坐标值确定的单元格[“201505002”,”Info”,”email”,”1230016521”]\n\n14.2.2问法二：我们的单元格是通过坐标来决定的，这四维坐标分别是什么？\n\n[“行键”,”列族”,”列限定符”,”时间戳”]\n\n\n14.3 创建表\n\n以第一题的表格为例：\n\ncreate &#39;myTable&#39;, {NAME =&amp;gt; &#39;personal_info&#39;}, {NAME =&amp;gt; &#39;office_info&#39;}\n\n14.4 插入数据\n\n  可以使用 put 命令向 HBase 表格中的特定单元格添加数据。以下是向名为 myTable 的表格中，行键为 row1，列族为 cf1，列名为 column1 的单元格添加数据的示例：\n\nput &#39;myTable&#39;, &#39;row1&#39;, &#39;cf1:column1&#39;, &#39;value1&#39;\n\n\n  其中，myTable 是表格的名称，row1 是行键，cf1 是列族名称，column1 是列名。要将值 value1 添加到该单元格，请将其作为最后一个参数传递给 put 命令。\n\n\n\n15 mapreduce\n\n15.1MapReduce的编程规范\n\n用户编写的程序分成三个部分：\n\n1：Mapper\n\n  用户自定义的Mapper要继承自己的父类\n  Mapper的输入数据是KV对的形式（KV类型可自己定义）\n  Mapper中的业务逻辑写在map()方法中\n  Mapper的输出数据是KV对的形式（KV类型可自定义）\n\n\n2：Reducer\n\n  用户自定义的Reducer要继承自己的父类\n  Reducer的输入数据类型对应Mapper输出数据类型\n  Reducer中的业务逻辑写在reduce()方法中\n  ReduceTask进程对每一组相同K的&amp;lt; k,v&amp;gt;组调用一次reduce()方法\n\n\n3：Driver\n相当于Yarn集群的客户端，用于提交我们整个程序到YARN集群，提交的是封装了MapReduce程序相关运行参数的job对象。\n\n15.2自定义数据类型\n\n\n  实现Writable接口\n  空参构造\n  重写序列化方法\n  重写反序列化方法\n  如果需要把结果显示在文件中，则需要重写toString()\n  如果需要将自定义的bean放在key中传输，则要实现Comparable接口\n\n\n15.3代码实现\n\n第一套卷子考点：map逻辑实现\n\n\n    \n    \n        \n    \n    \n\n\n15.3.2第二套卷子考点：Driver逻辑实现\n\n  7点全要考\n\n\n    \n    \n        \n    \n    \n\n\n"
} ,
  
  {
    "title"    : "xcpc模板积累",
    "category" : "",
    "tags"     : " 算法",
    "url"      : "/algorithm",
    "date"     : "May 4, 2023",
    "excerpt"  : "  这是一个竞赛算法模板博客，用于应对xcpc等算法竞赛。此模板不一定是符合大众的模板，我会带有自己的风格。模板我会不断地更新，内容仅供参考。\n\n\n目录\n\n\n  目录\n  算法模板积累\n    \n      图论\n        \n          单源最短路\n            \n              dijiestal\n              SPFA\n            \n          \n          多源最短路\n            \n      ...",
  "content"  : "  这是一个竞赛算法模板博客，用于应对xcpc等算法竞赛。此模板不一定是符合大众的模板，我会带有自己的风格。模板我会不断地更新，内容仅供参考。\n\n\n目录\n\n\n  目录\n  算法模板积累\n    \n      图论\n        \n          单源最短路\n            \n              dijiestal\n              SPFA\n            \n          \n          多源最短路\n            \n              Floyd\n            \n          \n          最小生成树\n            \n              prim\n              Kruskar\n            \n          \n          spfa负环判断\n          差分约束\n          最近公共祖先lca\n          有向图的强连通分量\n          无向图的强连通分量\n            \n              e-dcc缩点\n              v-dcc缩边\n            \n          \n          二分图\n            \n              染色法判断二分图是否合理\n              匈牙利算法 解 二分图的最大匹配数\n            \n          \n        \n      \n      dp\n        \n          背包问题\n            \n              完全背包\n              多重背包的二进制优化\n            \n          \n          数位dp\n        \n      \n      数据结构\n        \n          树状数组\n          线段树\n        \n      \n      数学\n        \n          pow\n          矩阵快速幂\n          逆元计算\n          欧拉筛\n          博弈论\n        \n      \n    \n  \n\n\n\n算法模板积累\n\n\n\n图论\n\n\n\n单源最短路\n\n\n\ndijiestal\nint head[N],edge[N],Next[N],val[N],tt=0;\nvoid add(int x,int y,int z){\n    edge[++tt]=y;\n    val[tt]=z;\n    Next[tt]=head[x];\n    head[x]=tt;\n}\n\nint d[N];\n\nstruct node{\n    int i,d;\n    node(int i=0,int d=0):i(i),d(d){}\n    bool friend operator&amp;lt;(const node &amp;amp;a,const node &amp;amp;b){\n        return a.d&amp;gt;b.d;\n    }\n};\n\nvoid dijiestal(int u){\n    memset(d,0x3f,sizeof d);\n    d[u]=0;\n\n    bool mp[N]={0};\n    priority_queue&amp;lt;node&amp;gt;q;\n    q.push(node(u,0));\n    \n    while(!q.empty()){\n        node e=q.top();\n        q.pop();\n        int x=e.i;\n        if(mp[x]) continue;\n        mp[x]=true;\n\n        for(int i=head[x];i;i=Next[i]){\n            int y=edge[i],y_val=val[i];\n            if(d[y]&amp;gt;d[x]+y_val){\n                d[y]=d[x]+y_val;\n                q.push(node(y,d[y]));\n            }\n        }\n    }\n}\n\n\n\n\nSPFA\n\nstruct node{\n    int val,y;\n    node(int y=0,int val=0):val(val),y(y){}\n};\n\nvector&amp;lt;node&amp;gt;a[M];\nint d[M],b[M];   // b[i]记录在牧场i处有多少只奶牛\nint n,p,c;\n\nint spfa(int u){\n    memset(d,0x3f,sizeof d);\n    d[u]=0;\n    queue&amp;lt;int&amp;gt; q;\n    q.push(u);\n    bool mp[M]={};\n    while(!q.empty()){\n        int x=q.front();\n        q.pop();\n        \n        mp[x]=false;\n        \n        for(node &amp;amp;e:a[x]){\n            int y=e.y,val=e.val;\n            if(d[y]&amp;gt;d[x]+val){\n                d[y]=d[x]+val;\n                if(!mp[y]){\n                    mp[y]=true;\n                    q.push(y);\n                }\n            }\n        }\n    }\n    int res=0;\n    for(int i=1;i&amp;lt;=p;i++){\n        if(b[i]){\n            if(d[i]==MAX) return MAX;\n            res+=b[i]*d[i];\n        }\n    }\n    return res;\n}\n\n\n\n\n多源最短路\n\n\n\nFloyd\n\nmemeset(d,0x3f,sizeof d);\nfor(int i=1,x,y,z;i&amp;lt;=m;i++){\n    cin&amp;gt;&amp;gt;x&amp;gt;&amp;gt;y&amp;gt;&amp;gt;z;\n    d[x][y]=d[y][x]=min(d[x][y],z);\n}\nfor(int k=1;k&amp;lt;=n;i++){\n    for(int i=1;i&amp;lt;=n;i++){\n        for(int j=1;j&amp;lt;=n;j++)\n            d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n    }\n}\n\n\n\n\n最小生成树\n\n\nprim\n\nint d[N],n;\nint res;    // 最小生成树的总路程长度\nint a[N][N];\nstruct node{\n    int i,d;\n    bool friend operator&amp;lt;(const node &amp;amp;a,const node &amp;amp;b){\n        return a.d&amp;gt;b.d;\n    }\n};\n\nvoid prim(int u=1){\n    bool mp[N]={0};\n\n    priority_queue&amp;lt;node&amp;gt;q;\n    q.push({u,0});\n\n    memset(d,0x3f,sizeof d);\n    d[u]=0;\n\n    while(!q.empty()){\n        node e=q.top();\n        q.pop();\n        int x=e.i;\n\n        if(mp[x]) continue;\n        mp[x]=true;\n        res+=e.d;\n\n        for(int y=1;y&amp;lt;=n;y++){\n            if(!mp[y]&amp;amp;&amp;amp;d[y]&amp;gt;a[x][y]){\n                d[y]=a[x][y];\n                q.push({y,d[y]});\n            }\n        }\n    }\n}\n\n\n\nKruskar\n\nint n,k,sum=0;\nint edge[M],head[M],Next[M],val[M],top=0;\nint d[N];\n\nint f[N];\nint Hash[N]={0};\nint get(int x){\n    return f[x]==x?x:f[x]=get(f[x]);\n}\n\nvoid mange(int x,int y){\n    x=get(x);\n    y=get(y);\n    if(x!=y){\n        f[x]=y;\n        Hash[x]=1;\n    }\n}\n\nvoid add(int x,int y,int z){\n    edge[++top]=y;\n    val[top]=z;\n    Next[top]=head[x];\n    head[x]=top;\n}\n\nstruct node{\n    int i,d;\n    node(int i=0,int d=0):i(i),d(d){}\n    friend bool operator&amp;lt;(const node &amp;amp;a,const node &amp;amp;b){\n        return a.d&amp;gt;b.d;\n    }\n};\n\nvoid pirm(int u){\n    bool Hash[N]={0};\n    memset(d,0x3f,sizeof d);\n    priority_queue&amp;lt;node&amp;gt;q;\n    q.push(node(u,0));\n    d[u]=0;\n    while(!q.empty()){\n        int x=q.top().i;\n        q.pop();\n        if(Hash[x]) continue;\n        Hash[x]=true;\n        sum-=d[x];\n        for(int i=head[x];i;i=Next[i]){\n            int y=edge[i],z=val[i];\n            if(!Hash[y]&amp;amp;&amp;amp;z&amp;lt;d[y]){\n                d[y]=z;\n                q.push(node(y,d[y]));\n            }\n        }\n    }\n}\n\n\nspfa负环判断\n\n输入的第一行是两个整数 N,K。\n接下来 K 行，表示分配糖果时需要满足的关系，每行 3 个数字 X,A,B。\n\n\n  如果 X=1．表示第 A 个小朋友分到的糖果必须和第 B个小朋友分到的糖果一样多。\n  如果 X=2，表示第 A 个小朋友分到的糖果必须少于第 B个小朋友分到的糖果。\n  如果 X=3，表示第 A 个小朋友分到的糖果必须不少于第 B个小朋友分到的糖果。\n  如果 X=4，表示第 A 个小朋友分到的糖果必须多于第 B个小朋友分到的糖果。\n  如果 X=5，表示第 A 个小朋友分到的糖果必须不多于第 B 个小朋友分到的糖果。\n\n\n小朋友编号从1到 N。\nbool spfa(){\n    int d[N],cnt[N]={0};\n    bool mp[N];\n    queue&amp;lt;int&amp;gt;q;\n    for(int i=1;i&amp;lt;=n;i++){\n        q.push(i);\n        d[i]=INF;\n        mp[i]=true;\n    }\n    while(!q.empty()){\n        int x=q.front();\n        q.pop();\n        mp[x]=false;\n        for(int i=head[x];i;i=Next[i]){\n            int y=ver[i],z=edge[i];\n            if(d[y]&amp;gt;d[x]+z){\n                d[y]=d[x]+z;\n                cnt[y]=cnt[x]+1;\n                if(cnt[y]&amp;gt;=n) return true;\n                if(!mp[y]){\n                    mp[y]=true;\n                    q.push(y);\n                }\n            }\n        }\n    }\n    return false;\n}\n\n\n\n差分约束\n实质上也是判断负环\n#include&amp;lt;cstring&amp;gt;\n#include&amp;lt;iostream&amp;gt;\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+10;\nconst int K=3e5+10;\nint head[N],Next[K],edge[K],ver[K],tot=0;\n\nvoid add(int x,int y,int z){\n    edge[++tot]=z;\n    ver[tot]=y;\n    Next[tot]=head[x];\n    head[x]=tot;\n}\n\nll d[N]={0};\nbool mp[N];\nint stc[N]={0},top=0;\nint cnt[N]={0};\nint n,k;\nbool spfa(){\n    memset(d,-1,sizeof d);\n    d[0]=0;\n    stc[top++]=0;\n    while(top){\n        int x=stc[--top];\n        mp[x]=false;\n        for(int i=head[x];i;i=Next[i]){\n            int y=ver[i],z=edge[i];\n            if(d[y]&amp;lt;d[x]+z){\n                d[y]=d[x]+z;\n                cnt[y]=cnt[x]+1;\n                if(cnt[y]&amp;gt;=n+1) return true;\n                if(!mp[y]){\n                    mp[y]=true;\n                    stc[top++]=y;\n                }\n            }\n        }\n    }\n    return false;\n}\nint main(){\n    int x,y,t;\n    scanf(&quot;%d %d&quot;,&amp;amp;n,&amp;amp;k);\n    for(int i=1;i&amp;lt;=k;i++){\n        scanf(&quot;%d %d %d&quot;,&amp;amp;t,&amp;amp;x,&amp;amp;y);\n        if(t==1){\n            add(x,y,0);\n            add(y,x,0);\n        }\n        else if(t==2){\n            add(x,y,1);\n        }\n        else if(t==3){\n            add(y,x,0);\n        }\n        else if(t==4){\n            add(y,x,1);\n        }\n        else{\n            add(x,y,0);\n        }\n    }\n    for(int i=1;i&amp;lt;=n;i++) add(0,i,1);\n    if(spfa()){\n        puts(&quot;-1&quot;);\n    }\n    else{\n        ll sum=0;\n        for(int i=1;i&amp;lt;=n;i++)\n            sum+=d[i];\n        printf(&quot;%lld\\n&quot;,sum);\n    }\n    return 0;\n}\n\n\n\n最近公共祖先lca\nconst int N = 4e4 + 5, M = N &amp;lt;&amp;lt; 1;\nstruct E {\n    int v, next;\n} e[M];\nint n, m, t, len, root, u, v, dep[N], f[N][17], h[N];\nvoid add(int u, int v) {\n    e[++len].v = v; e[len].next = h[u]; h[u] = len;\n}\nvoid bfs() {        // 初始化\n    int q[N],tt=0,hh=0;\n    q[tt++]=root;   // 进入一个根节点\n    dep[root] = 1, dep[0] = 0;\n    while (tt!=hh) {\n        int u = q[hh++];\n        for (int j = h[u]; j; j = e[j].next) {\n            int v = e[j].v;\n            if (dep[v]) continue;\n            dep[v] = dep[u] + 1;\n            q[tt++]=v;\n            f[v][0] = u;\n            for (int k = 1; k &amp;lt;= t; k++) f[v][k] = f[f[v][k - 1]][k - 1];\n        }\n    }\n}\nint lca(int x, int y) { // 返回x，y的最近公共祖先\n    if (dep[y] &amp;gt; dep[x]) x=x+y-(y=x);\n    for (int i = t; i &amp;gt;= 0; i--) {\n        if (dep[f[x][i]] &amp;gt;= dep[y]) x = f[x][i];\n    }\n    if (x == y) return x;\n    for (int i = t; i &amp;gt;= 0; i--) {\n        if (f[x][i] != f[y][i]) x = f[x][i], y = f[y][i];\n    }\n    return f[x][0];\n}\n\n\n有向图的强连通分量\nvoid tarjan(int x){\n    low[x]=dfn[x]=++ti;\n    dic[++top]=x;\n    mp[x]=true;\n    for(int i=head[x];~i;i=Next[i]){\n        int y=edge[i];\n        if(!dfn[y]){\n            tarjan(y);\n            low[x]=min(low[x],low[y]);\n        }else if(mp[y]) low[x]=min(low[x],dfn[y]);\n    }\n    if(low[x]==dfn[x]){     // 联通块缩点\n        int y;\n        ecc_cnt++;\n        do{\n            y=dic[top--];\n            id[y]=ecc_cnt;\n            ecc[ecc_cnt].push_back(y);\n            mp[y]=false;\n        }while(x!=y);\n    }\n}\n\n\n无向图的强连通分量\ne-dcc缩点\nint n,m,dcc_cnt;\nint dfn[N],low[N],ti;\nint dic[N],top=0;   // 用于记录边\n\nvoid tarjan(int x,int pre){  // 用于计算桥的算法,pre是边不是点\n    dfn[x]=low[x]=++ti;\n    dic[top++]=x;\n\n    for(int i=head[x];~i;i=Next[i]){    // 注意这里的i表示head要初始化为-1\n        int y=edge[i];\n        if(!dfn[y]){    // 这个点没走过\n            tarjan(y,i);\n            low[x]=min(low[x],low[y]);\n            if(dfn[x]&amp;lt;low[y]){  //这里有桥\n                mp[i]=mp[i^1]=true;\n            }\n        }else if(i!=(pre^1)){   // 这个点走过了，但不是父节点\n            low[x]=min(low[x],dfn[y]);\n        }\n    }\n    if(dfn[x]==low[x]){ // 说明这个是一个连通域的根结点\n        id[x]=++sign;   // 这里将联通域中所有的点压缩为一个点\n        for(int y=dic[--top];y!=x;y=dic[--top]) id[y]=sign;\n    }\n}\n\n\n\nv-dcc缩边\nvoid tarjan(int x){\n    low[x]=dfn[x]=++ti;\n    dic[++top]=x;\n    if(x==root&amp;amp;&amp;amp;head[x]==-1){   // 孤立点\n        dcc_cnt++;\n        dcc[dcc_cnt].push_back(x);\n        return;\n    }\n    int sign=0;\n    for(int i=head[x];~i;i=Next[i]){    // 不是孤立点\n        // 注意这里的i表示head要初始化为-1\n        int y=edge[i];\n        if(!dfn[y]){\n            tarjan(y);\n            low[x]=min(low[x],low[y]);\n            if(dfn[x]&amp;lt;=low[y]){\n                sign++;\n                if(sign&amp;gt;1||x!=root) mp[x]=true;\n                dcc_cnt++;\n                int z;\n                do{\n                    z=dic[top--];\n                    dcc[dcc_cnt].push_back(z);\n                }while(z!=y);\n                dcc[dcc_cnt].push_back(x);\n            }\n        }\n        else low[x]=min(low[x],dfn[y]);\n    }\n}\n\n\n二分图\n\n染色法判断二分图是否合理\nbool dfs(int x,int c){  // 结点，颜色，阈值\n    color[x]=c;\n    for(int i=head[x];i;i=Next[i]){\n        int y=edge[i],val_y=val[i];\n        if(color[y]==color[x]) return false;\n        if(!color[y]&amp;amp;&amp;amp;!dfs(y,3-c,mid)) return false;\n    }\n    return true;\n}\n\nbool check(){\n    memset(color,0,sizeof color);\n    for(int i=1;i&amp;lt;=n;i++){\n        if(!color[i]){\n            if(!dfs(i,1)) return false;     // 出现矛盾就返回\n        }\n    }\n    return true;\n}\n\n\n匈牙利算法 解 二分图的最大匹配数\n二分图的：\n最小覆盖点的数量可以用匈牙利算法求解\n最小覆盖点的数量 = 最大匹配数\n最大独立集 = 总点数 - 最小覆盖点的数量\n\nbool mp[M];  // 表示i是否被访问过\nint match[M];   // 表示i的配对对象是match[i],0表示还没有配对上\nbool dfs(int x){\n    for(int i=head[x];i;i=Next[i]){ // 递归的寻找可以与x配对的点\n        int y=ver[i];\n        if(!mp[y]){  // 这个点没有访问过\n            mp[y]=true; // 标记一下表示访问过了\n            if(!match[y]||dfs(match[y])){   // 找到一个没有配对过的点，或者一个可以让出y的方案\n                match[y]=x; // 回溯的标注与其配对的点\n                return true;\n            }\n        }\n    }\n    return false;   // 没找到可以增广的点\n}\n\n\nint main(){\n    *\n    *\n    *\n    int res=0;  // 表示二分图的最大匹配数\n    for(int i=1;i&amp;lt;=n;i++){  // 注意！！这里枚举的是二分图的左部（右部也可以）\n        memset(mp,0,sizeof mp);  // 这一步不能少\n        if(dfs(i)) \n    }\n    return 0;\n}\n\n\ndp\n背包问题\n完全背包\nfor(int i = 1 ; i&amp;lt;=n ;i++){\n    for(int j = v[i] ; j&amp;lt;=m ;j++)\n        f[j] = max(f[j],f[j-v[i]]+w[i]);\n}\n\n\n多重背包的二进制优化\nwhile(n--){\n    scanf(&quot;%d %d %d&quot;,&amp;amp;v,&amp;amp;w,&amp;amp;s);\n    int k;\n    for(k=1;k&amp;lt;=s;k&amp;lt;&amp;lt;=1){\n        s-=k;\n        for(int i=m;i&amp;gt;=v*k;i--)\n        dp[i]=max(dp[i],dp[i-k*v]+k*w);\n    }\n    if(s&amp;gt;0){\n        for(int i=m;i&amp;gt;=s*v;i--)\n        dp[i]=max(dp[i],dp[i-s*v]+w*s);\n    }\n}\n\n\n数位dp\n这个板子不具有一般性，请结合题目来理解：\n\n如果一个正整数每一个数位都是 互不相同 的，我们称它是 特殊整数 。\n\n给你一个正整数 \\(n\\) ，请你返回区间 \\([1, n]\\) 之间特殊整数的数目。\n\n示例：\n输入:\n    20\n\n\n输出\n    19\n\n\nint f[15][1&amp;lt;&amp;lt;10];   // 前面出现了数字的合法情况下（当前数字允许是0），这里存储的是一般情况下（不受限制）的情况\nint n;\nstring s;   // 字符串表示的数字\n\n// is_limt表示是否受到了前面数字的约束\n// is_num第i个数前面是否填了数字\nint dfs(int i,int mask,bool is_limt,bool is_num){\n    if(i==n) return is_num; // 合法返回1\n        \n    if(!is_limt&amp;amp;&amp;amp;is_num&amp;amp;&amp;amp;f[i][mask]!=-1) return f[i][mask];\n        \n    int res=0;\n    if(!is_num) res=dfs(i+1,mask,false,false);  // 前面全是0的状态是可以传导的，且前面是0那就对后面的数字不存在约束\n\n    // 如果受到限制，那么就必须要设置最大值为s[i]，否则最大值可以到9\n    int up=is_limt?s[i]-&#39;0&#39;:9;\n\n    // is_sum==false表示前面没有填写数字，那么这一位需要从1开始，否则可以从0开始\n    for(int d=1-is_num;d&amp;lt;=up;d++)   // 遍历选择的数字\n        if(!(mask &amp;gt;&amp;gt; d &amp;amp; 1))    // 这个数字没有填写过\n            res+=dfs(i+1,mask|(1&amp;lt;&amp;lt;d),d==up&amp;amp;&amp;amp;is_limt,true);\n    if(!is_limt&amp;amp;&amp;amp;is_num) f[i][mask]=res;\n    return res;\n\n}\n\n\n数据结构\n\n树状数组\n点修改，区间查询\nvoid add(int i,ll d){\n    for(;i&amp;lt;N;i+=i&amp;amp;-i) b[i]+=d;\n}\n\nll ask(int i){\n    ll res=0;\n    for(;i;i-=i&amp;amp;-i) res+=b[i];\n    return res;\n}\n\n\n\n线段树\n\n区间修改，区间查询\n\nconst int N=2e5+10;\nint n,m;\nint a[N];\n\nstruct node{\n    int l,r;\n    ll sum,add;\n    #define l(p) tree[p].l\n    #define r(p) tree[p].r\n    #define add(p) tree[p].add\n    #define sum(p) tree[p].sum\n}tree[N*4];\n\nvoid build(int p,int l,int r){\n    l(p)=l,r(p)=r;\n    if(l==r){\n        sum(p)=a[l];\n        return;\n    }\n    int mid=(l+r)/2;\n    build(p*2,l,mid);\n    build(p*2+1,mid+1,r);\n    sum(p)=sum(p*2)+sum(p*2+1);\n};\n\nvoid spead(int p){\n    if(add(p)){\n        sum(p*2)+=add(p)*(r(p*2)-l(p*2)+1);\n        sum(p*2+1)+=add(p)*(r(p*2+1)-l(p*2+1)+1);\n        add(p*2)+=add(p);\n        add(p*2+1)+=add(p);\n        add(p)=0;\n    }\n}\n\nvoid change(int p,int l,int r,int d){\n    if(l&amp;lt;=l(p)&amp;amp;&amp;amp;r(p)&amp;lt;=r){\n        sum(p)+=d*(r(p)-l(p)+1);\n        add(p)+=d;\n        return;\n    }\n    spead(p);\n    int mid=(l(p)+r(p))/2;\n    if(l&amp;lt;=mid) change(p*2,l,r,d);\n    if(mid&amp;lt;r) change(p*2+1,l,r,d);\n    sum(p)=sum(p*2)+sum(p*2+1);\n}\n\nll ask(int p,int l,int r){\n    spead(p);\n    if(l&amp;lt;=l(p)&amp;amp;&amp;amp;r(p)&amp;lt;=r) return sum(p);\n    int mid=(l(p)+r(p))/2;\n    ll res=0;\n    if(l&amp;lt;=mid) res+=ask(p*2,l,r);\n    if(mid&amp;lt;r) res+=ask(p*2+1,l,r);\n    return res;\n}\n\n\n\n\n\n数学\n\npow\n\n\nll pow(ll p,int n){\n    ll res=1;\n    while(n){\n        if(n&amp;amp;1) res*=p;\n        p*=p;\n        res%=mod;\n        p%=mod;\n        n&amp;gt;&amp;gt;=1;\n    }\n    return res;\n}\n\n\n矩阵快速幂\n\n斐波那契前 n 项和\n\n#include&amp;lt;iostream&amp;gt;\n#include&amp;lt;cstring&amp;gt;\nusing namespace std;\ntypedef long long ll;\nll n,mod;\nll res[3]={1,2,4};\nll a[3][3]={ {0,0,-1},\n             {1,0,0},\n             {0,1,2} };\n\nvoid mul(){\n    ll c[4]={0};\n    for(int j=0;j&amp;lt;3;j++){\n        for(int k=0;k&amp;lt;3;k++)\n            c[j]=(c[j]+res[k]*a[k][j])%mod;\n    }\n    memcpy(res,c,sizeof c);\n}\n\nvoid mulself(){\n    ll c[3][3]=0;\n    for(int i=0;i&amp;lt;3;i++)\n        for(int j=0;j&amp;lt;3;j++)\n            for(int k=0;k&amp;lt;3;k++)\n                c[i][j]=(c[i][j]+a[i][k]*a[k][j])%mod;\n    memcpy(a,c,sizeof a);\n}\n\nint main(){\n    cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;mod;\n    n--;\n    \n    while(n){\n        if(n&amp;amp;1) mul();\n        mulself();\n        n&amp;gt;&amp;gt;=1;\n    }\n    cout&amp;lt;&amp;lt;res[0];\n    return 0;\n}\n\n\n逆元计算\nint exgcd(int a,int b,int &amp;amp;x,int &amp;amp;y){\n    if(b==0){x=1,y=0;return a;}\n    int d=exgcd(b,a%b,x,y);\n    int z=x;\n    x=y;\n    y=z-a/b*y;\n    return d;\n}\n\n\n欧拉筛\nint prime[N],m; // 存放素数\nbool mp[N];     // 判断是否为素数\nint v[N]={0};\n\nvoid primes(){\n    for(int i=2;i&amp;lt;=N;i++){\n        if(v[i]==0) prime[m++]=i,v[i]=i,mp[i]=true;\n        for(int j=0;j&amp;lt;m;j++){\n            if(prime[j]&amp;gt;v[i]||prime[j]&amp;gt;N/i) break;\n            v[i*prime[j]]=prime[j];\n        }\n    }\n}\n\n\n博弈论\n\n给定一个有 N\n\n个节点的有向无环图，图中某些节点上有棋子，两名玩家交替移动棋子。\n\n玩家每一步可将任意一颗棋子沿一条有向边移动到另一个点，无法移动者输掉游戏。\n\n对于给定的图和棋子初始位置，双方都会采取最优的行动，询问先手必胜还是先手必败。\n\n对于一个有向无环图来说，如果只有一个棋子那么那个棋子的位置的sg值为0则必败，否则必胜\n如果有多个棋子那么取这些棋子的sg的异或值，异或值为0则必败，否则必胜。\n\n#include&amp;lt;bits/stdc++.h&amp;gt;\nusing namespace std;\n\nconst int N=1e5+10;\n\nint head[N],edge[N],Next[N],tt;\nint n,m,p;\nint a[N];\nvoid add(int x,int y){\n\tedge[++tt]=y;\n\tNext[tt]=head[x];\n\thead[x]=tt;\n}\nint h[N];\n\nint sg(int x){\n\tif(h[x]!=-1) return h[x];\n\tunordered_map&amp;lt;int,bool&amp;gt;mp;\n\tfor(int i=head[x];i;i=Next[i]){\n\t\tint y=edge[i];\n\t\tmp[sg(y)]=true;\n\t}\n\tfor(int i=0;i&amp;lt;=n;i++){\n\t\tif(!mp[i]){\n\t\t\th[x]=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn h[x];\n}\n\nint main(){\n\tscanf(&quot;%d %d %d&quot;,&amp;amp;n,&amp;amp;m,&amp;amp;p);\n\tfor(int i=1,x,y;i&amp;lt;=m;i++){\n\t\tscanf(&quot;%d %d&quot;,&amp;amp;x,&amp;amp;y);\n\t\tadd(x,y);\n\t}\n\tmemset(h,-1,sizeof h);\n\tint res=0;\n\tfor(int i=1;i&amp;lt;=p;i++){\n\t\tscanf(&quot;%d&quot;,a+i);\n\t\tres^=sg(a[i]);\t// 用于计算sj函数 \n\t}\n\tif(res==0) puts(&quot;lose&quot;); \n\telse puts(&quot;win&quot;);\n\treturn 0;\n}\n\n"
} ,
  
  {
    "title"    : "基于svm实现的屏幕翻译项目解析",
    "category" : "",
    "tags"     : " 人工智能, 计算机视觉, python, 机器学习, 爬虫",
    "url"      : "/tranlate",
    "date"     : "February 19, 2023",
    "excerpt"  : "\n  不知不觉间，人工智能慢慢开始走进千家万户。无人驾驶、AI绘图、语音识别、AI聊天都是人工智能的领域。我作为一个智能的学生已经被迷得不行了，在这份热爱的支持下我完成了这份项目。虽然我的项目与当今智能技术无法比拟，但是其中运用到的机器学习模型（如SVM分类器）足以能够让我的项目归类到人工智能。\n\n\n目录\n\n  目录\n  前言\n  项目总目标\n  正文\n    \n      数据收集与数据清洗\n        \n          为什么要收集数据？\n          数据收集\n    ...",
  "content"  : "\n  不知不觉间，人工智能慢慢开始走进千家万户。无人驾驶、AI绘图、语音识别、AI聊天都是人工智能的领域。我作为一个智能的学生已经被迷得不行了，在这份热爱的支持下我完成了这份项目。虽然我的项目与当今智能技术无法比拟，但是其中运用到的机器学习模型（如SVM分类器）足以能够让我的项目归类到人工智能。\n\n\n目录\n\n  目录\n  前言\n  项目总目标\n  正文\n    \n      数据收集与数据清洗\n        \n          为什么要收集数据？\n          数据收集\n          数据规范化\n        \n      \n      建模与机器学习（SVM）\n        \n          对建模的理解与机器学习的理解\n          建模\n            \n              1.随机划分训练集与测试集\n              2.参数调优\n              3.训练\n              4.模型检验\n              5.模型保存\n            \n          \n          数据处理\n        \n      \n      单词 \\&amp;amp; 句子的识别\n        \n          Q \\&amp;amp; A\n          findContours轮廓获取函数说明\n            \n              函数说明\n              函数签名\n              代码演示\n            \n          \n          首先从图片中分离出句子\n          其次从句子中分离出单词\n          最后从单词中分离出字母并识别\n        \n      \n      翻译\n        \n          传统爬虫\n          selenium技术模块介绍\n          selenium与传统爬虫的对比\n            \n              传统爬虫爬百度翻译\n              selenium爬百度翻译\n            \n          \n          selenium效率优化\n            \n              1. 使用显式等待\n              2. 无头浏览器\n              3. 多线程优化\n            \n          \n          翻译实现\n        \n      \n    \n  \n  作者自己的一些话\n\n\n\n\n前言\n  此项目专用于204技术交流会使用，未经本人允许不得外传。为了更好地展示项目，所以在这里写下这篇博客。本博客面向新人，我尽可能的使用了最朴素的方式来表达我的项目技术流程以及算法思想，且文章中不会出现大量生僻难懂的术语，请放心食用。另外，此静态博客网基于Jekyll框架搭建，但对Jekyll的讨论并不在此次技术交流之列中。如果你对Jekyll感兴趣，随时欢迎与我讨论❤️。\n\n  本项目设计以及编码历时共7天，共计划分8个模块，项目大致可以划出以下几个技术分支：\n\n  基于opencv实现的数据清洗与预处理\n  基于svm机器学习分类器识别字母\n  基于selenium无头浏览器实现的翻译爬虫\n  使用threading线程池优化\n\n\n\n\n\n  温馨提示：如果你觉得界面配色有些刺眼，你可以点击右上角的菜单，选择使用圆形按钮切换主题背景。\n\n\n项目总目标\n\n  实现一个可以实时读取屏幕信息，并翻译图中英文的屏幕翻译器。\n\n  效果展示如下图，左右分别为翻译前后的对比：\n\n\n    \n    \n        \n    \n    \n    \n        \n    \n    \n\n\n  项目主要的技术点以及流程如下所示\n\n\n    \n    \n        \n    \n    \n\n\n\n正文\n\n\n\n数据收集与数据清洗\n\n\n为什么要收集数据？\n\n  要翻译屏幕中的英文，首先要做的应该是识别出屏幕中的英文。识别的工作是交由机器学习模型实现的，但是模型并不是一开始就拥有识别英文的能力。事实上你可以将python所提供机器学习模型视为空壳，只有通过不断的喂养其数据，主观的告诉模型什么是对的什么是错的，在不断的训练学习之后模型才有识别的能力。机器学习因此得名“机器学习”。\n\n  什么？你问我为什么不直接去网上下载一个模型？\n  那肯定是（没找到）想要锻炼💪自己呀！\n\n  一般的，一个模型的好坏主要最关键的因素是数据的优劣。数据越多越纯净就越容易训练出优秀的模型。因此数据整理的部分显的尤为重要。\n\n\n数据收集\n\n  模型需要识别的是屏幕中的英文，所以收集的数据也应该是印刷体的的字母图片。不过这类数据资源在网上很少能找得到，少数在Gethub和Kaggle上找到的资源所训练出的模型效果都不尽人意。\n\n  最终还是决定，自己动手创造数据。\n  首先准备好自制的52个大小写英文字母一份。\n\n\n    \n    \n        \n    \n    \n\n\n  每个字母只有一张图片用以供应模型的训练肯定是不够用的，所以应该对数据进行扩充，保证至少每个字母对应能有20张匹配的图片。这里使用到的技术是图片的下采样以做到图片的扩充，简单的理解就是通过对一张图片采用随机的不同程度的模糊化处理从而到多张图片。\n\n  其中对字母A的采样结果示意图如下：\n\n\n    \n    \n        \n    \n    \n\n\n  你问我为什么不多造几个数据，而是使用下采样扩充？\n  （肝不够多）下采样得到的图片是对原有图片的衍生，同样拥有原图像的基本信息，用这样的数据进行训练不会影响模型的效果。\n\n数据规范化\n\n  图像数据需要最终供模型训练，而训练的接口是固定的，因此所有的数据应该有相同的规格。\n\n  我的做法是将数据处理成 \\(20*20\\) 像素的黑白图片素材使用。\n\n  也就是将一个普通的字母图片通过横向纵向的拉伸与压缩变成一个 \\(20*20\\) 标准的图片。显而易见的，这种做法很容易导致图片信息了流失。我在实践中也遇到了这个问题，其中影响最大的就是字母 \\(il\\) 等长宽比差距较大的字母，如果直接通过拉伸与放缩的手段让其规范化的话就会出现以下的结果（左边为原图，右边为处理后的图像）以至于影响到后面建模的效果:\n\n\n    \n    \n        \n    \n    \n    \n        \n    \n    \n\n\n  对此我的做法是显式地判断图片的长宽比，当长宽比超过4时，手动放缩，具体代码如下：\n\n    def resize(self, img):\n        &quot;&quot;&quot;\n        图像需要原先就是灰度图像\n        将图片调整到标准大小20*20\n        :param img: 原图像\n        :return:finish_img\n        &quot;&quot;&quot;\n\n        if img.shape[0] / img.shape[1] &amp;gt; 4:  # 表示长宽比太大了，不适合做拉伸操作\n            ## 待补充，这里需要解决过度拉伸的问题，可能需要寻找填充的方法\n            # 计算需要用于填充的图像的宽高\n            high = img.shape[0]\n            wide = int((img.shape[0] - img.shape[1]) / 2)\n\n            grid = np.zeros((high, wide))  # 计算用于填充的黑色图片\n\n            img = np.hstack((grid, img))  # 左右都做填充\n            img = np.hstack((img, grid))  # 左右都做填充\n\n            # 最后将填充的图像重新转换为20*20的格式\n            img = cv2.resize(img, (20, 20))\n            if self.debug:\n                print(&quot;这里做了一次对称填充&quot;)\n        else:\n            img = cv2.resize(img, (20, 20))\n        # 调整大小并返回\n        return img\n\n\n\n建模与机器学习（SVM）\n\n对建模的理解与机器学习的理解\n  在数据规范化后我们得到了，噪音（杂质）相对较少的 \\(20 * 20\\)的图片信息，但是我们的\\(SVM\\)分类器模型（下面以“\\(SVM\\)”简称）还不能直接使用这些数据，\\(SVM\\)所反映的是多个数值影响一个数值的映射关系函数，可以简单的概括成以下的函数，训练的最终目的就是为了得到这个函数：\n\n\\[f(x) = w_1x_1 + w_2x_2 + w_3x_3 + /dots w_nx_n\\]\n\n\n  其中 \\(x_i\\) 表示自变量，可以理解为对应图片像素点的数值，\\(w_i\\)表示权值，\\(f(x)\\)是最终计算出来的结果。\n\n\n  将之前清洗好的图像，当成一个个\\(n\\)组400维的方程组，使用\\(SVM\\) 算法“解方程”。\n\n\n  400维由来：一个20*20的图片有400个像素点\n\n\n  上面最终计算得到上面的式子，也就是我们所说的一个训练好的模型。\n\n\n建模\n  数据建模，在这里不是指3D建模，而是指一个机器学习的流程。这里数据建模用到了机器学习是本项目可以称之为人工智能的原因之一。接下来将简单讲解机器学习的流程。\n\n1.随机划分训练集与测试集\n\n  将整理好的数据，按照一定比例划分成训练集与测试集，训练集的数据顾名思义是用于训练数据的，测试集的数据是用来检验模型的正确率的。\n\n\n  训练集的数据就好比那些的有答案的课本，我们拿他学习提升自己的能力，而测试集则更像是试卷，用来检测我们的学习成果。\n\n\n2.参数调优\n\n   一个模型往往有很多的参数需要我们定义，这些参数在不同的情况下需要取不同的数值才能使模型达到最优的效果。不同于平时的算法竞赛题目，这些参数值往往不是确定的，需要我们自己去调整。当然，我们不需要自己手动调参，我们可以用网格搜索与k折交叉验证两种方法来解决最优参数的寻找问题。\n\n  这两种算法的主要做法是，将训练集的数据继续分出一个和验证集，通过不断测试与调整，最终计算出最优模型的参数。由于篇幅有限，其具体做法这里不做过多的描述。\n\n3.训练\n\n  模型训练的操作，其实才是机器学习里面最难的部分，不过好在SVM已经被python封装好了，我们只需要提供前面清洗出的数据以及定义参数调优，稍等片刻即可得到训练好的模型。\n\n4.模型检验\n\n  将之前分出的测试集数据代入模型进行预测，计算正确率。当然评价一个模型的好坏的指标有很多其他的评价指标还有\\(R^2\\)，召回率等等，这里不做延伸。\n\n5.模型保存\n\n  每次训练一个模型经常要消耗大量的时间，为此我们需要保存训练好的模型，在下次做识别时就不需要再训练了。\n\n  上面对机器学习的建模过程的描述地十分简单，但是实际的建模过程远比这个要复杂。只要前面在的“数据分析”“数据选择与清洗”“模型选择”“参数设置”等等环节出现了一个错误都有可能把你的人工智能模型训练成“人工智障”，而且前面的繁多步骤也会加大调参排错的难度。我也是花了4天左右的时间才训练出了一个比较过得去的模型。\n\n\n  ⚡如果你也想入门人工智能，那要求你至少要有比较强的python基础，成熟的面向对象的思维，以及强大的心理素质。⚡\n\n\n  以下是py代码实现\n    def train(self):\n        &quot;&quot;&quot;\n        SVM模型实现\n        :return: None\n        &quot;&quot;&quot;\n        ## 数据分析与预处理\n        x_train, y_train, x_test, y_test = self.get_data()\n\n        ## 网格搜索,找到最优参数\n        machine_svm = svm.SVC()\n\n        param_grid = {&#39;C&#39;: range(0, 50, 10)}  # 这里设置了参数的测试范围\n        grid_search = GridSearchCV(machine_svm, param_grid, cv=3)  # 建立网格搜索器模型\n        grid_search.fit(x_train, y_train)  # 开始搜索\n\n        ## 创建分类器对象\n        print(&quot;最优参数是 c= &quot;, grid_search.best_params_)\n        print(&quot;最优模型正确率 = &quot;, grid_search.best_score_)\n        self.machine_svm = grid_search.best_estimator_  # 获取最优模型\n\n        ## 模型训练\n        self.machine_svm.fit(x_train, y_train)\n\n        ## 模型验证\n        result = self.machine_svm.predict(x_test)\n        correct = np.count_nonzero(result == y_test)\n        accuracy = correct / result.size\n\n        print(&quot;测试集正确率：&quot;, accuracy)\n\n        ## 模型保存\n        joblib.dump(self.machine_svm, &#39;model/svm.pkl&#39;)\n\n\n\n\n\n数据处理\n\n  在前面，我们用做了特殊处理的图片对模型进行训练，所以在用该模型进行识别操作时，也需要对被识别图像做同样的操作。在之前清洗数据时我并没有详细讲解具体的操作，所以放到这里详细说明。\n\n  我们想要预测一个图像，显然无法直接对一个RGB格式的图片下手，对于一个RGB格式的图片，它的每一个像素点都由三个数值组成（Rad Green Blue），这不利于识别，所以需要处理成一个数值，这样的处理过程我们称之为灰度化。\n\n  如下方的两个图像就是做了灰度化处理的图像对比。\n\n\n    \n    \n        \n    \n    \n    \n        \n    \n    \n\n\n  为了更好的配对模型，我们需要对灰度图进一步简化，通常的做法是将像素点间的差距拉的尽可能大（离散化），我们通常使用的方式是二值化\n\n  如下方的两个图像是灰度图像做了二值化处理的前后对比。\n\n\n    \n    \n        \n    \n    \n    \n        \n    \n    \n\n\n  二值化后的图像，为过滤或弱化出图形中的小白点（噪音），我们常常采用高斯模糊（打马赛克）以及腐蚀的方法。\n\n  如下图分别为做了高斯模糊和腐蚀操作的二值图像。\n\n\n    \n    \n        \n    \n    \n    \n        \n    \n    \n\n\n  有时，我们会把握不好腐蚀操作的度，以至于一些重要信息也被过滤掉了，为了弥补过滤掉的内容，一般会对腐蚀后的图像做膨胀操作。\n一般的，先对一个图像做腐蚀再对齐做膨胀的组合操作我们称之为开运算。\n\n  如下为两个分别是做了碰撞和开运算的图像。\n\n\n    \n    \n        \n    \n    \n    \n        \n    \n    \n\n\n  通过opencv库实现以上操作，可以帮助我们从一张图片中提取出很多有效的信息。你可以从下面的代码中直观得体会出这个处理流程。\n\n    def change_color(self, img):\n        &quot;&quot;&quot;\n        将图像进行预处理\n        :param img:img 彩图\n        :return: img 二值图\n        &quot;&quot;&quot;\n        ## 原图像备份\n        copy_img = img.copy()\n        self.show(copy_img)\n\n        ## 高斯模糊\n        copy_img = cv2.GaussianBlur(img, (3, 3), 0)\n\n        ## 图像灰度化\n        copy_img = cv2.cvtColor(copy_img, cv2.COLOR_BGR2GRAY)\n        self.show(copy_img)\n\n        ## 图像二值化\n        _, copy_img = cv2.threshold(copy_img, 115, 255, cv2.THRESH_BINARY_INV)\n        self.show(copy_img)\n\n        ## 开运算降噪\n        copy_img = cv2.morphologyEx(copy_img, cv2.MORPH_OPEN, np.ones((2, 2)), iterations=2)\n        self.show(copy_img)\n\n        ## 膨胀运算\n        copy_img = cv2.morphologyEx(copy_img, cv2.MORPH_DILATE, np.ones((5, 5)), iterations=4)\n        self.show(copy_img)\n\n        return copy_img\n\n\n\n单词 &amp;amp; 句子的识别\n\n  在前面的讲解中，我们已经得到了可以识别字母的模型和清洗好的数据。但是模型只有识别字母的能力没有识别单词的功能，更没有识别句子的能力。所以这里我们需要自己想办法将识别出来的字母进行组合拼凑。\n\n\n\nQ &amp;amp; A\n\n  问题1：为什么，模型无法识别单词？\n  答：模型是拿字母图集训练出来的，所以只能识别单词。\n\n  问题2：是否能够训练出能识别单词的模型\n  答：可以，但是成本很大，效率也不高。对于26个字母都需要上百的图形数据取训练，如果换成数不胜数的单词的话，需要的数据那更是数不清。而且单词之间本身就有很多相似的部分，这也会加大识别的难度降低效率。\n\n  问题3：如果模型不能识别单词，那要怎么处理这个问题呢？\n  答：其实使用数据处理中说到的的方法就可以巧妙地处理这个问题，不过还要用到cv中的一个内置函数函数，具体操作请看下文。\n\n\n\nfindContours轮廓获取函数说明\n\n函数说明\n\n   findContours可以作用于，二值图像，查找出图像的所有轮廓信息并返回。\n\n函数签名\n\n    def findContours(image, mode, method, contours=None, hierarchy=None, offset=None):\n\n  image：表示一个二值度图像。\n  mode：使用的二值化的算法。\n  method：轮廓检测的方式。\n\n  函数具体的使用方式这里不做过多的阐述，如果你对此感兴趣，详情请看这里👉findContours函数详细解析\n\n代码演示\n\n  文字的描述或许依然让你难以理解。那么我们来看看下面的代码和效果展示。\n\ndef test_findContours(self, image=None):\n    &quot;&quot;&quot;\n        该函数用于展示findContours的函数\n        :param img: img\n        :return: img,con\n    &quot;&quot;&quot;\n    ## 轮廓提取\n    contours, w1 = cv2.findContours(image, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n    \n    ## 轮廓绘制\n    show_img = cv2.drawContours(copy_img.copy(), contours, -1, (0, 0, 255), 3)\n    self.show(show_img)\n\n\n  如下两图，分别是原图和描绘轮廓后的图形。\n\n\n    \n    \n        \n    \n    \n    \n        \n    \n    \n\n\n\n\n首先从图片中分离出句子\n\n  如何识别出一个句子？其实我们只需要框出句子的轮廓，再根据轮廓信息，从原图像中裁剪出来即可。\n\n  但是前面谈到的findContours函数似乎只能查找出字母的轮廓，那要怎么做？\n\n  其实只要适当的对图像做膨胀运算，让所有的字母粘连在一起，所有的单词粘连在一起，让它们形成一个整体。那这个整体不就是句子的轮廓了吗？怎么样是不是很巧妙？\n\n\n  不能上手就对图像做膨胀运算，这可能会放大一些杂质（噪音）！\n\n\n  下面将处理过程进行展示，处理次序依次是高斯模糊、灰度化、二值化、开运算、膨胀\n\n\n    \n    \n        \n    \n    \n    \n        \n    \n    \n    \n        \n    \n    \n\n\n\n    \n    \n        \n    \n    \n    \n        \n    \n    \n    \n        \n    \n    \n\n\n  代码实现如下。\n\n    def change_color(self, img):\n        &quot;&quot;&quot;\n        将图像进行预处理\n        :param img:img 彩图\n        :return: img 二值图\n        &quot;&quot;&quot;\n        ## 原图像备份\n        copy_img = img.copy()\n        self.show(copy_img)\n\n        ## 高斯模糊\n        copy_img = cv2.GaussianBlur(img, (3, 3), 0)\n\n        ## 图像灰度化\n        copy_img = cv2.cvtColor(copy_img, cv2.COLOR_BGR2GRAY)\n        self.show(copy_img)\n\n        ## 图像二值化\n        _, copy_img = cv2.threshold(copy_img, 115, 255, cv2.THRESH_BINARY_INV)\n        self.show(copy_img)\n\n        ## 开运算降噪\n        copy_img = cv2.morphologyEx(copy_img, cv2.MORPH_OPEN, np.ones((2, 2)), iterations=2)\n        self.show(copy_img)\n\n        ## 膨胀运算\n        copy_img = cv2.morphologyEx(copy_img, cv2.MORPH_DILATE, np.ones((5, 5)), iterations=4)\n        self.show(copy_img)\n\n        return copy_img\n\n\n\n\n其次从句子中分离出单词\n\n  这一步操作其实和，上一步差不多，只不过需要将膨胀运算等的参数略做调整，使得单词中的字母之间互相连接而单词之间不连接。\n\n  除此之外，还要记录单词之间的次序，以便后期整理。\n\n  话不多说，上结果：\n\n\n    \n    \n        \n    \n    \n    \n        \n    \n    \n    \n        \n    \n    \n\n\n\n    \n    \n        \n    \n    \n    \n        \n    \n    \n    \n        \n    \n    \n\n\n  下面是代码展示，相比与句子识别部分的代码，下面还多了单词剪切和手动降噪的等代码逻辑。\n\n    def image_init(self, img=None):\n        &quot;&quot;&quot;\n        该函数用于将图像灰度化，模糊化，二值化等操作得到可以处理的图像\n        :param img: img\n        :return: img,con\n        &quot;&quot;&quot;\n        if img is None:\n            img = self.img\n        copy_img = img.copy()\n\n        ## 高斯滤波\n        img = cv2.GaussianBlur(img, (3, 3), 0)\n\n        ## 灰度化处理\n        gray_img = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)\n\n        ## 二值化\n        _, binary = cv2.threshold(gray_img, 120, 255, cv2.THRESH_BINARY_INV)\n\n        # ## 开运算用以降噪\n        kernel = np.ones((3, 3))\n        image = cv2.morphologyEx(binary, cv2.MORPH_OPEN, kernel, iterations=1)\n\n        ## 膨胀\n        image = cv2.morphologyEx(binary, cv2.MORPH_DILATE, kernel, iterations=4)\n\n        ## 轮廓提取\n        contours, w1 = cv2.findContours(image, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n        show_img = cv2.drawContours(copy_img.copy(), contours, -1, (0, 0, 255), 3)\n\n        ## 提取有效轮廓\n        result = []\n        for item in contours:\n            if cv2.contourArea(item) &amp;lt; self.min_area:  # 过于小的部分抛弃\n                continue\n\n            rect = cv2.boundingRect(item)\n            x, y, weight, height = rect  # 这个是轮廓的信息\n            result.append(rect)  # 收集所有的轮廓信息\n        # contour 所表示的是每一个矩形轮廓的左上点和右下点的坐标\n\n        contours = [[[a[0], a[1]], [a[0] + a[2], a[1] + a[3]]] for a in result]\n\n        ## 剪切对应的轮廓，并返回对应的轮廓矩形的左上点和右下点的坐标集合、\n        result_imgs = []\n        for contour in contours:\n            result_imgs.append(copy_img[contour[0][1]:contour[1][1], contour[0][0]:contour[1][0]])\n\n        return result_imgs, contours\n\n\n\n\n最后从单词中分离出字母并识别\n\n  其实这一步大体与前面步骤相同，只不过可能不需要再进行膨胀运算了，不然的话将字母整理粘合在一起就不好识别了。\n\n  同样的，我们需要记录分离出来的字母的前后次序，以便整理出正确单词。\n\n  对于每一个分离出来的字母图片同样按照之前数据处理的步骤，整理成一个可供SVM分类器识别的二值图片后，进行字母预测。\n\n  将识别好的字母按顺序组成单词，再将单词按照次序整理成句子（有些类似于函数回溯的过程）。那么我们就得到了图片的英文识别结果了。\n\n  那么下面这两张图就是字母分离的结果，也是我们之前所展示过的。\n\n\n    \n    \n        \n    \n    \n    \n        \n    \n    \n\n\n  下面给出，字母图片处理的有关代码逻辑\n\n    def resize(self, img):\n        &quot;&quot;&quot;\n        图像需要原先就是灰度图像\n        将图片调整到标准大小20*20\n        :param img: 原图像\n        :return:finish_img\n        &quot;&quot;&quot;\n\n        if img.shape[0] / img.shape[1] &amp;gt; 4:  # 表示长宽比太大了，不适合做拉伸操作\n            ## 待补充，这里需要解决过度拉伸的问题，可能需要寻找填充的方法\n            # 计算需要用于填充的图像的宽高\n            high = img.shape[0]\n            wide = int((img.shape[0] - img.shape[1])/2)\n\n            grid = np.zeros((high, wide))  # 计算用于填充的黑色图片\n\n            img = np.hstack((grid, img))      # 左右都做填充\n            img = np.hstack((img, grid))  # 左右都做填充\n\n            # 最后将填充的图像重新转换为20*20的格式\n            img = cv2.resize(img, (20, 20))\n\n          else:\n            img = cv2.resize(img, (20, 20))\n\n        # 调整大小并返回\n        return img\n\n\n\n\n翻译\n\n  翻译功能，本项目使用爬虫实现。\n\n传统爬虫\n\n  对于传统的爬虫，其一般步骤是：\n\n\n  抓包，找接口。\n  寻找表单中的一些参数规律，并解析。\n  封装请求头，保存cookie状态，考虑使用代理等。\n  发送表单请求，获取返回信息。\n  解析数据，并保存。\n\n\n  传统的爬虫方式，其实就是通过伪装成浏览器的方式获取网络资源的。这种做法的好处是，小巧轻便，速度快。\n\n  但是其局限性也很大，一旦后台更改了接口访问方式、文本加密方式就可能要重写一个份代码。对于需要保存登录信息的网页，我们使用的cookie也需要时不时更新一下。一些网站带有的反爬机制也会增加传统爬虫的难度。\n\n\n  顺带一提，百度翻译现在已经加密了翻译接口的表单参数，用传统的爬虫已经爬不了了。\n\n\n  所以我选择selenium技术进行爬虫。\n\n\n\nselenium技术模块介绍\n\n  如果说传统爬虫是伪装成浏览器，那么selenium就是模拟成浏览器访问数据。\n\n  什么是“模拟成浏览器”？\n\n  就是像真的浏览器一样，加载一个网页上所有的数据包括，JavaScript，html，png，等等。\n  如果处理得当，这种爬虫可以规避 \\(95%\\) 的反爬监控。\n\n\n\nselenium与传统爬虫的对比\n\n  selenium的工作思路是基于网页html结构的，而传统爬虫是针对的API接口。\n\n  下面以百度翻译的爬取为例来说明这两种方式的区别。\n\n\n\n传统爬虫爬百度翻译\n\n  1. 打开网页，输入数据，开始抓包。\n\n\n    \n    \n        \n    \n    \n\n\n  2. 找到带有，翻译结果的参数。\n\n\n    \n    \n        \n    \n    \n\n\n  3. 根据抓包工具提供的信息封装请求头。\n\n\n    \n    \n        \n    \n    \n\n\n  4. 整理表单数据，发送请求。\n\n  5. 接收返回信息并解析。\n\n\n\nselenium爬百度翻译\n\n  1. 打开网页，找到输入框，从html源码中定位输入框的位置，编写XPATH语句。\n\n\n    \n    \n        \n    \n    \n\n\n  2. 在定位到的输入框组件中，（不需要手动输入）输入数据。\n\n  3. 再次使用XPATH语法，直接从结果框中定位翻译结果。\n\n\n    \n    \n        \n    \n    \n\n\n  selenium的优势在于，不需要繁琐的更新请求头，不用担心接口的更新而导致程序会失效，selenium相比传统的爬虫更加稳定，如果网页没有较大的改变selenium可以一直有效。selenium的难度也不大，只要有一点html基础和XPATH语法就可以灵活使用。\n\n  selenium的劣势也很明显，由于是模拟浏览器，所以会加载很多用不上的信息，比如网页中的图片，视频之类的资源，这会使得爬取的速度下降。\n\n\n\nselenium效率优化\n\n  前面有提到，selenium因加载无用信息而导致速度的下降，对此我们有以下几种方式来加速。\n\n1. 使用显式等待\n\n  网页中的信息往往在没有全部加载出来前（通俗的讲就是，刷新箭头还在转的时候），就已经出现了我们想要的信息，这个时候我们不需要等待直接上手抓数据。\n  这种方式称之为显式等待。\n\n2. 无头浏览器\n\n  所谓的无头浏览器就是，直接不展示界面，让selenium在后台加载数据，省去浏览器展示的时间。\n\n3. 多线程优化\n\n  这是一种传统的的方法。如果要访问多次，那么多个线程加载肯定比一个要快。要注意访问公共资源时上锁。\n\n\n  多线程优化用的好的话，程序效率会大大提升。不过这也同样加大了调试的难度。初学者要慎重使用。\n\n\n\n\n翻译实现\n\n  selenium爬虫的代码实现，部分代码\nclass spider:\n    url = &#39;https://fanyi.baidu.com/&#39;\n    path_ad = &#39;//div[@class=&quot;app-guide-inner&quot;]/div[@class=&quot;app-guide-aside&quot;]/span&#39;\n    path_input = &#39;//div[@class=&quot;textarea-wrap&quot;]/textarea[@class=&quot;textarea&quot;]&#39;\n    path_out = &#39;//p[@class=&quot;ordinary-output target-output clearfix&quot;]/span&#39;\n\n    @staticmethod\n    def get_no_ui_browser():\n        &quot;&quot;&quot;\n        获得一个无界面浏览器对象\n        :return: Chrome\n        &quot;&quot;&quot;\n        chrome_options = Options()\n        chrome_options.add_argument(&#39;--headless&#39;)\n        chrome_options.add_argument(&#39;--disable-gpu&#39;)\n        chrome_options.add_argument(&#39;blink-settings=imagesEnabled=false&#39;)  # 可以选择不加载图片以提升速度\n        browser = webdriver.Chrome(chrome_options=chrome_options)\n\n        return browser\n\n    @staticmethod\n    def get_browser():\n        &quot;&quot;&quot;\n        获得一个有界面浏览器对象（用于展示或者调试）\n        :return:  Chrome\n        &quot;&quot;&quot;\n\n        return webdriver.Chrome()\n\n    def click_object(self, object):\n        &quot;&quot;&quot;\n        用于点击一个元素\n        :param object:元素对象\n        :return: None\n        &quot;&quot;&quot;\n        self.browser.execute_script(&quot;arguments[0].click();&quot;, object)\n\n    def close_ad(self):\n        # 这里显示等待界面中的广告出现\n        try:\n            self.ad = WebDriverWait(self.browser, 1).until(EC.presence_of_element_located((By.XPATH, self.path_ad)))\n        except:\n            return\n        self.click_object(self.ad)\n\n    def __init__(self, debug=False):\n        self.browser = self.get_browser() if debug else self.get_no_ui_browser()  # 获取一个浏览器对象\n        self.browser.implicitly_wait(5)  # 设置隐式等待的时间\n\n        self.browser.get(self.url)  # 打开界面\n        self.close_ad()  # 关闭界面上的广告\n        self.find_button()  # 寻找输入框\n\n    def find_button(self):\n        &quot;&quot;&quot;\n        此方法用于实现常用元素的查找\n        :return: None\n        &quot;&quot;&quot;\n        ## 寻找输入输出框框\n        self.text_input = WebDriverWait(self.browser, 5).until(\n            EC.presence_of_element_located((By.XPATH, self.path_input)))\n        # self.text_out = self.browser.find_element(by=By.XPATH, value=self.path_out)\n\n    def input(self, text):\n        &quot;&quot;&quot;\n        用于给输入框输入句子\n        :param text: 待翻译文本\n        :return: bool\n        &quot;&quot;&quot;\n        self.text_input.clear()  # 清除输入内容\n        self.text_input.send_keys(text)  # 填写被翻译内容\n\n    def get_translate_sentence(self):\n        &quot;&quot;&quot;\n        获取翻译结果\n        :return:翻译结果\n        &quot;&quot;&quot;\n        try:\n            self.text_out = WebDriverWait(self.browser, 5).until(EC.presence_of_element_located((By.XPATH, self.path_out)))\n        except:\n            return &#39;&#39;\n        return self.text_out.text\n\n    def translate_sentence(self, text, wait=0.5):\n        &quot;&quot;&quot;\n        用于实现翻译的逻辑\n        :param text: 需要翻译的文本\n        :return: 翻译结果\n        &quot;&quot;&quot;\n        self.input(text)\n        time.sleep(wait)\n        return self.get_translate_sentence()\n\n\n  在加上多线程优化\nclass translation_queue:\n    number = 5  # 默认开启界面数\n    queue = []  # 浏览器队列\n    hh, tt = 0, 0  # 队列头，队列尾\n\n    def add_browser(self):\n        self.queue.append(spider())\n\n    def __init__(self, number=None):\n        ## 初始化线程池大小\n        if number is not None:\n            self.number = number\n\n        ## 初始化5个浏览器\n        children = []\n        for _ in range(self.number):\n            children.append(Thread(target=self.add_browser))\n            children[-1].start()\n\n        # 等待所有浏览器初始化完毕\n        for i in range(self.number):\n            children[i].join()\n\n    def set_text(self, text):\n        self.queue[self.tt].input(text)\n        self.tt = (self.tt + 1) % self.number\n\n    def get_text(self):\n        text = self.queue[self.hh].get_translate_sentence()\n        self.hh = (self.hh + 1) % self.number\n        return text\n\n\n\n\n作者自己的一些话\n\n  本项目其实只是对人工智能算法模型SVM分类器的一个小小的应用。一个模型能做的事情其实都很小很简单，因此对图片的数据清洗解析简化等的步骤尤为重要，而这些处理步骤其实就是，将我们所能看懂图片信息一步步转化成计算机能读的懂的数据。然后将计算机得到的结果转化成我们能读懂的信息（如图片，文字，视频）。这些转化的任务正是我们程序员的工作。\n\n  在项目实操中，还是遇到了不少的困难，例如训练数据找不到，训练数据洗不干净，模型效率低，字母il分不清，传统爬虫爬不了翻译等等问题。\n\n  程序试错试也是一个复杂的而又漫长的过程，多线程的优化更是进一步加大了编码的难度。\n\n  实现部分远比我当初预想的要难得多，没有团队的支持所有模块都是我一人完成的，平均花了1-2天的时间，虽然很辛苦，但总之项目还是写出来了，代码不多一共1400行，但行行都是心血的付出。\n\n  希望新人们在以后中遇到困难也可以坚持下去，办法总比困难多。只要方向是对的，那么坚持下去就没有错。\n\n\n\n回到顶部\n"
} ,
  
  {
    "title"    : "Java EE",
    "category" : "",
    "tags"     : " java, java ee, 期末考试",
    "url"      : "/javaee",
    "date"     : "December 24, 2022",
    "excerpt"  : "  Java EE，Java 平台企业版（Java Platform Enterprise Edition），之前称为Java 2 Platform, Enterprise Edition (J2EE)，2018年3月更名为 Jakarta EE(这个名称应该还没有得到群众认可)。是 Sun 公司为企业级应用推出的标准平台，用来开发B/S架构软件。Java EE 可以说是一个框架，也可以说是一种规范。\n\n\n\n前言\n  《java EE》是一门与就业相关度较高的一门课程，作为企业级的应用开发...",
  "content"  : "  Java EE，Java 平台企业版（Java Platform Enterprise Edition），之前称为Java 2 Platform, Enterprise Edition (J2EE)，2018年3月更名为 Jakarta EE(这个名称应该还没有得到群众认可)。是 Sun 公司为企业级应用推出的标准平台，用来开发B/S架构软件。Java EE 可以说是一个框架，也可以说是一种规范。\n\n\n\n前言\n  《java EE》是一门与就业相关度较高的一门课程，作为企业级的应用开发，虽然书本上学的ssm框架已经过时，但是作为我们初学者，它的价值还是不小的。\n\n  本博客按知识点整理一些相关内容，祝愿你可以取得一个让自己满意的成绩。\n\n\n问题解析\nSpring中Bean的作用域有哪些，默认是哪一个\n\n  singleton：单例模式（默认），在整个Spring IoC容器中，使用singleton定义的Bean将只有一个实例\n\n  prototype：原型模式，每次通过容器的getBean方法获取prototype定义的Bean时，都将产生一个新的Bean实例\n\n  request：对于每次HTTP请求，使用request定义的Bean都将产生一个新实例，即每次HTTP请求将会产生不同的Bean实例。只有在Web应用中使用Spring时，该作用域才有效\n\n  session：对于每次HTTP Session，使用session定义的Bean豆浆产生一个新实例。同样只有在Web应用中使用Spring时，该作用域才有效\n\n  globalsession：每个全局的HTTP Session，使用session定义的Bean都将产生一个新实例。典型情况下，仅在使用portlet context的时候有效。同样只有在Web应用中使用Spring时，该作用域才有效\n\n\n\nSpring中有哪些注解\n  1. @Controller：将Controller层的类对象交由spring容器生成与管理\n\n  2. @Service：将Service层的类对象交由spring容器生成与管理\n\n  3. @Repository：将Dao层的类对象交由spring容器生成与管理\n\n  4. @Component将类对象交由spring容器生成与管理\n\n\n\nSpring AOP、IOC的概念\n  AOP(Aspect-Oriented Programming:面向切面编程)：是指将那些与业务无关，却被多个业务模块所共同调用逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，提升系统的可维护性。\n\n  IOC就是控制反转，是指程序将创建对象的控制权转交给Spring框架进行管理，由Spring通过java的反射机制根据配置文件在运行时动态的创建实例，并管理各个实例之间的依赖关系。\n\n\n\nSpring AOP中的通知类型\n\n\n  \n    \n      通知类型\n      注解\n      说明\n    \n  \n  \n    \n      before（前置通知）\n      @Before\n      通知方法在目标方法调用之前执行\n    \n    \n      after（后置通知）\n      @After\n      通知方法在目标方法返回或异常后调用\n    \n    \n      after-returning（返回通知）\n      @AfterReturning\n      通知方法会在目标方法返回后调用\n    \n    \n      after-throwing（异常抛出通知）\n      @AfterThrowing\n      通知方法会在目标方法抛出异常后调用\n    \n    \n      around（环绕通知）\n      @Around\n      通知方法会将目标方法封装起来\n    \n  \n\n\n\n\nSpring 实现AOP的动态代理的方式\n\n  1. JDK动态代理（基于接口实现的）：JDK动态代理制能对实现了接口的类生成代理，而不是针对类\n\n  2. CGLIB动态代理（基于类实现的）：CGLIB是针对类实现代理，主要对指定的类生成一个子类，覆盖其中的方法，添加额外功能，因为是继承，所以该类方法不能用final来声明。\n\n\n\nMyBaes如何防止SQL注入问题\n\n  在编写MyBatis的映射语句时，尽量采用“#{xxx}”这样的格式。若不得不使用“${xxx}”这样的参数，要手工地做好过滤工作，来防止SQL注入攻击。\n\n\n\n动态SQL的使用\n\n&amp;lt;select id=&quot;queryList&quot; parameterType=&quot;com.jinzheng.pojo.Book&quot; resultType=&quot;com.jinzheng.pojo.Book&quot;&amp;gt;\n    select * from tb_book\n    &amp;lt;where&amp;gt;\n        &amp;lt;if test=&quot;id != null and id !=&#39;&#39; &quot;&amp;gt;\n            or id = #{id}\n        &amp;lt;/if&amp;gt;\n        &amp;lt;if test=&quot;name != null and name !=&#39;&#39; &quot;&amp;gt;\n            or name like concat(&#39;%&#39;,#{name},&#39;%&#39;)\n        &amp;lt;/if&amp;gt;\n        &amp;lt;if test=&quot;press != null and press !=&#39;&#39; &quot;&amp;gt;\n            or press like concat(&#39;%&#39;,#{press},&#39;%&#39;)\n        &amp;lt;/if&amp;gt;\n        &amp;lt;if test=&quot;author != null and author !=&#39;&#39; &quot;&amp;gt;\n            or author like concat(&#39;%&#39;,#{author},&#39;%&#39;)\n        &amp;lt;/if&amp;gt;\n        &amp;lt;if test=&quot;bookPrice != null and bookPrice !=&#39;&#39; &quot;&amp;gt;\n            or bookPrice = #{bookPrice}\n        &amp;lt;/if&amp;gt;\n    &amp;lt;/where&amp;gt;\n&amp;lt;/select&amp;gt;\n\n\n\n\nSpring MVC的工作原理\n\n\n    \n    \n        \n    \n    \n\n\n\n\n开发Java Web项目的三层架构\n\n  1)：数据访问层：(dao持久层)主要是对原始数据（数据库或者文本文件等存放数据的形式）的操作层，\n而不是指原始数据，也就是说，是对数据的操作，而不是数据库，具体为业务逻辑层或表示层\n提供数据服务．\n\n  2)：业务逻辑层：(service)主要是针对具体的问题的操作，也可以理解成对数据层的操作，对数据业务\n逻辑处理，如果说数据层是积木，那逻辑层就是对这些积木的搭建。具体的讲主要负责对数\n据层的操作。也就是说把一些数据层的操作进行组合。\n\n  3)：表示层：(controller)主要表示WEB方式，如果逻辑层相当强大和完善，\n无论表现层如何定义和更改，逻辑层都能完善地提供服务。\n主要对用户的请求接受，以及数据的返回，为客户端提供应用程序的访问。\n\n\n\nserverlet需要实现的两个方法是什么\n  1. toGet 方法\n  2. toPut 方法\n\nJSP的9个内置对象\n\n  1. Request对象\n  2. Response对象\n  3. Out对象\n  4. session对象\n  5. Application对象\n  6. PageContext对象\n  7. Config对象\n  8. Page（相当于this）对象\n  9. Exception对象\n\n\n\n程序设计题\n1. MyBean\n设计一个数据库访问的代码：\n\npublic void userFindByIdTest() {\n    String resources = &quot;mybatis-config.xml&quot;;\n    Reader reader = null;\n    try {\n        reader = Resources.getResourceAsReader(resources);\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n    SqlSessionFactory sqlMapper = new SqlSessionFactoryBuilder().build(reader);\n    SqlSession session = sqlMapper.openSession();\n    User user = session.selectOne(&quot;findById&quot;, 1);\n    System.out.println(user.getUname());\n    session.close();\n}\n\n\n2. AOP\n基于注解的AOP代码：\n\n注册bean\n\n&amp;lt;bean name=&quot;userDao&quot; class=&quot;com.itheima.demo03.UserDaoImpl&quot;/&amp;gt;\n&amp;lt;bean name=&quot;AnnoAdvice&quot; class=&quot;com.itheima.demo04.AnnoAdvice&quot;/&amp;gt;\n&amp;lt;!-- 开启@aspectj的自动代理支持 --&amp;gt;\n&amp;lt;aop:aspectj-autoproxy/&amp;gt;\n\n\n\n定义通知\n/**\n * 1、在切面中，需要通过指定的注解将方法标识为通知方法\n * @Before：前置通知，在目标对象方法执行之前执行\n * @After：后置通知，在目标对象方法的finally字句中执行\n * @AfterReturning：返回通知，在目标对象方法返回值之后执行\n * @AfterThrowing：异常通知，在目标对象方法的catch字句中执行\n *\n * 2、切入点表达式：设置在标识通知的注解的value属性中\n * execution(public int com.atguigu.spring.aop.annotation.CalculatorImpl.add(int, int)\n * execution(* com.atguigu.spring.aop.annotation.CalculatorImpl.*(..)\n * 第一个*表示任意的访问修饰符和返回值类型\n * 第二个*表示类中任意的方法\n * ..表示任意的参数列表\n * 类的地方也可以使用*，表示包下所有的类\n * 3、重用切入点表达式\n * //@Pointcut声明一个公共的切入点表达式\n * @Pointcut(&quot;execution(* com.atguigu.spring.aop.annotation.CalculatorImpl.*(..))&quot;)\n * public void pointCut(){}\n * 使用方式：@Before(&quot;pointCut()&quot;)\n *\n * 4、获取连接点的信息\n * 在通知方法的参数位置，设置JoinPoint类型的参数，就可以获取连接点所对应方法的信息\n * //获取连接点所对应方法的签名信息\n * Signature signature = joinPoint.getSignature();\n * //获取连接点所对应方法的参数\n * Object[] args = joinPoint.getArgs();\n *\n */\n \n@Component\n@Aspect  //将当前组件标识为切面\npublic class LoggerAspect {\n \n    @Pointcut(&quot;execution(* com.atguigu.spring.aop.annotation.CalculatorImpl.*(..))&quot;)\n    public void pointCut(){}\n \n    //前置通知\n    //@Before(&quot;execution(public int com.atguigu.spring.aop.annotation.CalculatorImpl.add(int, int))&quot;)\n    //@Before(&quot;execution(* com.atguigu.spring.aop.annotation.CalculatorImpl.*(..))&quot;)\n    @Before(&quot;pointCut()&quot;)\n    public void beforeAdviceMethod(JoinPoint joinPoint) {\n        //获取连接点所对应方法的签名信息\n        Signature signature = joinPoint.getSignature();\n        //获取连接点所对应方法的参数\n        Object[] args = joinPoint.getArgs();\n        System.out.println(&quot;LoggerAspect，方法：&quot;+signature.getName()+&quot;，参数：&quot;+ Arrays.toString(args));\n    }\n \n    //后置通知\n    @After(&quot;pointCut()&quot;)\n    public void afterAdviceMethod(JoinPoint joinPoint){\n        // System.out.println(&quot;LoggerAspect,后置通知&quot;);\n        //获取连接点所对应方法的签名信息\n        Signature signature = joinPoint.getSignature();\n        System.out.println(&quot;LoggerAspect，方法：&quot;+signature.getName()+&quot;，执行完毕&quot;);\n    }\n \n    //返回通知\n    /**\n     * 在返回通知中若要获取目标对象方法的返回值\n     * 只需要通过@AfterReturning注解的returning属性\n     * 就可以将通知方法的某个参数指定为接收目标对象方法的返回值的参数\n     */\n    @AfterReturning(value = &quot;pointCut()&quot;, returning = &quot;result&quot;)\n    public void afterReturningAdviceMethod(JoinPoint joinPoint, Object result){\n        // System.out.println(&quot;LoggerAspect,返回通知&quot;);\n        //获取连接点所对应方法的签名信息\n        Signature signature = joinPoint.getSignature();\n        System.out.println(&quot;LoggerAspect，方法：&quot;+signature.getName()+&quot;，结果：&quot;+result);\n    }\n \n      //异常通知\n    @AfterThrowing( &quot;pointCut()&quot;)\n    public void afterThrowingAdviceMethod(JoinPoint joinPoint){\n        //获取连接点所对应方法的签名信息\n        Signature signature = joinPoint.getSignature();\n        System.out.println(&quot;LoggerAspect，方法：&quot;+signature.getName()+&quot;,异常通知&quot;);\n    }\n \n    /**\n     * 在异常通知中若要获取目标对象方法的异常\n     * 只需要通过AfterThrowing注解的throwing属性\n     * 就可以将通知方法的某个参数指定为接收目标对象方法出现的异常的参数\n     */\n    @AfterThrowing(value = &quot;pointCut()&quot;, throwing = &quot;ex&quot;)\n    public void afterThrowingAdviceMethod(JoinPoint joinPoint, Throwable ex){\n        //获取连接点所对应方法的签名信息\n        Signature signature = joinPoint.getSignature();\n        System.out.println(&quot;LoggerAspect，方法：&quot;+signature.getName()+&quot;，异常：&quot;+ex);\n    }\n \n \n    //环绕通知\n    @Around(&quot;pointCut()&quot;)\n    //环绕通知的方法的返回值一定要和目标对象方法的返回值一致\n    public Object aroundAdviceMethod(ProceedingJoinPoint joinPoint){\n        Object result = null;\n        try {\n            System.out.println(&quot;环绕通知--&amp;gt;前置通知&quot;);\n            //表示目标对象方法的执行\n            result = joinPoint.proceed();\n            System.out.println(&quot;环绕通知--&amp;gt;返回通知&quot;);\n        } catch (Throwable throwable) {\n            throwable.printStackTrace();\n            System.out.println(&quot;环绕通知--&amp;gt;异常通知&quot;);\n        } finally {\n            System.out.println(&quot;环绕通知--&amp;gt;后置通知&quot;);\n        }\n        return result;\n    }\n}\n\n\nMyBean XML程序编写\n要求写出对应的增删改查的几种代码\n\n&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&amp;gt;\n&amp;lt;!DOCTYPE mapper\n        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;\n        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&amp;gt;\n&amp;lt;mapper namespace=&quot;com.jinzheng.dao.BookMapper&quot;&amp;gt;\n\n&amp;lt;!--    显示所有目录--&amp;gt;\n    &amp;lt;select id=&quot;findAll&quot; resultType=&quot;com.jinzheng.pojo.Book&quot;&amp;gt;\n        select * from tb_book\n    &amp;lt;/select&amp;gt;\n\n&amp;lt;!--    根据id查询图书信息 --&amp;gt;\n    &amp;lt;select id=&quot;findBookById&quot; parameterType=&quot;Integer&quot;\n            resultType=&quot;com.jinzheng.pojo.Book&quot;&amp;gt;\n        select *\n        from tb_book\n        where id=#{id}\n    &amp;lt;/select&amp;gt;\n\n&amp;lt;!--    添加数据--&amp;gt;\n    &amp;lt;insert id=&quot;addBook&quot; parameterType=&quot;com.jinzheng.pojo.Book&quot;&amp;gt;\n        insert into tb_book values (#{id},#{name},#{press},#{author},#{bookPrice})\n    &amp;lt;/insert&amp;gt;\n\n&amp;lt;!--        删除数据--&amp;gt;\n    &amp;lt;delete id=&quot;deleteById&quot; parameterType=&quot;Integer&quot;&amp;gt;\n        delete from tb_book where id = #{id}\n    &amp;lt;/delete&amp;gt;\n\n&amp;lt;!--    修改数据--&amp;gt;\n    &amp;lt;update id=&quot;updateBook&quot; parameterType=&quot;com.jinzheng.pojo.Book&quot;&amp;gt;\n        update tb_book\n        &amp;lt;set&amp;gt;\n            &amp;lt;if test=&quot;name != null and name != &#39;&#39; &quot;&amp;gt;\n                name = #{name},\n            &amp;lt;/if&amp;gt;\n            &amp;lt;if test=&quot;press != null and press != &#39;&#39; &quot;&amp;gt;\n                press = #{press},\n            &amp;lt;/if&amp;gt;\n            &amp;lt;if test=&quot;author != null and author != &#39;&#39; &quot;&amp;gt;\n                author = #{author},\n            &amp;lt;/if&amp;gt;\n            &amp;lt;if test=&quot;bookPrice != null and bookPrice != &#39;&#39; &quot;&amp;gt;\n                bookPrice = #{bookPrice},\n            &amp;lt;/if&amp;gt;\n\n        &amp;lt;/set&amp;gt;\n        where id = #{id}\n    &amp;lt;/update&amp;gt;\n\n&amp;lt;!--        根据图书信息去模糊查询图书信息(动态SQL)--&amp;gt;\n    &amp;lt;select id=&quot;queryList&quot; parameterType=&quot;com.jinzheng.pojo.Book&quot; resultType=&quot;com.jinzheng.pojo.Book&quot;&amp;gt;\n        select * from tb_book\n        &amp;lt;where&amp;gt;\n            &amp;lt;if test=&quot;id != null and id !=&#39;&#39; &quot;&amp;gt;\n                or id = #{id}\n            &amp;lt;/if&amp;gt;\n            &amp;lt;if test=&quot;name != null and name !=&#39;&#39; &quot;&amp;gt;\n                or name like concat(&#39;%&#39;,#{name},&#39;%&#39;)\n            &amp;lt;/if&amp;gt;\n            &amp;lt;if test=&quot;press != null and press !=&#39;&#39; &quot;&amp;gt;\n                or press like concat(&#39;%&#39;,#{press},&#39;%&#39;)\n            &amp;lt;/if&amp;gt;\n            &amp;lt;if test=&quot;author != null and author !=&#39;&#39; &quot;&amp;gt;\n                or author like concat(&#39;%&#39;,#{author},&#39;%&#39;)\n            &amp;lt;/if&amp;gt;\n            &amp;lt;if test=&quot;bookPrice != null and bookPrice !=&#39;&#39; &quot;&amp;gt;\n                or bookPrice = #{bookPrice}\n            &amp;lt;/if&amp;gt;\n        &amp;lt;/where&amp;gt;\n    &amp;lt;/select&amp;gt;\n\n&amp;lt;/mapper&amp;gt;\n\n\n"
} ,
  
  {
    "title"    : "服务器",
    "category" : "",
    "tags"     : " 服务器, 期末考试",
    "url"      : "/server",
    "date"     : "December 23, 2022",
    "excerpt"  : "  服务器指的是网络环境下为客户机(Client)提供某种服务的专用计算机，服务器安装有网络操作系统和各种服务器应用系统软件(如Web服务、电子邮件服务)的计算机。服务器具有高速的CPU运算能力、长时间的可靠运行、强大的I/O外部数据吞吐能力以及更好的扩展性。\n\n\n\n前言\n  《服务端技术原理与应用》是一门考察类课程，其课程本身难度不大，但是知识点比较多。希望你能好好准备，取得一个好成绩。\n\n\n\n知识点剖析\n\n小点\n\n  在Windows server中，新建的用户属于users组\n  系...",
  "content"  : "  服务器指的是网络环境下为客户机(Client)提供某种服务的专用计算机，服务器安装有网络操作系统和各种服务器应用系统软件(如Web服务、电子邮件服务)的计算机。服务器具有高速的CPU运算能力、长时间的可靠运行、强大的I/O外部数据吞吐能力以及更好的扩展性。\n\n\n\n前言\n  《服务端技术原理与应用》是一门考察类课程，其课程本身难度不大，但是知识点比较多。希望你能好好准备，取得一个好成绩。\n\n\n\n知识点剖析\n\n小点\n\n  在Windows server中，新建的用户属于users组\n  系统安装在NTFS盘中\n  ipconfig /release可以释放IP地址\n  权限以最低为准\n  每个人的最低权限都是只读权限\n\n\n\n\n1. 域名空间结构\n简单介绍\n  根域：代表域名命名空间的根，这里为空。\n\n  顶级域：直接处于根域下面的域，代表一种类型的组织或一些国家。在Internet中，顶级域由InterNIC（Internet Network Information Center）进行管理和维护。\n\n  二级域：在顶级域下面，用来标明顶级域以内的一个特定的组织。在Internet中，二级域也是由InterNIC负责管理和维护。\n\n  子域：在二级域的下面所创建的域，它一般由各个组织根据自己的需求与要求，自行创建和维护。\n\n  主机：是域名命名空间中的最下面一层，它被称之为完全合格的域名（Fully Qualified Domain Name，FQDN），例如www.sanxia.net.cn就是一个完全合格的域名。\n\n域名级别\n\n机构顶级域名：\n  com 商业机构，\n  gov 政府机构，\n  edu 教育机构，\n  int 国际组织，\n  mil 军事部门，\n  net 网络运行与服务中心\n  org 其他的非赢利机构\n\n地区顶级域名：\n  CN（中国）\n  hk （中国香港）\n  TW（中国台湾）\n  JP（日本）\n  RU（俄罗斯）\n  UK或GB（英国）\n\n\n\n2.Window Server 2016主要新增功能\n身份标识和访问权限\n  Window Server 2016的Active Directory域服务可以帮助组织保护Active Directory环境并为组织和个人设备提供更好的标识管理，并提供联合身份验证服务(AD FS) , AD FS对轻型目录访问协议(LDAP) 目录中存储的用户进行身份验证的新功能。\n\n系统管理性能\n  Window Server 2016提供了新安装选项: Nano Server。 Nano Server针对私有云和数据中心进行优化的远程管理的服务器操作系统。其所需磁盘空间小，启动速度快。Windows Server 2016引入了一种新的PackageManagement功能(以前称为OneGet)，该功能可以允许IT专业人员或开发人员使软件发现、安装、清单(SDIl)在本地或远程自动进行，无论安装程序技术为何，也不管软件位于何处。\n\n系统网络管理\n  Window Server 2016新增了软件定义的网络。与分布式防火墙和网络安全组联合使用，使你能够以类似于Azure的方式动态分段和保护工作负荷。其次，你可以使用System Center Virtual Machine\n\n  Manager部署并管理整个软件定义的网络(SDN)堆栈。最后，可以使用Docker来管理Windows Server 容器网络，并将SDN 策略与虚拟机和容器关联。在TCP性能改进方面，默认初始拥塞窗口(ICW) 已从4增加到10并已实现TCP快速打开(TFO)。\n\n系统数据存储\n  Windows Server 2016中的存储包括软件定义存储以及传统文件服务器的新功能和增强功能。存储空间直通允许通过使用具有本地存储的服务器构建高可用性和可缩放存储。存储副本可在各个服务器或群集之间实现存储不可知的块级同步复制，以便在站点间进行灾难恢复及故障转移群集扩展。\n\nweb应用程序开发\n  Windows Server 2016中的lIS 10.0 Web服务器提供的新增功能包括:\n\n  1. 在网络堆栈中支持HTTP/2协议，并与IIS10.0集成，允许IIS 10.0网站针对支持的配置为HTTP/2请求自动提供服务。\n\n  2. 在Nano Server 中运行和管理lIS 10.0的功能\n\n  3. 支持通配符主机头，使管理员能够为域设置Web 服务器，然后让Web服务器为任何子域的请求提供服务。\n一个用于管理IIS的新 PowerShell模块(1ISAdministration)。\n\n\n\n3.DHCP报文\n  DHCP服务器和客户端之间通过8种类型的报文进行通信。8种类型报文的格式相同，只是某些字段的取值不同。DHCP报文格式基于BOOTP的报文格式。它们是:\n\n1. DHCP DISCOVER:\n  这是DHCP客户端首次登录网络时进行DHCP过程的第一个报文，用来寻找DHCP服务器。\n\n2. DHCP OFFER:\n  DHCP服务器用来响应DHCP，DISCOVER报文，此报文携带了各种配置信息。\n\n3. DHCP REQUEST\n  此报文用于以下三种用途：\n\n  客户端初始化后，发送广播的DHCP REQUEST 报文来回应服务器的 DHCP OFFER 报文。\n\n  客户端重启初始化后，发送广播的 DHCP REQUEST 报文来确认先前被分配的IP地址等配置信息。\n\n  当客户端已经和某个IP地址绑定后，发送 DHCP REQUEST 报文来延长IP地址的租期。\n\n4. DHCP ACK:\n  服务器对客户端的DHCP REQUEST 报文的确认响应报文，客户端收到此报\n文后，才真正获得了IP地址和相关的配置信息。\n\n5. DHCP NAK:\n  服务器对客户端的DHCP REQUEST 报文的拒绝响应报文，比如服务器对客户\n\n  端分配的IP地址已超过使用租借期限（服务器没有找到相应的租约记录)或者由于某些原因无法正常分配IP地址，则发送 DHCP NAK报文作为应答（客户端移到了另一个新的网络)。\n\n  通知DHCP客户端无法分配合适IP地址。DHCP客户端需要重新发送\n\nDHCP DISCOVERY\n  报文来申请新的IP地址。\n\nDHCP DECLINE:\n  当客户端发现服务器分配给它的IP地址发生冲突时会通过发送此报文来通知服务器，并且会重新向服务器申请地址。\n\nDHCP RELEASE:\n  客户端可通过发送此报文主动释放服务器分配给它的IP地址，当服务器收到此报文后，可将这个IP地址分配给其它的客户端。\n\nDHCP INFORM:\n  客户端已经获得了IP地址，发送此报文的目的是为了从服务器获得其他的一些网络配置信息，比如网关地址、DNS服务器地址等，\n\n\n\n4.操作题（ip配置）\n\n  在DHCP服务器上创建一个IP地址作用域，它的名称为“office”，所包含的IP地址范围为：192.168.1.1～192.168.1.100，子网掩码为：255.255.255.0，需要排除的IP地址范围为：192.168.1.51～192.168.1.60，采用默认的租约期限，不用配置DHCP选项。\n\n操作步骤：\n  步骤1：单击【开始】→【程序】→【管理工具】→【DHCP】，打开“DHCP”管理控制台。\n\n  步骤2：右键单击这台计算机的名称，然后选择【新建作用域】 。\n\n  步骤3：当出现“欢迎使用新建作用域向导”时，单击【下一步】按钮。这时出现“作用域名”对话框。\n\n  步骤4：在“作用域名”对话框中，输入：“office”，然后单击【下一步】按钮。\n\n  步骤5：在“IP地址范围”对话框中的【起始IP地址】中输入：192.168.1.1、在【结束IP地址】中输入：192.168.1.100、在【子网掩码】中输入：255.255.255.0。单击【下一步】。\n\n  步骤6：在“添加排除”对话框中的【起始IP地址】中输入：192.168.1.51、在【结束IP地址】中输入： 192.168.1.60、然后单击【添加】按钮，再单击【下一步】按钮。\n\n  步骤7：在“配置DHCP选项”对话框中，选择【否，我想稍后配置这些选项】，单击【下一步】按钮。\n\n  步骤8：当出现“正在完成建立作用域向导”对话框时，单击【完成】按钮。\n\n5.DHCP地址分配类型\nDHCP允许有三种类型的地址分配如下:\n\n1.自动分配方式\n  当DHCP客户端第一次成功的从DHCP 服务器端租用到IP地址之后,就永远使用这个地址。\n\n2.动态分配方式\n  当DHCP第一次从 HDCP服务器端租用到IP地址之后，并非永久的使用该地址，只要租约到期，客户端就得释放这个IP地址，以给其它工作站使用。当然，客户端可以比其它主机更优先的更新租约，或是租用其它的IP地址。\n\n3.手工分配方式\n  DHCP客户端的IP地址是由网络管理员指定的,DHCP服务器只是把指定的IP地址告诉客户端。\n\n\n\n6.分布式文件系（DFS）的优点\n  DFS是将相同的文件同时存储到网络上多台服务器上后，就可以有以下功能和优点:\n\n1.访问文件更加容易\n  分布式文件系统使用户可以更容易地访问文件。共享文件可能在物理上跨越多个服务器,用户只需要转到网络上的一个位置即可访问文件。\n\n2.可用性\n  基于域的DFS命名空间以两种方法确保用户保持文件的访问，一是WindowsServer 20016自动将DFS拓扑发布到活动目录中，以确保DFS拓扑对域中所有服务器上的用户总是可见的;二是用户可以复制DFS根目录和DFS共享文件夹。复制意味着可以在域中的多个服务器上存储DFS根目录和DFS共享文件夹，即使这些文件驻留的一个物理服务器不可用，用户仍然可以访问此文件。\n\n3.服务器负载平衡\n  DFS根目录支持物理上分布在网络中的多个DFS共享文件夹。这一点很有用,例如，当用户将频繁访问某一文件时,并非所有的用户都在单个服务器上物理地访问此文件，这将会增加服务器的负担,DFS确保访问文件的用户分布于多个服务器。然而，在用户看来,文件驻留在网络上的相同位置。\n\n7.服务器的分类\n主DNS服务器\n  主域名服务器负责维护域中的域名服务信息，管理员需要配置正向解析文件、反向解析文件等相关信息，本身具有向客户机提供域名解析的功能。\n\n辅助DNS服务器\n  辅助域名服务器不需要配置正向解析与反向解析的数据库文件，辅助域名服务器的正向解析与反向解析数据库是从主域名服务器复制得来的。辅助域名服务器的作用是分担主域名服务器的查询负担，提供域名查询的稳定性和可靠性。\n\n转发DNS服务器\n  转发DNS服务器(Forwarder Name Server)可以向其他DNS转发解析请求。\n\n惟缓存DNS服务器\n  惟缓存DNS服务器不配置域名解析数据库文件，也不从主域名服务器同步其数据库信息。当本地DNS客户机有查询请求时，它会向某个远程DNS服务器转发查询请求。\n\n\n\n8.操作题（账户配置）\n\n在计算机上创建一个本地用户帐户，帐户名为“student”，密码为“12345”，并且允许用户在第一次登录时更改密码。\n\n操作步骤：\n\n步骤1：右键单击【我的电脑】→【管理】，然后在“计算机管理”对话框中的【本地用户和组】中右击【用户】，然后选择【新用户】 。\n\n步骤2：在“新用户”对话框中的【用户名】中输入【student】 ，在【密码】中输入：12345，在【确认密码】中再次输入：12345，然后选中用户【下次登录时须更改密码 】 。\n\n步骤3：单击【创建】按钮。\n\n\n\n9.如何在一台服务器上建立多个Web站点\n\n\n  使用不同的IP地址\n  使用不同的端口号\n  使用主机头\n\n\n10.概念考察总汇\n\n操作系统\n  操作系统位于底层硬件与用户之间，是两者沟通的桥梁。用户可以通过操作系统的用户界面，输入命令。\n\n动态磁盘\n  动态硬盘，即动态磁盘。动态硬盘是指在Windows操作系统的磁盘管理器中将本地硬盘升级得来的。\n\nDNS\n  即域名系统，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。\n\nVPN\n  VPN虚拟专用网络，利用公用网络架设专用网络活动目录。\n\n组策略\n  是管理员为用户和计算机定义并控制程序、网络资源及操作系统行为的主要工具。\n"
} ,
  
  {
    "title"    : "计算机组成原理",
    "category" : "",
    "tags"     : " 计算机组成原理, 期末考试",
    "url"      : "/computer",
    "date"     : "December 18, 2022",
    "excerpt"  : "计算机组成原理重点讲授计算机系统的硬件组成，及其主要功能子系统的基本原理和逻辑设计；主要内容包括计算机系统概述，数据的表示、运算与校验，CPU子系统，存储子系统，总线与I/O子系统，I/O设备及接口等。\n\n\n\n前言\n本博客针对《计算机组成原理》课程进行期末复习，其中复习形式以对真题的解答为主要方式。本门课程偏硬件，对于软件专业的可能需要花费更多的时间来攻克本门课程。希望你顺利通过本门考试。\n\n\n\n考题分析\n\n\n  \n    \n      题型\n      单项分数\n      题量\n   ...",
  "content"  : "计算机组成原理重点讲授计算机系统的硬件组成，及其主要功能子系统的基本原理和逻辑设计；主要内容包括计算机系统概述，数据的表示、运算与校验，CPU子系统，存储子系统，总线与I/O子系统，I/O设备及接口等。\n\n\n\n前言\n本博客针对《计算机组成原理》课程进行期末复习，其中复习形式以对真题的解答为主要方式。本门课程偏硬件，对于软件专业的可能需要花费更多的时间来攻克本门课程。希望你顺利通过本门考试。\n\n\n\n考题分析\n\n\n  \n    \n      题型\n      单项分数\n      题量\n      总分\n    \n  \n  \n    \n      选择\n      2\n      10\n      20\n    \n    \n      判断\n      1\n      10\n      10\n    \n    \n      简答\n      5\n      10\n      20\n    \n    \n      计算\n      10\n      3\n      30\n    \n    \n      综合\n      15\n      2\n      30\n    \n  \n\n\n\n\n选择题\n\n1. 两个数\\(9F5 H\\)和\\(513 H\\)相加，得( C ).\n\n\n  后缀H表示16进制，其表示方式\\(9F5 H\\)等价于\\((9F5)_{16}\\)\n\n\n  A: BDBH\n  B: CD8H\n  C: F08H\n  D: CC8H\n\n2. ( D )表示法主要用于表示浮点数中的阶码。\n\n  A: 原码\n  B: 补码\n  C: 反码\n  D: 移码\n\n3. 存储字长是( C )\n\n  存储字长是位数，大小才是个数\n\n\n  A: 存储单元的个数\n  B: 机器指令的位数\n  C: 存放在一个存储单元之后的二进制代码位数\n  D: 机器字长\n\n4. 若[x]补 = 1.10001100，则[x]原=( B )。\n\n  这里的第一位表示符号位不是小数点\n原码 = 补码按位取反后 + 1\n\n\n  A: 1.0010101\n  B: 1.01110100\n  C: 0.0010110\n  D: 0.1101010\n\n5. 若CPU的地址线为A0~A15，某芯片存储单元有8K，则加在该存储器芯片上的地址线为( C )。\n\n  1k 表示 \\(2^{10}\\) 所以可以推算出 8k 表示 \\(2^{13}\\) 所以总线占据13位\n\n\n  A: A0~A10\n  B: A0~A11\n  C: A0~A12\n  D: A0~A13\n\n6. 冯.诺依曼机工作方式的基本特点是( B )。\n\n  A: 多指令流单数据流\n  B: 按地址访问并顺序执行指令\n  C: 堆栈操作\n  D: 存储器按内容选择地址\n\n7. 某一RAM 芯片，其容为1024*8位，其数据线和地延线分别为( C )。\n\n  1024 表示地址线 \\(2^{10}\\) 共10位，数据线为8位\n\n\n  A: 3、10\n  B: 10、3\n  C: 8、10\n  D: 10、8\n\n8. Cache的地址映射中，若主存中的任意一块均可映射到Cache内的任意一块的位置上，称( B )。\n\n  直接映射表示：取模映射，每一个块只能映射到模数固定的位置上。\n全相联映射：如题意。\n组相联映射：组间直接映射，组内全映射\n\n\n  A: 直接映射\n  B: 全相联映射\n  C: 组相联映射\n  D: 以上全是\n\n9. 某机字长8位，来用补码形式，则机疑数能表示的范国是( C )。\n\n  左闭右开\n\n\n  A: -127~+127\n  B: -128~+128\n  C: -128~+127\n  D: -127~+128\n\n10. 计算机操作的最小单位时间是( A )。\n\n  A: 时钟周期\n  B: 机器周期\n  C: CPU周期\n  D: 指令周期\n\n\n\n判断题\n\n11．超前进位不要考虑前一位来的进位。（✔）\n12. 在补码的加减法中，用两位符号位判断溢出,两位符号位组合为10时，表示结果正溢。（✖）\n\n  00\t结果为正，无溢出 \n01\t正溢，（大于机器所能表示的最大正数）\n10\t负溢，（小于机器所能表示的最小负数）\n11\t结果为负，无溢出\n\n\n13. NAND闪存更适用作为U盘。 （✔）\n14. 在程序的执行过程中，Cache与主存的地址映射是由操作系统来管理的。 (✖)\n\n  此处应该把操作系统换成硬件\n\n\n15．存取时间比存取周期花费的时间要长一些。 (✖)\n\n  存取周期包括了存储时间，所以存储周期时间要更长\n\n\n16. 浮点数的正负由阶码的正负符号决定。 (✖)\n\n  正负由符号位决定\n\n\n17. NOR闪存更适用作为程序存储器。 (✖)\n\n18. \\(E^2PROM\\) 是带电可擦可编程的只读存储。 (✔)\n19．硬件实现的功能一般比款件实现具有更尚的执行速度。 (✔)\n20. 动态存储DRAM的刷新是以列为单位的。 (✖)\n\n  应该以行为单位\n\n\n\n\n简答题\n21. 任意写出五种指令寻址方式。\n\n  1. 隐含寻址\n  2. 立即寻址\n  3. 直接寻址\n  4. 间接寻址\n  5. 寄存器寻址\n  6. 寄存器间接寻址\n  7. 偏移寻址\n  8. 堆栈寻址\n\n22．写出 NOR和NAND型Flash闪存各自的优缺点\n  NOR可靠性高，适用于擦除次数和编程操作较少，而直接执行代码的场合。\n  NAND存储速度快，闪存有10倍于NOR闪存的可擦除次数，适用于大容量存储设备。\n\n\n\n计算题\n23. 二进制计算\n\n  指数 = 阶码 - 127\n\n  IEEE754标准: 1位符号位 + 8位阶码 + 23位尾数\n\n\n(1)设浮点数的阶码和尾数部分均用二进制补码表示，按照浮点数的运算规则计算X+Y:\\(X=2^{-101}*0.101100，Y=2^{-100}*(-0.101000)\\)\n\n  [x]浮=1011;0.101100，[y]浮=1100;1.011000\n\n  对阶:小阶向大阶看齐。\n\n  △E=EA-EB=-1\n\n  [x]浮’=1100;0.010110\n\n  尾数相加：00.010110+11.011000=11.101110\n\n  需左规一次\n\n  [x+y]浮=1011；1.011100\n\n  X+Y=2-101*（-0.100100）\n\n（2）将十进制数10.375表示成单精度的IEEE754标准规定的32位短浮点数（结呆以十六进制形式给出)。\n\n将整数部分和小数部分整理成二进制可以得到：\n\n  \\(10.375=(1010.011)_2\\)\n\n移动小数点，使其位于第一二位之间：\n\n  \\(1010.011=1.010011 X 2^3\\)\n\n可以得到：\n\n  \\(S=0 E=3+127=130 M=010011\\)\n\n所以有二进制的IEEE754标准表达式：\n\n  \\(01000001 00100110 00000000 00000000\\)\n\n最终得到16进制的IEEE754标准表达式：\n\n  \\((41260000)_{16}\\)\n\n24．设主存容量为256K字，Cache容量为2K字，块长为256字，存储器按字寻址。\n\n  块数 = 容量 / 块长\n\n  直接映射标志位 = s - r\n全相联映射标志位 = s\nw = log(块大小)，r = log(Cache行数)，s = log(主存块数) - w\n\n\n1)在直接映射方式下,设计主存地址格式并求标志位的位数;\n\n  \\(块大小 = 256 = 2^8 = 2^w 字节\\)\n  \\(所以w=8位\\)\n\n  \\(主存寻址单元数 = 256K = 2^{18} = 2^{s+w}\\)\n  \\(所以s = 18-8 = 10 位\\)\n\n  \\(Cache的行大小=2K/256=2^2=2^r\\)\n  \\(所以r=2 位，标记位位数=s-r=10-2=8位\\)\n\n综上所述：\n\n\n  \n    \n      标记s-r\n      行r\n      字地址w\n    \n  \n  \n    \n      8位\n      2位\n      8位\n    \n  \n\n\n标记位的位数是8位\n\n2)在全相联映射方式下，设计主存地址格式并求标志位的位数。\n  \\(块大小 = 256 = 2^8 = 2^w 字节\\)\n  \\(所以w=8位\\)\n\n  \\(主存寻址单元数 = 256K = 2^{18} = 2^{s+w}\\)\n  \\(所以s = 18-8 = 10 位\\)\n\n综上所述\n\n\n  \n    \n      标记s\n      字地址w\n    \n  \n  \n    \n      10位\n      8位\n    \n  \n\n\n标记位的位数是10位\n\n\n\n综合题\n\n25．用8K*2位的SRAM芯片组成32K*8位的存储器。试问:\n\n1)地址寄存器多少位?(5分)\n\n  字大小 = 32K = 2^15\n  所以需要15位\n\n2)共需要多少片SRAM?(5分)\n\n由题意可得\n  新组成的存储器，需要4倍的字扩容、4倍的位扩容才能得到\n  所以：需要\\(4*4 = 16\\)片\n\n3)画出此存储器的组成简要框图。(5分)\n\n\n    \n    \n        \n    \n    \n\n\n26. 作图（微指令与微操作）\n\n\n    \n    \n        \n    \n    \n\n\n参见图1的数据通路,画出取数指令“LDA(R3),RO的指令周期流程图,其含义是将(R3)为地址数存单元的内容取至寄存器RO中，画出方框图并标出各微操作信号序列。\n\n  输入可以不用画\n\n  在下图中，包括菱形在内的上面部分是取指，不包括菱形的下部分是执行\n\n\n\n    \n    \n        \n    \n    \n\n\n"
} ,
  
  {
    "title"    : "马克思主义原理",
    "category" : "",
    "tags"     : " 马克思主义基本原理, 期末考试",
    "url"      : "/marxism",
    "date"     : "December 17, 2022",
    "excerpt"  : "马克思主义基本原理是指马克思主义政治经济学、辩证唯物主义和历史唯物主义以及科学社会主义。它是马克思主义科学体系的基本理论、基本范畴，是其立场、观点和方法的理论表达。\n\n\n\n前言\n本篇博客为对马原课程的期末复习整理，主要是针对68个知识点来整理的，内容较多。祝愿你可以在考试中拿下一个好成绩！\n\n\n\n考试题型\n\n\n  \n    \n      题型\n      题量\n      分值（题/分）\n      总分\n    \n  \n  \n    \n      单选\n      20\n      1\n...",
  "content"  : "马克思主义基本原理是指马克思主义政治经济学、辩证唯物主义和历史唯物主义以及科学社会主义。它是马克思主义科学体系的基本理论、基本范畴，是其立场、观点和方法的理论表达。\n\n\n\n前言\n本篇博客为对马原课程的期末复习整理，主要是针对68个知识点来整理的，内容较多。祝愿你可以在考试中拿下一个好成绩！\n\n\n\n考试题型\n\n\n  \n    \n      题型\n      题量\n      分值（题/分）\n      总分\n    \n  \n  \n    \n      单选\n      20\n      1\n      20\n    \n    \n      多选\n      10\n      2\n      20\n    \n    \n      简答\n      2\n      5\n      10\n    \n    \n      论述\n      2\n      10\n      20\n    \n    \n      分析\n      2\n      15\n      30\n    \n    \n      合计\n      36\n       \n      100\n    \n  \n\n\n\n考题分析\n\n\n\n导论\n1.马克思主义的三个基本组成部分及其理论来源（P2、P5）\n  三个基本组成部分：马克思主义哲学、马克思主义政治经济学和科学社会主义。\n  理论来源：德国古典哲学、英国古典政治经济学、英法两国的空想社会主义。\n\n2.马克思主义产生的社会根源、阶级基础和思想渊源（P4-5）（待确定）\n  社会根源：资本主义生产方式的发展。\n  阶级基础：无产阶级斗争对科学理论的需求。 \n  思想渊源：19世纪西欧三大先进思潮。细胞学说，能量守恒与转化定律，生物进化论，为马克思主义的产生提供了自然科学前提。\n\n3.马克思主义公开问世的标志（P6）\n  《共产党宣言》的发表。\n\n4.《反杜林论》（P7）\n  恩格斯写出了《反杜林论》。全面阐述了马克思主义理论体系。\n\n5.马克思主义的鲜明特征（P10-11）\n  科学性，人民性，实践性，发展性。\n\n6.马克思主义的当代价值（P12-15）（多选）\n  观察当代世界变化的认识工具\n  指引当代中国发展的行动指南\n  引领人类社会进步的科学真理。\n\n7.自觉学习和运用马克思主义（P17-18）\n  努力学习和掌握马克思主义的基本立场观点方法。\n  努力学习和掌握马克思主义中国化的理论成果。\n  坚持理论联系实际的马克思主义学风。\n  自觉将马克思主义内化于心外化于行。\n\n\n\n第一章\n8.哲学的基本问题（P21）\n  哲学的基本问题主要包括两方面内容。一是存在和思维，物质和意识谁为本源的问题，即何者为第一性的问题，对于这一问题的不同回答形成了唯物主义和唯心主义两种根本对立的哲学派别，二是存在和思维，物质和意识是否具有同一性的问题，即思维能否正确的反映存在人能否认识或彻底认识世界的问题，对这一问题的不同回答，产生了可知论和不可知论的理论分野\n\n9.意识的本质（P26）\n  意识是人脑这样一种特殊物质的机能和属性，是客观世界的主观映象。\n\n10.主观能动和客观规律性的辩证统一（P27）\n  一方面尊重客观规律是正确发挥主观能动性的前提。\n  另一方面只有充分发挥主观能动性，才能正确认识和利用客观规律。\n\n11.联系的含义及特点（P32）\n  联系是指事物内部各要素之间和事物之间互相影响，互相制约，互相作用的关系。\n  联系具有客观性，普遍性、多样性、条件性。\n\n12.发展的实质（P33）\n  新事物的产生和旧事物的灭亡。\n\n13.矛盾的同一性和斗争性原理及其方法论要求（P35-36）\n\n  本知识点考查大题目\n\n\n方法论原理：\n  矛盾的同一性是指矛盾着的对立面，互相依存，互相贯通的性质和趋势，有两个方面的含义\n  一是矛盾着的对立面，相互依存互为存在的前提并共处于一个统一个体中。\n  二是矛盾着的对立面，互相贯通，在一定条件下可以互相转化。矛盾的斗争性是矛盾着的，对立面互相排斥，互相分离的性质和趋势。\n\n方法论要求：\n  矛盾的统一性和斗争性的辩证关系原理，要求我们在观察和处理问题时，必须善于把两者结合起来，既要看到矛盾双方的对立，又要看到矛盾双方的统一，在斗争中把握同一性，在同一性中把握斗争性。\n\n14.矛盾的普遍性和特殊性的辩证关系原理及其方法论要求（P37）\n\n  本知识点考查大题目\n\n\n方法论原理：\n  矛盾的普遍性和特殊性是辩证统一的关系，矛盾的普遍性，即矛盾的共性，矛盾的特殊性，即矛盾的个性。 \n  二者相互区别矛盾的共性是无条件的，绝对的矛盾的，个性是有条件的，相对的\n  二者相互区别任何存在的事物都是共性和个性的有机统一，共性寓于个性之中，没有离开个性的共性，也没有离开共性的个性\n  二者在一定条件下相互转化\n  方法论要求我们坚持个性与共性相结合的分析方法\n\n方法论要求：\n  矛盾同一性和斗争性的辩证关系原理要求，我们在观察和处理问题时，必须善于把两者结合起来，在斗争性中把握同一性，在同一性中把握斗争性，既要看到矛盾双方的对立，又要看到矛盾双方的统一。\n\n15.量变质变规律及其方法论要求（P38）\n\n  本知识点考查大题目\n\n\n方法论原理：\n  第一量变是质变的必要准备；\n  第二质变是量变的必然结果；\n  第三量变和质变是相互渗透的；\n\n方法论要求：\n  一方面当事物的发展处在量变阶段时，要踏踏实实做好日常工作，为未来重大改变做准备。\n  另一方面当质变来临的时候要果断的不失时机的抓住机遇，促成质变，使工作迈上新台阶。\n\n16.辩证的否定观及其方法论要求（P39）\n\n  本知识点考查大题目\n\n\n方法论原理：\n  第一否定是事物自我否定；\n  第二否定是事物发展的环节；\n  第三否定是新旧事物联系的环节；\n  第四辩证否定的实质是扬弃。\n\n方法论要求：\n  按照否定之父定规律办事，就要求我们树立辩证的否定观，反对形而上学的肯定一切或否定一切，要对事物采取科学分析的态度，使实践活动符合事物自我否定的辩证本性，同时又要求我们正确看待事物发展的过程，既要看到道路的曲折，又要看到前途的光明。\n\n17.原因与结果（P41）\n  原因与结果是揭示事物引起和被引起关系的一对范畴，在事物的普遍联系中，引起某种现象的现象就是原因，被某种现象所引起的现象就是结果。\n\n18.辩证思维能力（P50）\n\n  本知识点考查大题目\n\n\n  提高辩证思维能力，要求我们客观地而不是主观地联系地，而不是孤立地发展地，而不是静止的全面地而不是片面地系统地而不是零散地观察事物，把握事物的本质和发展规律，找到解决问题的方法和途径。\n  以问题为向导，善于正确分析矛盾，在对立中把握统一在统一中把握对立，克服极端化，片面化，善于运用辩证思维谋划事业发展。\n\n\n\n第二章\n19.实践的基本特征（P62-63）\n  实践具有客观实在性、自觉能动性、社会历史性。\n\n20.实践对认识的决定作用（P67-68）\n\n  本知识点考查论述题\n\n\n实践是认识的来源；\n  实践是认识发展的动力；\n  实践是认识的目的；\n  实践是检验认识真理的唯一标准。\n\n21.两条根本对立的认识路线（P69）\n\n  本知识点考查大题目\n\n\n  在认识的本质问题上，存在着两条根本对立的认识路线：\n  一条是坚持从物到感觉和思想的唯物主义认识路线。\n  另一条是坚持从思想和感觉到物的唯心主义认识路线。\n\n22.认识的本质（P71）\n  在认识的本质问题上，存在着两条根本对立的认识路线：\n  一条是坚持从物到感觉和思想的唯物主义认识路线；\n  另一条是坚持从思想和感觉到物的唯心主义认识路线。\n\n23.感性认识和理性认识的辩证统一关系（P74）\n\n  本知识点考查论述题\n\n\n  第一理性认识依赖于感性认识；\n  第二感性认识有待于发展和深化为理性认识；\n  第三感性认识和理性认识相互渗透相互包含\n  第四毛泽东说。我们的实践证明，感觉到了的东西，我们不能立刻理解它，只有理解了的东西才更深刻的感觉它。这段话形象的说明了感性认识上升为理性认识的重要性以及二者关系的交融性\n\n24.实践与认识的辩证运动规律（P77）\n\n  本知识点考查大题目\n\n\n  实践与认识的辩证运动是由一个感性认识到理性认识，又有理性认识，到实践的飞跃是实践认识再实践，再认识循环往复以至无穷的辩证发展过程。\n\n25.真理的一元性（P81）\n  真理的一元性是指在同一条件下，对于特定的认识客体的真理性认识只有一个，而不可能有多个\n\n26.真理的绝对性和相对性的含义（P81-82）\n  真理的绝对性真理的绝对性是指真理主客观统一的确定性和发展的无限性；\n  真理的相对性真理的相对性是指人们在一定条件下对客观事物及其本质和发展规律的正确认识总是有限度的，不完善的；\n\n27.真理与谬误的辩证关系（P85）\n\n  本知识点考查简答题\n\n\n  第一，真理与谬误相互对立；\n  第二，真理与谬误的对立又是相对的，它们在一定条件下能够相互转化。\n\n28.实践是检验真理的唯一标准（P87）\n  实践之所以能够作为检验真理的唯一标准，是由真理的本性和实践的特点决定的。\n\n29.价值的基本特性（P91-92）\n  第一，价值的主体性，价值的主体性是指价值直接与主体相联系，始终以主体为中心；\n  第二，价值的客观性，价值的客观性是指在一定条件下客体对于主体的意义不依赖于主体的主观意识而存在；\n  第三，价值的多维性，价值的多维性是指每个主体的价值，关系具有多样性，同一客体相对于主体的不同需要与会产生不同的价值；\n  第四，价值的社会历史性，主体和客体的不断变化决定了价值的社会历史性\n\n30.价值评价的特点（P92-94）\n\n  本知识点考查简答题\n\n\n  第一，评价与主客体的价值关系为认识对象；\n  第二，评价结果与评价主体直接相关；\n  第三，评价结果的正确与否依赖于客体状态和主体需要的认识；\n  第四，价值评价有科学与非科学之别。\n\n31.真理与价值在实践中的辩证统一（P95-96）\n  人们的实践活动总是受着真理尺度和价值尺度的制约。\n  任何实践活动都是在这两种尺度共同制约下进行的，任何成功的实践都是真理尺度和价值尺度的统一，是合规律性和合目的性的统一。\n  一方面价值尺度必须以真理为前提。\n  另一方面人类自身需要的内在尺度推动着人们不断发现新的真理。\n\n32.理论创新和实践创新的良性互动（P106-107）\n  实践创新为理论创新提供不竭的动力源泉；\n  理论创新为实践创新提供科学的行动指南；\n  努力实现理论创新与实践创新的良性互动。\n\n\n\n第三章\n33.自然地理环境在人类社会生存和发展中的重要作用（P112）\n  自然地理环境是指人类社会所处的地理位置相联系的自然条件的总和，是人类社会生存和发展永恒的必要的条件，是人们生活和生产的自然基础。\n\n34.物质生产方式（P113）\n  物质的生产方式是社会存在和发展的基础及决定力量。\n\n35.社会存在和社会意识的辩证关系（P116）\n\n  本知识点考查简答题（有待补充）\n\n\n  社会存在和社会意识是辩证统一的，社会存在决定社会意识，社会意识是社会存在的反映，并反作用于社会存在\n\n36.社会意识对社会存在具有能动的反作用（P117）\n  社会意识对社会存在具有能动的反作用，这是社会意识相对独立性的突出表现。\n\n37.生产力（P121）\n  劳动者是生产力中最活跃的因素\n\n38.经济基础与上层建筑的辩证关系（P127）\n  经济基础与上层建筑是辩证统一的，经济基础决定上层建筑，上层建筑反作用于经济基础，二者相互影响相互作用。\n\n39.社会形态更替的一般规律及特殊形式（P133-136）\n  社会形态的内涵；\n  社会形态更替的统一性和多样性\n  社会形态更替的必然性与人们的历史选择性；\n  社会形态更替的前进性和曲折性。\n\n40.社会革命在社会发展中的重要作用（P148）\n  革命对社会发展起巨大作用，“革命是历史的火车头”，是社会进步和政治进步的强大推动力。社会革命是实现社会形态根体的重要手段和决定性环节。\n\n41.改革在社会历史发展中的重要作用（P149）\n  在一定社会形态总的量变过程中，当社会基本矛盾发展到一定程度带有尚未激化到引起社会革命的程度时，就需要依靠改革的途径或手段来改变与生产力不相适应的生产关系和与经济基础不相适应的上层建筑。\n\n42.科学技术在社会发展中的作用（P151-153）\n\n  本知识点考查大题目\n\n\n  积极作用：每一次科技革命都不同程度地引起了生产方式，生活方式和思维方式的深刻变化和社会的巨大进步。首先对生产方式产生了深刻影响，其次对于生活方式产生了巨大影响，最后促进了思维方式的变革。\n\n  消极作用：例如工业的发展带来水和空气的污染，大规模的开垦和过度放牧，造成森林和草原的生态破坏。生命科学的发展提出了涉及人自身尊严，健康，遗传以及生态安全和环境保护等方面的伦理问题，基因工程可能导致基因歧视转基因食品的安全性和基因治疗克隆技术的适用范围等问题引起了人们高度关注。互联网可以迅速广泛的传播大量有用的信息，但也存在大量垃圾信息和虚假信息，并可能侵害国家安全，企业经营秘密以及个人隐私。\n\n  方法论要求：正确认识和运用科学技术：一，充分发挥其积极作用，努力创造条件，将消极作用转化为积极作用。二首要的就是有合理的社会制度，保障科学技术的正确运用，始终坚持使科学技术为人类社会的健康发展服务，让科学技术为人类造福\n\n43.两种历史观在历史创造者问题上的对立（P153）\n  唯物史观与唯心史观的对立，在历史创造者问题上表现为群众史观与英雄史观的对立。\n\n44.人民群众在创造历史过程中的决定作用（P157）\n  人民群众是社会物质财富的创造者，人民群众是社会精神财富的创造者，人民群众是社会改革的决定力量。\n\n45.群众路线（P159）\n  一切为了群众，一切依靠群众，从群众中来到群众中去。\n\n\n\n第四章\n46.商品及其二因素（P169-170）\n  商品是用来交换能满足人的某种需要的劳动产品，具有使用价值和价值两因素或两种属性。\n  价值是商品所持有的社会属性。\n\n47.商品价值量的决定（P171）\n  决定商品价值量的不是生产商品的个别劳动时间，而是社会必要劳动时间。\n\n48.价值规律的表现形式（P174）\n  商品经济中价值规律的表现形式是商品的价格围绕商品的价值自发的波动。\n\n49.资本原始积累的两个途径（P186）\n  一是用暴力手段剥夺农民的土地，二是用暴力手段掠夺货币财富。\n\n50.资本主义生产过程的两重性（P192）\n  资本主义生产过程具有二重性：\n  一方面生产物质资料的劳动过程；\n  另一方面是生产剩余价值的过程及价值增值过程。\n\n51.剩余价值的含义（P193）\n  剩余价值是雇佣工人所创造的，并被资本家无偿占有的，超过劳动力价值的那部分价值，他是雇佣工人劳动价值的凝结。\n\n52.资本主义的基本矛盾（P206）\n  生产社会化和生产资料资本主义私人占有之间的矛盾，是资本主义的基本矛盾。\n\n\n\n第五章\n53.资本主义发展的客观规律（P220）\n  自由竞争引起生产集中和资本集中生产集中和资本集中发展到一定阶段必然引起垄断，这是资本主义发展的客观规律。\n\n54.金融寡头对国家机器的控制（P223）\n  金融寡头对国家机器的控制主要是通过同政府的“个人联合”来实现的。\n\n55.垄断价格（P224）\n  垄断价格，包括垄断高价和垄断低价两种形式。\n\n56.国家垄断资本主义的含义（P225）\n  国家垄断资本主义是国家政权和私人垄断资本联合在一起的垄断资本主义。\n\n57.金融垄断资本得以形成和壮大的重要制度条件（P229）\n  金融自由化与金融创新是金融垄断资本得以形成和壮大的重要制度条件。\n\n58.经济全球化的表现（P235）\n  生产全球化，贸易全球化，金融全球化。\n\n59.第二次世界大战后，居主导地位的资本所有制形式（P240）\n  法人资本所有制崛起并成为居主导地位的资本所有制形式。\n\n60.第二次世界大战后资本主义发生变化的根本推动力量（P244）\n  科学技术革命和生产力的发展，是资本主义发生变化的根本推动力量\n\n\n\n第六章\n61.空想社会主义发展到高级阶段的三个代表人物（P259）\n  法国的圣西门、傅立叶和英国的欧文。\n\n62.社会主义从理想到现实的伟大飞跃（P265）\n  十月革命实现了社会主义从理想到现实的伟大飞跃。\n\n63.无产阶级是最先进最革命的阶级（P274）\n  无产阶级是最先进最革命的阶级，肩负着推翻资本主义旧世界、建立社会主义和共产主义新世界的历史使命。\n\n64.探索适合本国国情的发展道路（P290-291）\n  第一，探索社会主义发展道路，必须坚持对待马克思主义的科学态度。\n  第二，探索社会主义发展道路，必须坚持从当时当地的社会历史条件出发，坚持“走自己的路”。\n  第三，探索社会主义发展道路，必须充分吸收人类的一切文明成果。\n  发展社会主义不能照搬苏联社会主义的模式，照搬别国模式，从来不能成功，这是一个被历史反复证明了的颠扑不破的真理。\n\n\n\n第七章\n65.预见未来社会的方法论原则（P300-303）（多选）\n  在揭示人类社会发展一般规律的基础上指明社会发展的方向。\n  在剖析资本主义旧世界的过程中阐发未来新世界的特点。\n  在社会主义社会发展中不断深化对未来共产主义社会的认识。\n  立足于揭示未来社会的一般规律，而不对各种细节做具体描绘。\n\n66.共产主义社会个人消费品的分配方式（P306）\n  在共产主义社会，个人消费品的分配方式是“各尽所能，按需分配”。\n\n67.马克思主义追求的根本价值目标（P309）\n  实现人的自由而全面的发展是马克思主义追求的根本，价值目标也是共产主义社会的根本特征。\n\n68.实现共产主义是历史发展的必然（P312-313）\n  共产主义理想作为一种社会理想，是对人类社会发展规律认识的基础上，设想的社会目标。\n  遗产主义理想是一定会实现的，是以前的社会发展规律以及资本主义社会的基本矛盾发展为依据的。\n  社会主义运动的实践，特别是社会主义国家的兴起和不断发展已经并正在用事实证明共产主义理想实现的必然性。\n"
} ,
  
  {
    "title"    : "机器学习",
    "category" : "",
    "tags"     : " 机器学习, 期末考试, python",
    "url"      : "/machinelearning",
    "date"     : "December 9, 2022",
    "excerpt"  : "今天的人工智能主要依赖的不再是符号知识表示和程序推理机制，现代 AI 而是建立在新的基础上，即机器学习。无论是传统的基于数学的机器学习模型或决策树，还是深度学习的神经网络架构，当今人工智能领域的大多数 AI 应用程序都是基于机器学习技术。\n\n\n\n前言\n机器学习是智能专业的专核心课，其科目本身的难度较高，不论是在于理论层面还是代码实现层面都有一定的难度。想要征服机器学习还是一件非常具有挑战性的事情。\n\n本次博客整理了有关机器学习课程的期末考试重点，希望同学们可以获得一个好成绩。\n\n\n\n问题一...",
  "content"  : "今天的人工智能主要依赖的不再是符号知识表示和程序推理机制，现代 AI 而是建立在新的基础上，即机器学习。无论是传统的基于数学的机器学习模型或决策树，还是深度学习的神经网络架构，当今人工智能领域的大多数 AI 应用程序都是基于机器学习技术。\n\n\n\n前言\n机器学习是智能专业的专核心课，其科目本身的难度较高，不论是在于理论层面还是代码实现层面都有一定的难度。想要征服机器学习还是一件非常具有挑战性的事情。\n\n本次博客整理了有关机器学习课程的期末考试重点，希望同学们可以获得一个好成绩。\n\n\n\n问题一：有关拟合的问题\n什么是过拟合和欠拟合？\n\n过拟合是指模型在训练集上表现很好，到了验证和测试阶段就很差，即模型的泛化能力很差。\n欠拟合是指模型在训练集上表现的不好，以至于在验证和测试阶段表现的也比较差。\n\n如何解决过拟合与欠拟合？\n过拟合的解决方法：\n\n  重新调整一下参数和超参数。\n  对数据进行特征降维处理，有选择性的抛弃一些特征。\n  降低模型的复杂度。\n  使用正则化约束。\n\n\n欠拟合的解决方法：\n\n  增加模型的复杂度，例如使用神经网络代替线性回归、用随机森林代替决策树。\n  考虑选用更多更具有代表意义的特征的数据特征。\n  重新调整一下参数和超参数。\n  降低正则化约束。\n\n\n决策树如何防止过拟合\n剪枝。\n\n\n问题二：回归模型与分类模型的区别是什么？请举例说明。\n\n回归模型：是对连续变量，进行预测的模型，即回归问题是定量问题。\n回归模型问题的举例：对某城市房价预测、对某地区空气湿度的预测。\n\n分类模型：是对离散变量、进行预测的模型，即分类问题是定类问题。\n分类模型问题的举例：对明天是否下雨的预测、判断病人是否患有某种疾病的预测。\n\n\n问题三：机器学习的四大问题是什么？\n回归、分类、聚类、降维。\n\n\n问题四：机器学习的一般步骤。（需要以某一实物为例）\n回归问题以披萨价格预测为例。\n明确任务收集数据。\n在一定范围内的各个城市中随机选取若干家披萨店，作为初始数据。\n数据分析与预处理。\n将数据特征初步定为以下几项：\n\n比萨的尺寸、披萨的脂肪含量、披萨的制作成本、披萨的口味、披萨的品牌、披萨所在城市的GDP水平、生产披萨的披萨店的知名度。\n\n分析这些特征是否出现缺失值，对缺失值较多的特征直接删除。对缺失值较少的使用平均值填补定量的特征（例如披萨的脂肪含量），使用众数填补定类的特征（例如披萨的口味）。\n\n将定类数据数值化，方便后期计算。\n\n使用灰色关联分析法有选择性地剔除关联度较小的几个特征，即进行降维与特征选择处理。\n\n模型训练\n\n选择使用线性回归解决该回归问题。\n\n模型评估与参数调优\n\nR2评估，模型的优劣，当R2的值越接近1时模型性能越好。\n使用k折交叉验证方法选取出最佳的学习率等参数并再次进行模型训练。\n\n模型应用\n\n将训练模型保存下来，并公布用以推广。\n\n分类问题以肿瘤预测为例。\n明确任务收集数据。\n随机选取若干家医院的肿瘤病人数据作为初始数据\n\n数据分析与预处理。\n\n将数据特征初步定为以下几项：\n肿瘤的直径、体积、颜色、数量、肿瘤是否为良性、病人体温、病人是否出现炎症等信息。\n\n将肿瘤是否为良性作为目标列作为输出项并做数值化处理。\n\n分析这些特征是否出现缺失值，对缺失值较多的特征直接删除。对缺失值较少的使用平均值填补定量的特征（例如肿瘤的直径），使用众数填补定类的特征（例如病人是否出现炎症）。\n\n使用灰色关联分析法有选择性地剔除关联度较小的几个特征，即进行降维与特征选择处理。\n\n模型训练\n\n选择使用逻辑回归解决该分类问题。\n\n模型评估与参数调优\n\n使用AUC值评估模型的优劣，当R2的值越接近1时模型性能越好。\n使用k折交叉验证方法选取出最佳的激活函数的阈值等参数并再次进行模型训练。\n\n模型应用\n\n将训练模型保存下来，并公布用以推广。\n\n\n\n问题五：k折交叉验证的简述。\n\nk折交叉验证常用于参数调优，使得更容易训练出较高性能的模型。\n\nk折交叉验证的工作流程：\n\n  将训练集随机地进行k块、并选出其中1块作为验证集。\n  用其余k-1块的数据进行训练，并用验证集，计算出这一次的误差。\n  重复k次以上步骤，每次选取不同的块作为验证集\n  统计每一次计算得到的误差估计，并取平均值作为本次训练参数的最终指标。\n\n\n\n\n问题六：模型的评估标准\n回归问题的评估标准\n\n  MSE（均方误差） 预测残差的平方和，数值越小越好。\n  RMSE（平均绝对误差）是在MSE的基础上开根号计算得到，同样数值越小越好。\n  MAE（平均绝对误差）预测残差的绝对值之和，值越小越好。\n  R2 (R方分数)既考虑预测值与真值之间的差异又考虑问题本身与真值之间的差异。结果的约接近于1越好。\n    分类问题的评估标准\n  \n  正确率（Accuracy）即被预测正确的样本在所有预测样本中的占比。\n  召回率(TRR) 即在所有真的正类中被模型预测出来的比例。\n  AUC值：AUC的概率意义是随机取一对正负样本，正样本得分大于负样本得分的概\n AUC的范围在[0, 1]之间，并且越接近1越好，越接近0.5属于乱猜\n\n\n\n\n问题七：决策树的建立（以ppt为例）\n考察公式：\n\n信息熵公式：\\(H(X)=\\sum_{i=1}^{n}p_i log_2^{\\frac{1}{p_i}}=-\\sum_{i=1}^{n}p_i log_2{p_i}\\)\n信息增益公式：\\(Gain(D,a)=Ent(D)-Ent(d|a)=Ent(D)-\\sum_{v=1}^V \\frac{D_v}{D}Ent(D_v)\\)\n\n问题描述\n\n如下图，第一列为论坛号码，第二列为性别，第三列为活跃度，最后一列用户是否流失。\n\n\n    \n    \n        \n    \n    \n\n\n根据该图整理得到如下表格：\n\n\n    \n    \n        \n    \n    \n\n\n整体熵为多少\n\n\n    \n    \n        \n    \n    \n\n\n计算按照性别划分的信息增益\n\n要计算性别的信息增益需要先计算性别的信息熵\n\n\n    \n    \n        \n    \n    \n\n\n因此得到按照性别划分的信息增益为\n\n\n    \n    \n        \n    \n    \n\n\n计算按照活跃度划分的信息增益\n\n同样的，要计算活跃度的信息增益需要先计算活跃度的信息熵\n\n\n    \n    \n        \n    \n    \n\n\n因此得到按照活跃度划分的信息增益为：\n\n\n    \n    \n        \n    \n    \n\n\n比较两种特征对流失度的影响\n\n活跃度的信息增益比性别的信息增益大，也就是说，活跃度对用户流失的影响比性别大。\n\n做出决策树图形并说明理由\n\n根据第三问的分析，活跃度的信息增益比性别的信息增益大所以要选用，活跃度作为决策树的根节点。最终结果如下所示：\n\n\n    \n    \n        \n    \n    \n\n\n\n\n问题八：逻辑回归的优化目标函数是什么？交叉熵中的两个概率是分布什么？(不确定)\n\n逻辑回归的优化目标函数是:对数似然函数。 \n交叉熵的灵感概率是：真实分布，非真实分布。\n\n问题九：简述k近邻的算法流程，以及问题问题分析\n算法流程\n\n  计算距离：计算已知类别数据集中的点与当前点之间的距离\n2）排序：按距离递增次序排序\n3）选择：选取与当前点距离最小的k个点\n4）计算频次：统计前k个点所在的类别出现的频率\n5）确定类别：返回前k个点出现频率最高的类别作为当前点的预测分类\n\n\n计算题（以ppt为例）\n考察公式\n欧氏距离：平方和开根号 \n曼哈顿距离（城市街区距离）：绝对值的和\n\n提问\n假设我们现在有几部电影，如何去预测序号9电影的类别？\n\n\n    \n    \n        \n    \n    \n\n\n分别计算每个电影和被预测电影的距离，然后求解\n\n\n    \n    \n        \n    \n    \n\n\n所以最终结果预测为喜剧片。\n\n\n\n问题十：标准化与归一化问题（以PPT为例）\n归一化（重点）\n\n归一化定义：通过对原始数据进行变换把数据映射到(默认为[0,1])之间\n\n\n    \n    \n        \n    \n    \n\n\n作用于每一列，max为一列的最大值，min为一列的最小值，那么X’’为最终结果，mx，mi分别为指定区间值，默认mx为1，mi为0\n\n\n    \n    \n        \n    \n    \n\n\n标准化\n\n定义：通过对原始数据进行变换把数据变换到均值为0,标准差为1范围内\n\n\n    \n    \n        \n    \n    \n\n\n其中，它作用于每一列，mean为平均值，σ为标准差\n\n\n\n问题十一：k均值（k-means）聚类的算法\n流程\n\n  随机设置K个特征空间内的点作为初始的聚类中心\n  对于其他每个点计算到K个中心的距离，未知的点选择最近的一个聚类中心点作为标记类别\n  接着对着标记的聚类中心之后，重新计算出每个聚类的新中心点（平均值）\n  如果计算得出的新中心点与原中心点一样（质心不再移动），那么结束，否则重新进行第二步过程\n\n\n\n\n问题十二：梯度下降法\n梯度下降算法的作用：\n\n梯度下降法是一个优化算法，可以递归地找到模型的最小值，从而找到在最优参数。\n\n需要处理的问题：\n\n\n  学习率：需要在模型建立的速度和质量上做出权衡，学习率过大可能会导致最终结果不收敛，学习率过小会导致训练时间过长。\n  方向：计算出当前点的梯度方向，并向下不断更新自己的位置。\n  终止条件：考虑使用迭代次数、损失函数值到达一定范围之后终止。\n\n\n\n\n问题十三：逻辑回归（不确定）\n损失函数：\n\n\n    \n    \n        \n    \n    \n\n\n目标函数\n\n\n    \n    \n        \n    \n    \n\n\n定义：\n逻辑回归是机器学习中的一种分类模型，做二分类（1/0）任务，并给出相应概率。\nsigmoid函数\nsigmoid可以将数值压缩到[0,1]的范围内。\n\n\n\n问题十四：编程大题\n线性回归（以实验为例）\n\n\n  \n    \n      序号\n      直径（英寸）\n      价格（ 美元）\n    \n  \n  \n    \n      1\n      6\n      7\n    \n    \n      2\n      8\n      9\n    \n    \n      3\n      10\n      13\n    \n    \n      4\n      14\n      17.5\n    \n    \n      5\n      18\n      18\n    \n  \n\n\n该线性回归是一个几元函数，表达式是什么？\n是一个一元线性回归函数。\n表达式为：\\(f(x) = w_1x_1 + b\\)\n其中\\(w_1\\)表示的是“直径”特征的权重，\\(x_1\\)表示“直径”变量，\\(b\\)表示截距\n\n代码实现\nimport numpy as np\nimport pandas as pd\nfrom sklearn.linear_model import LinearRegression   # 最小二乘法线性回归\nfrom sklearn.model_selection import train_test_split\nimport matplotlib.pyplot as plt\n\nX_train_old = np.array([6,8,10,14,18]).reshape(5,1)\nY_train_old = np.array([7,9,13,17.5,18]).reshape(5,1)\nX_train_old,Y_train_old\n\n# 因为数据较少所以没必要再单独划出测试集了\nX_train,X_test,Y_train,Y_test = train_test_split(X_train_old,Y_train_old,random_state=33,test_size=0.2)\n# X_train,X_test,Y_train,Y_test = X_train_old,[],Y_train_old,[]\nX_train,X_test,Y_train,Y_test\n\nmodel = LinearRegression()\nmodel.fit(X_train,Y_train)\n\nT_sim1 = model.predict(X_test)\n\n\n逻辑回归（以实验为例）\n代码实现：\nimport pandas as pd\nimport numpy as np\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.linear_model import LogisticRegression\n\n# 1.获取数据\nnames = [&#39;Sample code number&#39;, &#39;Clump Thickness&#39;, &#39;Uniformity of Cell Size&#39;, &#39;Uniformity of Cell Shape&#39;,\n                   &#39;Marginal Adhesion&#39;, &#39;Single Epithelial Cell Size&#39;, &#39;Bare Nuclei&#39;, &#39;Bland Chromatin&#39;,\n                   &#39;Normal Nucleoli&#39;, &#39;Mitoses&#39;, &#39;Class&#39;]\ndata = pd.read_csv(r&quot;breast-cancer-wisconsin.data&quot;,names=names)\ndata.head()\n\nx_train, x_test, y_train, y_test = train_test_split(x, y, random_state=22)\nx_train.head()\n\nestimator = LogisticRegression()\nestimator.fit(x_train, y_train)\n\ny_predict = estimator.predict(x_test)\n\n问题十五：随机森林\n随机森林的算法流程（随机森林=Bagging+决策树）\n\n\n  随机选取m条数据\n  随机选取k个特征\n  训练决策树\n  重复1-3\n  对上面的若决策树进行平权投票\n\n\nbagging和boosting的区别\n\n区别一:数据方面\n\n  Bagging：对数据进行采样训练；\n  Boosting：根据前一轮学习结果调整数据的重要性。\n\n\n区别二:投票方面\n\n  Bagging：所有学习器平权投票；\n  Boosting：对学习器进行加权投票。\n\n\n区别三:学习顺序\n\n  Bagging的学习是并行的，每个学习器没有依赖关系；\n  Boosting学习是串行，学习有先后顺序。\n\n\n区别四:主要作用\n\n  Bagging主要用于提高泛化性能（解决过拟合，也可以说降低方差）\n  Boosting主要用于提高训练精度 （解决欠拟合，也可以说降低偏差）\n\n"
} ,
  
  {
    "title"    : "机器学习三大基础库",
    "category" : "",
    "tags"     : " 机器学习, python, numpy, pandas, matplotlib",
    "url"      : "/machine",
    "date"     : "December 6, 2022",
    "excerpt"  : "机器学习是研究怎样使用计算机模拟或实现人类学习活动的科学，是人工智能中最具智能特征，最前沿的研究领域之一。自20世纪80年代以来，机器学习作为实现人工智能的途径，在人工智能界引起了广泛的兴趣，特别是近十几年来，机器学习领域的研究工作发展很快，它已成为人工智能的重要课题之一。机器学习不仅在基于知识的系统中得到应用，而且在自然语言理解、非单调推理、机器视觉、模式识别等许多领域也得到了广泛应用。一个系统是否具有学习能力已成为是否具有“智能”的一个标志。\n\n\n\n前言\n\n本次博客主要内容为以下三个p...",
  "content"  : "机器学习是研究怎样使用计算机模拟或实现人类学习活动的科学，是人工智能中最具智能特征，最前沿的研究领域之一。自20世纪80年代以来，机器学习作为实现人工智能的途径，在人工智能界引起了广泛的兴趣，特别是近十几年来，机器学习领域的研究工作发展很快，它已成为人工智能的重要课题之一。机器学习不仅在基于知识的系统中得到应用，而且在自然语言理解、非单调推理、机器视觉、模式识别等许多领域也得到了广泛应用。一个系统是否具有学习能力已成为是否具有“智能”的一个标志。\n\n\n\n前言\n\n本次博客主要内容为以下三个python库\n\n  numpy\n  pandas\n  matplotlib\n\n\n前两个库numpy、pandas主要作用是对于数据存储与数据处理，并且广泛适用于很多机器学习的模型。而matplotlib是作图的好帮手，主要用户机器模型数据的可视化。\n\nnumpy（机器学习前缀知识）\n属性\n\n  数组的维数：对象名.ndim\n  数组的每个维度的数量：对象名.shape返回一个元组，元组中的数字表示该维度的长度。\n  元素总个数：对象名.size\n  成员的数据类型：对象名.dtype\n  矩阵的转置：对象名.T\n  对象名.flat 表示返回一个可以遍历所有元素的迭代器\n  numpy.nan 表示无穷\n  xxx\n\n\n功能型小函数\n\n\n  numpy.sum 求和\n  numpy.min 求最小值\n  numpy.max 求最大值\n  numpy.average 求平均值\n  numpy.median 求中位数\n  numpy.cumsum 返回前缀和向量\n  numpy.diff 返回一个差分数组（少一位）\n  numpy.argmin 求最小值的索引（从0开始计算）\n  numpy.argmax 求最大值的索引（从0开始计算）\n  numpy.nonzero返回n个向量，表示非元素所在位置的索引。\n  numpy.sort 返回对数组排序的结果，如果是多维则只会对一维排序（每一行）。\n  numpy.transpose 返回矩阵转置的结果\n  对象名.flatten() 返回该对象的一维展开（即变成一个行向量）\n  对象名.copy() 返回该对象的值拷贝（直接使用“=”是引用拷贝）注意不同于列表使用对象名[:]不能实现值拷贝，必须使用copy函数\n  numpy.random.randn 按正太分布的概率产生随机数数组\n  numpy.all(逻辑表达式) 逻辑表达式后半段 通过用这种方式将矩阵中所有数据参与计算返回一个bool判断矩阵中是不是所有元素都满足这个式子。\n  numpy.any(数组对象)逻辑表达式后半段 通过用这种方式将矩阵中所有数据参与计算返回一个bool判断矩阵中是否存在某个元素满足这个式子。\n\n\n示例（以numpy.sum为例）\n函数的默认计算区域是所有元素，当想要指定维度使用时需要使用axis来指定，axis从\n0开始计数。特别的对于一个矩阵来说，axis=0表示对每一列求和，axis=1表示对每一行求和。\n代码示例：\n\nimport numpy as np\n\na = np.arange(4).reshape(2,2)\nprint(a)\nprint(np.sum(a),np.sum(a,axis=1))\n\n程序运行截图：\n[[0 1]\n [2 3]]\n6 [1 5]\n\n\n矩阵索引\n以二维数组（矩阵）为例\n\n访问单元素的方法\na[i][j]，或 a[i,j]\n\n访问多元素的方法\n访问第i+1行的所有元素\na[i,:]\n访问第j+1列的所有元素\na[:,j]\n\n矩阵初始化 array\n函数签名：\narray(p_object, dtype=None, *args, **kwargs):\n\n上面的构造器接受以下参数：\n\n  object 任何暴露数组接口方法的对象都会返回一个数组或任何（嵌套）序列。\n  dtype 数组的所需数据类型，可选。\n  copy 可选，默认为true，对象是否被复制。\n  order C（按行）、F（按列）或A（任意，默认）。\n  subok 默认情况下，返回的数组被强制为基类数组。 如果为true，则返回子类。\n  ndmin 指定返回数组的最小维数。\n\n\n示例：\narray = numpy.array([[1,2,3],[4,5,6]].numpy.int64)\n\n滤波器clip\n\n函数签名：\ndef clip(a, a_min, a_max, out=None, **kwargs):\n\n将数组中小于a_min的值取a_min，将数组中大于a_max的值取a_max\n代码示例：\nimport numpy as np\n\na = np.arange(12)\n\nprint(np.clip(a,5,9))\n\n程序运行截图：\n[5 5 5 5 5 5 6 7 8 9 9 9]\n\n创建一个全1数组ones\n函数签名：\ndef ones(shape, dtype=None, order=&#39;C&#39;, *, like=None):\n\n示例：\nnumpy.noes((2,3,4)) # 创建一个2叶3行4列的全1矩阵\n\n\n创建一个全0数组zeros\n函数签名：\ndef zeros(shape, dtype=None, order=&#39;C&#39;, *args, **kwargs):\n\n\n示例：\nnumpy.zeros((2,3,4)) # 创建一个2叶3行4列的全0矩阵。\n\n\n创建有序数组arange\n函数签名：\ndef arange(start=None, *args, **kwargs):\n\n示例1（创建一个0~9的行向量）：\nnumpy.arange(10)\n\n程序输出：[0 1 2 3 4 5 6 7 8 9]\n\n示例2（创建一个5~9的行向量）：\nnumpy.arenge(5,10)\n\n程序输出：[5 6 7 8 9]\n\n示例3（创建一个以3为步长1~10的行向量）\nnumpy.arange(1,11,3)\n\n程序输出：[ 1  4  7  10]\n\n示例4（创建一个0~9的2行5列的矩阵）\nnumpy.arange(10).reshape(2,5) # 规模必须与元素个数相匹配\n\n程序输出：\n[[0 1 2 3 4]\n [5 6 7 8 9]]\n\n\n创建一个均匀划分的线段 linspace\n函数签名：\ndef linspace(start, stop, num=50, endpoint=True, retstep=False,type=None,axis=0):\n\n作用：以start为开始以stop结束以num为划分次数创建一个行向量。\n\n示例1（一般示例）：\nnumpy.linspace(0，10，2)\n\n程序输出：\n[ 0. 10.]\n\n示例2（重组元素为一个2*5的矩阵）\nnumpy.linspace(0,10,10).reshape(2,5)\n\n程序输出：\n[[ 0.          1.11111111  2.22222222  3.33333333  4.44444444]\n [ 5.55555556  6.66666667  7.77777778  8.88888889 10.        ]]\n\n\nnumpy的运算\n矩阵加减法：\n代码示例：\na = np.array([10,20,30,40])\nb = np.arange(1,5)\nprint(a-b)\nprint(a+b)\n\n程序运行截图：\n[ 9 18 27 36]\n[11 22 33 44]\n\n\n矩阵点乘：\n代码示例1（矩阵点乘）：\nimport numpy as np\n\na = np.array([10,20,30,40])\nb = np.arange(1,5)\nprint(a*b)\n\n程序运行截图：[ 10  40  90 160]\n\n代码示例2（矩阵乘数字）：\nimport numpy as np\n\na = np.array([10,20,30,40])\n\nprint(a*5)\n\n程序运行截图：[ 50 100 150 200]\n\n矩阵乘法：\n示例1（使用np.dot函数实现矩阵乘法）\n代码示例：\nimport numpy as np\n\na = np.arange(1,4).reshape(1,3)\nb = np.arange(1,4).reshape(3,1)\n\nc_dot = np.dot(a,b)\nd_dot = np.dot(b,a)\nprint(c_dot,d_dot,sep=&#39;\\n&#39;)\n\n程序运行截图：\n[[14]]\n[[1 2 3]\n [2 4 6] \n [3 6 9]]\n\n示例二（使用@符号实现矩阵乘法）：\n\n代码示例：\nimport numpy as np\n\na = np.arange(1,4).reshape(1,3)\nb = np.arange(1,4).reshape(3,1)\n\nprint(a@b,b@a,sep=&#39;\\n&#39;)\n\n程序运行截图：\n[[14]]\n[[1 2 3]\n [2 4 6]\n [3 6 9]]\n\n数组的逻辑判断：\n\n数组可以直接进行逻辑判断，其返回值为与元素组同规模的bool型结果数组。\n可以使用对象[逻辑表达式] 来过滤符合条件的项，返回一个行向量。\n\n代码示例：\nimport numpy as np\n\na = np.arange(10)\nprint(a &amp;lt; 3)\ns = np.random.random((4,4))\nprint(s[s &amp;gt; 0.5])\n\n程序运行截图：\n[ True  True  True False False False False False False False]\n[0.50784044 0.51138057 0.75612031 0.61457462 0.9712732  0.79497591]\n\n矩阵元素的函数运算：\n代码示例：\nimport numpy as np\n\na = np.arange(10)\nprint(np.sin(a))\n\n程序运行截图：\n[ 0.          0.84147098  0.90929743  0.14112001 -0.7568025  -0.95892427\n -0.2794155   0.6569866   0.98935825  0.41211849]\n\n\n创建一个元素值在0~1之间的随机矩阵\n示例（创建一个元素值在0~1之间的2行4列的随机矩阵）：\n代码示例：\nimport numpy as np\n\na = np.random.random((2,4))\n\nprint(a)\n\n程序运行截图：\n[[0.24853676 0.47803948 0.04436044 0.92552742]\n [0.61756337 0.31913713 0.83677922 0.51923448]]\n\n\n合并数组\n上下合并函数签名：\ndef vstack(tup):\n\n左右合并函数签名：\ndef hstack(tup):\n\n代码演示：\nimport numpy as np\n\na = np.array([1,2,3,4])\nb = np.array([4,3,5,8])\nprint(np.vstack((a,b)))\nprint(np.hstack((a,b)))\n\n程序运行截图：\n[[1 2 3 4]\n [4 3 5 8]]\n[1 2 3 4 4 3 5 8]\n\n数组分割 split or array_split\n等量数组分割 split\n\n函数签名：\ndef split(ary, indices_or_sections, axis=0):\n\n注意：axis表示对照切割的维度，例如对于矩阵而言axis=0表示横向切割，axis=1表示纵向切割，切割必须是对等切割否则报错。\n代码展示：\nimport numpy as np\n\nA = np.arange(12).reshape(3,4)\nprint(A)\nprint(&quot;纵向切割&quot;)\nprint(np.split(A,2,axis=1))\nprint(&quot;横向切割&quot;)\nprint(np.split(A,3,axis=0))\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n不等量数组分割 array_split\n函数签名：\ndef array_split(ary, indices_or_sections, axis=0):\n\n注意：这里与函数split最大的区别就是可以实现不等分的分法。前面等分，后面几项少分。\n代码展示：\nimport numpy as np\n\nA = np.arange(12).reshape(3,4)\n\nprint(A)\nprint(&quot;纵向切割&quot;)\nprint(np.array_split(A,3,axis=1))\nprint(&quot;横向切割&quot;)\nprint(np.array_split(A,2,axis=0))\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\npandas（机器学习前缀知识）\n属性\n\n  dtypes 获取所有列的数据格式\n  columns 获取所有列名\n  values 去除行名和列名，返回所有的内容，返回对象是numpy.ndarry。\n  T 获得矩阵的转置（列名和行名也会一起转）。\n    功能型小函数\n  \n  fillna(x) 将序列中出现的nan转变为x\n  isnull返回一个bool矩阵当原矩阵中该数值为nan时为true，非nan数据时为false。可以与numpy.any，numpy.all配套使用。\n  读取csv文件pd.read_csv(文件名)\n\n\n初始化矩阵\n创建矩阵 Series\n创建方式类似于numpy\n代码展示：\nimport pandas as pd\n\ns = pd.Series([1,3,6,44,1])\nprint(s)\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n定义有名称的数据 DataFrame\n说明：\nindex表示行标题，columns表示列标题，默认名称为从0开始的有序数列\n注意：每一行对应的数据数量要保持一致。\n示例1（使用序列创建）\n代码展示：\nimport pandas as pd\nmport numpy as np\ns = \nd.DataFrame(np.random.randn(3,4),index=[&#39;x&#39;,&#39;y&#39;,&#39;x&#39;],columns=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;])\nprint(s)\n\n程序运行截图:\n\n\n    \n    \n        \n    \n    \n\n\n示例2（使用字典创建）\n代码展示：\nimport pandas as pd\n\ns = pd.DataFrame({\n    &quot;a&quot;: [1,3],\n    &quot;b&quot;: [1.2,4],\n    &quot;c&quot;: [1.5,84],\n    &quot;d&quot;: [0.2,6]\n})\nprint(s)\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n数组访问\nloc （名称）表示法\n说明：\nloc[ [行名序列]，[列名序列] ]直接访问\nloc[ 行名序列i：行名序列j，列名序列i：列名序列j ]切片访问（切片是闭区间）\n\n两者可以混合使用。\n\n代码展示：\nimport pandas as pd\nimport numpy as np\n\ndates = pd.date_range(&#39;20221001&#39;, periods=6)\ns = pd.DataFrame(np.random.randn(6, 4), index=dates, columns=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])\n\nprint(s)\nprint(&#39;单个数据访问&#39;,s.loc[&quot;20221002&quot;,&#39;a&#39;],sep=&#39;\\n&#39;)\nprint(&#39;多行单列&#39;,s.loc[[&#39;20221002&#39;,&#39;20221001&#39;],&#39;b&#39;],sep=&#39;\\n&#39;)\nprint(&#39;单行多列&#39;,s.loc[&#39;20221002&#39;,[1,2]],sep=&#39;\\n&#39;)\nprint(&#39;多行多列&#39;,s.loc[[&#39;20221002&#39;,&#39;20221001&#39;],[&#39;a&#39;,&#39;b&#39;]],sep=&#39;\\n&#39;)\nprint(&#39;多行多列切片访问&#39;,s.loc[&#39;20221001&#39;:&#39;20221002&#39;,[&#39;a&#39;,&#39;b&#39;]],sep=&#39;\\n&#39;)\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\niloc（下标）表示法\n说明：\n使用方式等同于loc但是序列名变成了索引号（从0开始计数）（不同于loc的是使用切片表示法时是左开右闭区间）\n代码展示：\nimport pandas as pd\nimport numpy as np\n\ndates = pd.date_range(&#39;20221001&#39;, periods=6)\ns = pd.DataFrame(np.random.randn(6, 4), index=dates, columns=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])\n\nprint(s)\nprint(&#39;单个数据访问&#39;,s.iloc[1,1],sep=&#39;\\n&#39;)\nprint(&#39;多行单列&#39;,s.iloc[0:3,3],sep=&#39;\\n&#39;)\nprint(&#39;单行多列&#39;,s.iloc[0,0:3],sep=&#39;\\n&#39;)\nprint(&#39;多行多列&#39;,s.iloc[0:2,[0,3]],sep=&#39;\\n&#39;)\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n访问一列\n访问方式：\n\n对象名[列名]（适用于所有情况的访问方式）\n对象名.列名（这种访问方式仅适用于标题为字符串型的情况）\n\n代码展示：\nimport pandas as pd\nimport numpy as np\ndates = pd.date_range(&#39;20221001&#39;, periods=6)\ns = pd.DataFrame(np.random.randn(6, 4), index=dates, columns=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])\nprint(s)\nprint(s[&#39;a&#39;])\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n访问一行数据 loc\n代码展示：\nimport pandas as pd\nimport numpy as np\n\ndates = pd.date_range(&#39;20221001&#39;, periods=6)\ns = pd.DataFrame(np.random.randn(6, 4), index=dates, columns=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])\n\nprint(s)\nprint(s.loc[&quot;20221002&quot;])\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n访问多行数据\n\n多行数据直接访问语法：\n对象名[start:end] 这里的start、end既可以是数字用于表示序列的索引，当行名不是整数型时也可以直接使用行名（行名可以是字符串）\n\n数组修改\n说明：\n与赋值相似，对已存在的数值进行修改就是修改，对不存在的数据就是添加可以通过修改不存在的行列使得数据的行列增加（未知数据用NAN代替）\n代码展示：\nimport pandas as pd\nimport numpy as np\n\ndates = pd.date_range(&#39;20221001&#39;, periods=6)\ns = pd.DataFrame(np.random.randn(6, 4), index=dates, columns=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])\nprint(s)\nprint(&quot;修改数值&quot;)\ns.a[s.a &amp;lt; 0] = 0\nprint(s)\nprint(&quot;增加行&quot;)\ns.loc[&#39;new_index&#39;] = np.nan\nprint(s)\nprint(&quot;增加列&quot;)\ns.loc[:,&quot;new_columns&quot;] = np.array([0,1,2,3,4,5,6])\nprint(s)\nprint(&quot;同时增加行和列&quot;)\ns.loc[8,&#39;f&#39;] = np.nan\nprint(s)\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n删除行列 dropna\n说明：\n\naxis = 0 时表示删除行，1表示删除列\n\nhow参数有两个值：\n\n\n  “any”：如果存在任何NAN值，则删除该行或列。\n  “all”：如果所有值都为NAN值，则删除该行或列。\n\n\n注意：dropna 只是返回修改后的结果不会改变原本的值\n代码展示：\nimport pandas as pd\nimport numpy as np\n\ndates = pd.date_range(&#39;20221001&#39;, periods=6)\ns = pd.DataFrame(np.random.randn(6, 4), index=dates, columns=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])\n\nprint(s)\ns.iloc[0,0] = np.nan\ns.iloc[2] = np.nan\ns.iloc[:,3] = np.nan\nprint(s)\nprint(&quot;axis == 0 时表示删除行，1表示删除列&quot;)\ns = s.dropna(axis=0,how=&#39;all&#39;)\nprint(s)\ns = s.dropna(axis=1,how=&#39;all&#39;)\nprint(s)\ns = s.dropna(axis=0,how=&#39;any&#39;)\nprint(s)\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n读写excle文件 read_excle or .to_excle\n注意：\n\nread_excle 得到的是一个pandas对象，之前数据访问修改删除等操作依然成立。\nto_excle创建时会添加一列行名，可以使用index=False 去除行名的添加。\n脚本编程\n逻辑表达式筛选：\n\n使用对象名[逻辑表达式]方式筛选。\n代码展示：\nimport pandas as pd\nimport numpy as np\n\ndates = pd.date_range(&#39;20221001&#39;, periods=6)\ns = pd.DataFrame(np.random.randn(6, 4), index=dates, columns=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])\nprint(s)\nprint(&#39;第0列数据大于0的数据有：&#39;)\nprint(s[s.iloc[:,0] &amp;gt; 0])\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n数据分析 describe\n代码展示：\nimport pandas as pd\n\ns = pd.DataFrame({\n    &quot;a&quot;: [1,3],\n    &quot;b&quot;: [1.2,4],\n    &quot;c&quot;: [1.5,84],\n    &quot;d&quot;: [2,6.2]\n})\nprint(s.describe(),sep=&#39;\\n&#39;)\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n排序 sort_index &amp;amp; sort_values\nsort_index 对行列名排序\n说明：\naxis = 0表示对行名进行排序，1表示对列名进行排序。\n排序默认升序排序，当ascending = True 表示倒序排序\n函数签名：\ndef sort_index(\n    self,\n    axis: Axis = 0,\n    level: Level | None = None,\n    ascending: bool | int | Sequence[bool | int] = True,\n    inplace: bool = False,\n    kind: str = &quot;quicksort&quot;,\n    na_position: str = &quot;last&quot;,\n    sort_remaining: bool = True,\n    ignore_index: bool = False,\n    key: IndexKeyFunc = None,\n):\n\n代码展示：\nimport pandas as pd\ns = pd.DataFrame({\n    &quot;a&quot;: [1, 3],\n    &quot;b&quot;: [1.2, 4],\n    &quot;c&quot;: [1.5, 84],\n    &quot;d&quot;: [2, 6.2]\n})\nprint(s.sort_index(axis=0, ascending=False), sep=&#39;\\n\\n&#39;)\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\nsort_values对数据列排序\n函数签名：\ndef sort_values(  # type: ignore[override]\n    self,\n    by,\n    axis: Axis = 0,\n    ascending=True,\n    inplace: bool = False,\n    kind: str = &quot;quicksort&quot;,\n    na_position: str = &quot;last&quot;,\n    ignore_index: bool = False,\n    key: ValueKeyFunc = None,\n):\n\n代码展示：\nimport pandas as pd\n\ns = pd.DataFrame({\n    &quot;a&quot;: [1, 3],\n    &quot;b&quot;: [1.2, 4],\n    &quot;c&quot;: [1.5, 84],\n    &quot;d&quot;: [2, 6.2]\n})\n\nprint(s.sort_values(&#39;a&#39;,ascending=False))\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n合并数组 merge\n说明：\nhow 有4个取值：inner（默认）、outer、left、right 分别表示内连接、外连接、左外连接、右外连接。\non 表示连接是使用的列（类似于外键）\nindictor == True时，在结果列中增加一列以显示每一个数据连接的方式默认为False，可以给indictor赋予字符串，以表示新列的名称\nleft_\tindex &amp;amp; right_index同时为True时可以按行名合并，默认都为False，两者必须同为True才能生效。\nsuffixex当给其一个包含两个字符串的元组时，合并时若出现同名字段，则会加上这两个字符串后缀。\n函数签名：\ndef merge(\n    left: DataFrame | Series,\n    right: DataFrame | Series,\n    how: str = &quot;inner&quot;,\n    on: IndexLabel | None = None,\n    left_on: IndexLabel | None = None,\n    right_on: IndexLabel | None = None,\n    left_index: bool = False,\n    right_index: bool = False,\n    sort: bool = False,\n    suffixes: Suffixes = (&quot;_x&quot;, &quot;_y&quot;),\n    copy: bool = True,\n    indicator: bool = False,\n    validate: str | None = None,\n) -&amp;gt; DataFrame:\n\n\n案例演示\n示例1（依照指定列进行合并）：\n代码演示：\nimport numpy as np\nimport pandas as pd\n\nleft = pd.DataFrame({\n    &#39;key&#39;: [&#39;K0&#39;, &#39;k1&#39;, &#39;k2&#39;, &#39;k3&#39;],\n    &#39;A&#39;: [&#39;A0&#39;, &#39;A1&#39;, &#39;A2&#39;, &#39;A3&#39;],\n    &#39;B&#39;: [&#39;B0&#39;, &#39;B1&#39;, &#39;B2&#39;, &#39;B3&#39;]\n})\n\nright = pd.DataFrame({\n    &#39;key&#39;:[&#39;K0&#39;, &#39;k1&#39;, &#39;k2&#39;, &#39;k3&#39;],\n    &#39;C&#39;:[&#39;C0&#39;,&#39;C1&#39;,&#39;C2&#39;,&#39;C2&#39;],\n    &#39;D&#39;:[&#39;D0&#39;,&#39;D1&#39;,&#39;D2&#39;,&#39;D3&#39;]\n})\n\nprint(left)\nprint(right)\nres = pd.merge(left,right,on=&#39;key&#39;)\nprint(res)\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n示例2依照多列进行合并\n代码演示：\nimport numpy as np\nimport pandas as pd\n\nleft = pd.DataFrame({\n    &#39;key1&#39;: [&#39;K0&#39;, &#39;k0&#39;, &#39;k1&#39;, &#39;k2&#39;],\n    &#39;key2&#39;: [&#39;K0&#39;, &#39;k1&#39;, &#39;k0&#39;, &#39;k1&#39;],\n    &#39;A&#39;: [&#39;A0&#39;, &#39;A1&#39;, &#39;A2&#39;, &#39;A3&#39;],\n    &#39;B&#39;: [&#39;B0&#39;, &#39;B1&#39;, &#39;B2&#39;, &#39;B3&#39;]\n})\n\nright = pd.DataFrame({\n    &#39;key1&#39;: [&#39;K0&#39;, &#39;k1&#39;, &#39;k1&#39;, &#39;k2&#39;],\n    &#39;key2&#39;: [&#39;K0&#39;, &#39;k0&#39;, &#39;k0&#39;, &#39;k0&#39;],\n    &#39;C&#39;: [&#39;C0&#39;, &#39;C1&#39;, &#39;C2&#39;, &#39;C2&#39;],\n    &#39;D&#39;: [&#39;D0&#39;, &#39;D1&#39;, &#39;D2&#39;, &#39;D3&#39;]\n})\n\nprint(left)\nprint(right)\n# how = [&#39;left&#39;,&#39;right&#39;,&#39;inner&#39;,&#39;outer&#39;]\nprint(&#39;内连接&#39;)\nprint(pd.merge(left, right, on=[&#39;key1&#39;,&#39;key2&#39;],how=&#39;inner&#39;))\nprint(&#39;全外连接&#39;)\nprint(pd.merge(left, right, on=[&#39;key1&#39;,&#39;key2&#39;],how=&#39;outer&#39;))\nprint(&#39;左外连接&#39;)\nprint(pd.merge(left, right, on=[&#39;key1&#39;,&#39;key2&#39;],how=&#39;left&#39;))\nprint(&#39;右外连接&#39;)\nprint(pd.merge(left, right, on=[&#39;key1&#39;,&#39;key2&#39;],how=&#39;right&#39;))\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n示例3（显示每一列的合并方式）\n代码演示：\nimport pandas as pd\ndf1 = pd.DataFrame({&#39;col1&#39;:[0,1],&#39;col_left&#39;:[&#39;a&#39;,&#39;b&#39;]})\ndf2 = pd.DataFrame({&#39;col1&#39;:[1,2,2],&#39;col_right&#39;:[2,2,2]})\nprint(df1)\nprint(df2)\nres = pd.merge(df1,df2,on=&#39;col1&#39;,indicator=True,how=&#39;outer&#39;)\nprint(res)\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n示例4（依照行名进行合并）\n代码演示：\nimport pandas as pd\nleft = pd.DataFrame({\n    &#39;A&#39;:[&#39;A0&#39;,&#39;A1&#39;,&#39;A2&#39;],\n    &#39;B&#39;:[&#39;B0&#39;,&#39;B1&#39;,&#39;B2&#39;]},\n    index=[&#39;K0&#39;,&#39;K1&#39;,&#39;K2&#39;])\nright = pd.DataFrame({\n    &#39;C&#39;:[&#39;C0&#39;,&#39;C2&#39;,&#39;C3&#39;],\n    &#39;D&#39;:[&#39;D0&#39;,&#39;D2&#39;,&#39;D3&#39;]},\n    index=[&#39;K0&#39;,&#39;K2&#39;,&#39;K3&#39;])\nprint(left)\nprint(right)\nres = pd.merge(left,right,right_index=True,left_index=True,how=&#39;outer&#39;)\nprint(res)\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n示例5（同名字段加后缀）\n代码演示：\nimport pandas as pd\nboys = pd.DataFrame({&#39;k&#39;: [&#39;K0&#39;, &#39;k1&#39;, &#39;k2&#39;], &#39;age&#39;: [1, 2, 3]})\ngirls = pd.DataFrame({&#39;k&#39;: [&#39;K0&#39;, &#39;K1&#39;, &#39;K2&#39;], &#39;age&#39;: [4, 5, 6]})\nprint(boys)\nprint(girls)\nres = pd.merge(boys,girls,on=&#39;k&#39;,suffixes=(&#39;_boy&#39;,&#39;_girl&#39;),how=&#39;outer&#39;)\nprint(res)\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n合并数组 concat\n说明：\naxis == 0(默认) 表示竖向的合并，1表示横向合并\nignore == True表示纵向合并时忽略原行序列从新有序定义行标号，默认False\njoin 表示纵向连接方式默认为outer外连接（默认），还可以选择 inner 内连接\n注意：当竖向合并时，列名不一致（不包括次序不一致）将产生新列（全外连接）\n\n示例1\n代码展示：\nimport pandas as pd\nimport numpy as np\n\ndf1 = pd.DataFrame(np.ones((3,4))*0,columns=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;])\ndf2 = pd.DataFrame(np.ones((3,4))*1,columns=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;])\ndf3 = pd.DataFrame(np.ones((3,4))*2,columns=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;])\n\nprint(pd.concat([df1,df2,df3],axis=0,ignore_index=True))\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n示例2（纵向连接，两种连接的比较）\n代码演示：\nimport pandas as pd\nimport numpy as np\n\ndf1 = pd.DataFrame(np.ones((3,4))*0,index=[1,2,3],columns=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;])\ndf2 = pd.DataFrame(np.ones((3,4))*1,index=[2,3,4],columns=[&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;])\n\nprint(pd.concat([df1,df2],axis=0,join=&#39;outer&#39;))\nprint(pd.concat([df1,df2],axis=0,join=&#39;inner&#39;))\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n示例三（横向连接的4种方式比较）\n注意：\n代码演示：\nimport pandas as pd\nimport numpy as np\n\ndf1 = pd.DataFrame(np.ones((3,4))*0,index=[1,2,3],columns=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;])\ndf2 = pd.DataFrame(np.ones((3,4))*1,index=[2,3,4],columns=[&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;])\nprint(&quot;全外连接&quot;)\nprint(pd.concat([df1,df2],axis=1))\nprint(&quot;左外链接&quot;)\nprint(pd.concat([df1,df2.reindex(df1.index)],axis=1))\nprint(&quot;右外连接&quot;)\nprint(pd.concat([df2,df1.reindex(df2.index)],axis=1))\nprint(&quot;内连接&quot;)\nprint(pd.concat([df2.reindex(df1.reindex(df2.index).index)],axis=1))\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n数据筛选query\nDataFrame.query(expr, inplace=False, **kwargs)，用于通过boolean表达式来查询dataframe中的列。\n主要参数为expr，它是字符串表达式，有如下说明：\n\n可以引用变量，方法是在变量前添加一个@字符，例如@a + b。\n可以在反引号内将包含空格或运算符的列名引用起来。 这样，您还可以转义以数字开头或Python关键字的名称。 基本上是无效的Python标识符。\n\nmatplotlib（图像绘制）\n\n函数应用\n函数签名：\ndef plot(*args, scalex=True, scaley=True, data=None, **kwargs):\n\n\n\n  x: 横坐标，可选的， 默认为 range(len(y))\n  y: 纵坐标，即数据项，可以是一维或多维的列表或数组\n  markersize: 标记大小\n  color: 线条颜色\n  marker: 数据标记的形状，默认是没有标记\n  linestyle: 线条样式，默认为实线\n代码演示：\n\n\nimport matplotlib.pyplot as plt\n\nx = [1, 2, 3]\ny = [1, 2, 3]\n# 以下两种写法等价，\nplt.plot(x, y, color=&#39;green&#39;, marker=&#39;o&#39;, linestyle=&#39;dashed&#39;, linewidth=2, markersize=12)\n# plt.flot(x, y, &#39;go--&#39;，linewidth=2, markersize=12)\n# 可以在一个画布上绘制多张图片，\ny1 = [4, 5, 6]\nplt.plot(x, y1, color=&#39;red&#39;, marker=&#39;*&#39;, linestyle=&#39;solid&#39;, linewidth=2, markersize=12)\nplt.show()\n\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n重要示例\n\n示例1（创建4个折线图）\n说明：使用plot实现，其中show函数主要实现图像的展示工作。\n代码演示：\n\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndata = pd.DataFrame(np.random.randn(1000,4),index=np.arange(1000),columns=list(&quot;ABCD&quot;))\n\ndata = data.cumsum()    # 累加\ndata.plot()\nplt.show()\n\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n示例二（创建2个散点图）\n代码演示：\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndata = pd.DataFrame(np.random.randn(1000,4),index=np.arange(1000),columns=list(&quot;ABCD&quot;))\ndata = data.cumsum()    # 累加\nax = data.plot.scatter(x=&#39;A&#39;,y=&#39;B&#39;,color=&#39;DarkBlue&#39;,label=&quot;Class 1&quot;)\ndata.plot.scatter(x=&#39;A&#39;,y=&#39;C&#39;,color=&#39;DarkGreen&#39;,label=&quot;Class 2&quot;,ax=ax)\nplt.show()\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n日常问题\n图形中文乱码\n\n解决方法：更改字体防止图形乱码\nfrom matplotlib import pyplot as pl\npl.rcParams[&#39;font.sans-serif&#39;] = [&#39;SimHei&#39;]\n\n"
} ,
  
  {
    "title"    : "python 多线程与多进程",
    "category" : "",
    "tags"     : " python, 多线程, 多进程",
    "url"      : "/process",
    "date"     : "December 5, 2022",
    "excerpt"  : "进程是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。线程是进程中的一部分，也是进程的的实际运作单位，它也是操作系统中的最小运算调度单位。\n\n\n前言\n多线程与多进程还是比较实用的。本博客以应用为目的展示两个基础的类。\n\n多进程 Process\n\nprocess模块是一个创建进程的模块，借助这个模块，就可以完成进程的创建。\nfrom multiprocessing import Process\n\n参数介绍\nProcess(group=N...",
  "content"  : "进程是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。线程是进程中的一部分，也是进程的的实际运作单位，它也是操作系统中的最小运算调度单位。\n\n\n前言\n多线程与多进程还是比较实用的。本博客以应用为目的展示两个基础的类。\n\n多进程 Process\n\nprocess模块是一个创建进程的模块，借助这个模块，就可以完成进程的创建。\nfrom multiprocessing import Process\n\n参数介绍\nProcess(group=None, target=None, name=None, args=(), kwargs={})\n\n\n\n  group——参数未使用，值始终为None\n  target——表示调用对象，即子进程要执行的任务\n  args——表示调用对象的位置参数元组，args=(1,2,’egon’,)\n  kwargs——表示调用对象的字典，kwargs={‘name’:’egon’,’age’:18}\n  name——为子进程的名称\n\n\n方法介绍\n\n  obj.start()：启动进程，并调用该子进程中的obj.run()\n  obj.run()：进程启动时运行的方法，正是它去调用target指定的函数，我们自定义类的类中一定要实现该方法\n  obj.terminate()：强制终止进程obj，不会进行任何清理操作，如果obj创建了子进程，该子进程就成了僵尸进程，使用该方法需要特别小心这种情况。如果obj还保存了一个锁那么也将不会被释放，进而导致死锁\n  obj.is_alive()：如果obj仍然运行，返回True\n  obj.join([timeout])：主线程等待obj终止（强调：是主线程处于等的状态，而obj是处于运行的状态）。timeout是可选的超时时间，需要强调的是，obj.join只能join住start开启的进程，而不能join住run开启的进程\n\n\n属性介绍\n\n  obj.daemon：默认值为False，如果设为True，代表obj为后台运行的守护进程，当obj的父进程终止时，obj也随之终止，并且设定为True后，obj不能创建自己的新进程，必须在\n  obj.start()：之前设置\n  obj.name：进程的名称\n  obj.pid：进程的pid\n  obj.exitcode：进程在运行时为None、如果为–N，表示被信号N结束(了解即可)\n  obj.authkey：进程的身份验证键,默认是由os.urandom()随机生成的32字符的字符串。这个键的用途是为涉及网络连接的底层进程间通信提供安全性，这类连接只有在具有相同的身份验证键时才能成功（了解即可）\n\n\n使用案例\nfrom multiprocessing import Process\nimport os\n\ndef worker(arg):\n    # 返回父子进程的pid\n    print(os.getpid(), os.getppid())\n\n\nif __name__ == &quot;__main__&quot;:\n    print(&#39;I am parent process&#39;)\n    jobs = []\n    for i in range(5):\n        p = Process(target=worker, args=(i,))\n        jobs.append(p)\n        p.start()\n\n方法介绍\n\n\n    \n    \n        \n    \n    \n\n\n使用样例\n利用函数使用多线程\nfrom threading import Thread\na = 0\ndef work():\n    global a\n    a += 1\n    print(a，end=’’)\n\nif __name__ == &#39;__main__&#39;:\n    childs = []\n    for i in range(5):\n        childs.append(Thread(target=work))\n        childs[-1].start()\n\n\n程序运行结果：\n1 2 3 4 5\n如果创建的不是线程而是进程则资源不会共享，运行结果会是：\n1 1 1 1 1\n\n利用类重写Thrrad方法实现多线程\nfrom threading import Thread\nimport time\nnum = 0\nchilds = []\nclass MyThread(Thread):\n    def run(self):\n        self.t = num\n\n        for _ in range(3):\n            print(self.t, &#39;线程正在工作&#39;)\n            time.sleep(0.5)\n\n\nfor i in range(3):\n    num = i + 1\n    childs.append(MyThread())\n    childs[-1].start()\n\n运行结果之一：\n1 线程正在工作\n2 线程正在工作\n3 线程正在工作\n132 线程正在工作 线程正在工作 \n线程正在工作\n\n13 线程正在工作\n2 线程正在工作\n 线程正在工作\n\n可以看到输出十分的杂乱，说明确实是多线程输出。\n"
} ,
  
  {
    "title"    : "OpenStack",
    "category" : "",
    "tags"     : " OpenStack, 期末考试",
    "url"      : "/openstack",
    "date"     : "December 4, 2022",
    "excerpt"  : "OpenStack是Rackspace和NASA共同成立的一个开源项目，它是为云计算服务的，提供存储空间、计算能力等资源服务的Web Service。简单来说，OpenStack就是一个操作系统，一套软件，一套IaaS（基础设施即服务）软件，对资源进行管理，并且以服务的形式提供给上层应用或者用户去使用。\n\n\n\n前言\n\n以下为openstack的期末复习，考试考点整理，内容比较多且知识点生僻难懂，请好好准备，祝愿各位可以在期末获取一个好成绩！\n\n\n\n第一章考点\n什么是云计算\n云计算是一种把计...",
  "content"  : "OpenStack是Rackspace和NASA共同成立的一个开源项目，它是为云计算服务的，提供存储空间、计算能力等资源服务的Web Service。简单来说，OpenStack就是一个操作系统，一套软件，一套IaaS（基础设施即服务）软件，对资源进行管理，并且以服务的形式提供给上层应用或者用户去使用。\n\n\n\n前言\n\n以下为openstack的期末复习，考试考点整理，内容比较多且知识点生僻难懂，请好好准备，祝愿各位可以在期末获取一个好成绩！\n\n\n\n第一章考点\n什么是云计算\n云计算是一种把计算机基础资源经过重组后给用户使用的一系列相关服务。\n\n云计算架构对应几种架构模式以及概念\nIaaS（基础设施即服务）\nPaaS（平台即服务）\nSaaS（软件即服务）\n\nOpenStack 的主要项目以及对应的项目名称\n\n\n  \n    \n      服务\n      直译\n      项目名称\n    \n  \n  \n    \n      Dashboard\n      仪表盘\n      Horizon\n    \n    \n      Computer\n      计算\n      Nova\n    \n    \n      Natwork\n      网络\n      Neutron\n    \n    \n      Object Storage\n      对象存储\n      Swift\n    \n    \n      Block Storage\n      块存储\n      Cindar\n    \n    \n      Identity\n      身份\n      Keystone\n    \n    \n      Image\n      镜像\n      Glance\n    \n    \n      Telemetry\n      计量\n      Ceilometer\n    \n    \n      Orchestration\n      编排\n      Heat\n    \n    \n      Database\n      数据库\n      Trove\n    \n    \n      Data Processing\n      数据处理\n      Sahara\n    \n  \n\n\n\n\n第二章考点\n网络配置流程\n\n\n  进入网络配置的文件：vi  /etc/sysconfig/netwrok-scripts/ifcfg-ens33\n  修改BOOTPROTO的值为static \n  修改ONBOOT的值为yes\n  添加配置4条信息：IPADDR NETNASK GATEWAY DNS1\n  键入qw保存并退出配置文件\n  输入：systemctl restart network 重启network服务。\n\n\nopenstack的安装\n\n\n  安装openstack-packstack以及其依赖包：yum install -y openstack-packstack\n  安装openstack：packstack --allinone\n  进入文件查看生成的初始密码配置：vi /etc/my.cnf.d/server.cnf\n\n\n\n\n第三章考点\n\n数据库\n1.数据库验证\n验证方式：systemctl status sqlname\n\n2. 数据库有哪些\nNoSQL数据库：MongoDB Memcached Redis\nSQL数据库：MySQL Maria PostgreSQL\n\n消息队列\n什么是消息队列\n消息队列是一种应用程序对应用程序的通信方法。消息传递指的是程序之间通过打消良中发送数却进行通信,而不是通过百捉调用彼此来通信。\n\n消息队列实现的协议以及对应的软件\n协议：AMQP\n软件：RabbitMQ\n\n\n\n第四章考点\n\nREST 含义解释\nRESTFUL是一种网络应用程序的设计风格和开发方式，是我们用http调用资源的时候的统一接口的访问形式，用自己的话说就是把对资源的调用转化到一种表现方式上来，例如开发的时候使用微信小程序表现可以避免用不同的语言开发app应用\n\n调用OpenStack API的四种方式\n\n  cURL \n  OpenStack命令行客服端\n  REST客户端\n  OpenStack的Python SDK\n\n\nOpenStack 的认证与API 请求流程\n\n\n  向云管理员提供的身份端点请求一个认证令牌。\n  如果请求成功，服务器会返回一个认证令牌。\n  发送API请求，并在X-Auth-Token头部包括上一步返回的认证令牌。可以一直使用这个令牌发送API请求，直到服务完成该请求，或者出现未授权(401)的错误。\n  如果遇到未授权（401）的错误，则需要重新请求另一个令牌。\n\n\n获取OpenStack认证令牌\n\n\n  进入demo环境：source keystonerc_demo\n  运行命令cURL来请求一个令牌。\n\n\n发送API请求\n\n\n  设置OS_TOKEN环境变量，将其值设为令牌ID： export OS_TOKEN=令牌ID\n  设置OS_PROJECT_NAME环境变量：export OS_PROJECT_NAME=demo\n  设置OS_COMPUTE_API环境变量：export OS_COMPUTE_API=http://192.168.199.21:8774/v2.1\n  使用Compute API列出示例类型：curl -s -H &quot;X-Auth-Token: $OS_TOKEN&quot; $os_COMPUTE_API/flavors lpython -m json.tool。\n\n\n\n第五章\n\nKeystone的管理层次结构\n\n\n    \n    \n        \n    \n    \n\n\n问：在一个域中的用户User1是否可以管理项目Project1\n\n答：可以，因为用户User1是系统管理员，拥有对项目Project1的管理权限。\n\n\nKeystone认证流程图\n这张图需要背下来。\n\n\n    \n    \n        \n    \n    \n\n\n对图片的解释：\n\n\n  用户向Keystone提供凭证，Keystone验证通过后向用户返回令牌的同时还会返回一个通用目录。\n  用户使用该令牌向该目录列表中的端点请求该用户对应的项目信息，Keystone验证通过后返回用户对应的项目列表\n  用户从列表中选择要访问的项目再次向Keystone发出请求，Keystone验证通过后返回管理该项目的服务列表，并允许访问该项目的令牌。\n  用户会通过这个服务和通用目录映射找到服务的端点，并通过端点找到实际服务组件的位置。\n  用户在凭借项目令牌和端点来访问实际上的服务组件。\n  服务组件会向Keystone提供这个用户项目令牌进行验证，Keystone验证通过后会返回一系列的确认信息和附加信息给服务\n  服务执行一系列操作。\n\n\n罗列命令行操作\n\n  列出可用角色：openstack role list\n  创建角色：openstack role create new-role\n  分配角色：openstack role add --user 用户名或ID --oject项目名或ID角色名或ID\n  查看角色详细信息：openstack role show角色名或ID\n  删除角色：openstack role remove --user 用户名或ID--project用户名或ID角色名或ID\n\n\n\n\n第六章\n常用的镜像格式以及容器\n\n镜像格式：qcwr\n不用容器使用bare代替\n使用容器可以在ovf ova aki ari docker中选择\n\nopenstack中创建镜像的流程\n创建镜像，转成快照\n\n\n  获取实例啃决照的文件路径，可通过查看其详细信息中的“ID”值。\n  其中执行openstack image create 创建新的镜像：openstack image create &quot;entOS7-img&quot;--file varlib/glance/limages/快照id --disk-format qcow2--container-format bare\n  新创建的镜像类型变为镜像(image) .\n\n\n\n第七章\n\n虚拟机实例化的流程\n\n  首先用户（可以是OpenStack最终用户，也可以是其他程序）执行Nova Client提供的用于创建虚拟机的命令。\n  nova-api服务监听到来白于Nova Client的HTTP请求,并将这些请求转换为AMQP消息之后加入消息队列。\n  通过消息队列调用nova-conductor报务。\n  nova-conductor服务从消息队列中接收到虚拟机实例化请求消息后,进行一些准备工作。\n  nova-conductor服务通过消息队列告诉nova-scheduler服务去选择一个合适的计算节点来创建虚拟机，此时nova-scheduler会读取数据库的内容。\n  nova-conductor服务从nova-scheduler服务得到了合适的将计算节点的信息后，在通过消息队列来通知nova-compute服务实现虚拟机的创建。\n\n\n其他\n配置文件中对两个值的解释\n\n”” 空字符串\n表示“always”（总是）\n\n”!” 感叹号\n表示“nerver”或者“nobady”，即拒绝。\n\n小知识点\n\n\n  oslo.policy是json格式的文件。\n  openstack是使用python语言实现的。\n\n"
} ,
  
  {
    "title"    : "Jekyll 入门指导",
    "category" : "",
    "tags"     : " Jekyll, web前端",
    "url"      : "/jekyll",
    "date"     : "December 4, 2022",
    "excerpt"  : "jekyll是一个简单的免费的Blog生成工具，类似WordPress。但是和WordPress又有很大的不同，原因是jekyll只是一个生成静态网页的工具，不需要数据库支持。但是可以配合第三方服务,例如Disqus。最关键的是jekyll可以免费部署在Github上，而且可以绑定自己的域名。\n\n\n\n前言\n\n该博客的部署使用的就是Jekyll框架，Jekyll是一门很成熟的技术（也可能是有点老的缘故），他可以将makedown格式的文档转化成一个个静态的页面，即便你没有系统的学过前端三件套...",
  "content"  : "jekyll是一个简单的免费的Blog生成工具，类似WordPress。但是和WordPress又有很大的不同，原因是jekyll只是一个生成静态网页的工具，不需要数据库支持。但是可以配合第三方服务,例如Disqus。最关键的是jekyll可以免费部署在Github上，而且可以绑定自己的域名。\n\n\n\n前言\n\n该博客的部署使用的就是Jekyll框架，Jekyll是一门很成熟的技术（也可能是有点老的缘故），他可以将makedown格式的文档转化成一个个静态的页面，即便你没有系统的学过前端三件套也可以制作自己的主页（真的太棒了！）。\n\n对于使用者来说只需要找到对应的资源模板，套用jekyll即可得到你想要的博客。\n\n如果你想要了解更多，这个是Jekyll官网的传送门 \\(\\Longrightarrow\\) Jekyll\n\n\n\nJekyll 基础知识\n\n基本结构\nJekyll 也遵循「约定大于配置」的基本原则，所以上手成本极低。\n\n在新创建的项目目录下，有几个重要的文件夹：\n\n_layouts\n\n用于存放各种布局.html 的文件用于对.md文件的转换，在md设置的消息头中的变量，.md文件选择了layout布局之后，会引入对应的布局.html中，html会存放这些变量的默认值，\n\n_drafts\n\n用于存放.md博客的草稿，不会再jekyll工作的时候生成，需要使用指令jekyll server –draft 才会显示在界面中\n_posts\n\n用于存放博客文章\n_site\n\n用于存放项目构建完成之后所生成的静态文件，也就是说，静态网站的所有文件都会来源于此，其中 CSS 文件、JS 文件以及图片文件，会存放在该目录下的 assets 文件夹中。我们可以直接把该目录下的文件拿去部署\n\n除此之外，还有一些其他文件：\n_config.yml\n\n是项目的配置文件，一些全局配置会写在这个文件内，比如 collections（后续推文会讲解），默认文件/路径，等等。总之，这里可以自定义很多东西\n\n.gitignore\n\n创建项目时会自动生成，不需要纳入到 CVS 的文件存放于此，它可以限制一些元素在_site 中的生成\n\nGemfile &amp;amp; Gemfile.lock\n\n存放项目所依赖的 Ruby gems，里面拥有存放页面的样式信息，当新加入了主题配置之后，需要使用bundle install指令安装新的配置才能使用。需要使用新的主题时，需要在_config.yml文件的there做更改。注意，使用了新的布局之后可能会导致一些布局不可用，例如“post”，因为在新的主题上可能没有定义这样的布局。所以使用新的布局之后要在_layout中查看一下是否有对应的布局可以使用。\n\nabout.md\n\n会存放有关在界面中的about的内容，生成的页面会出现在主界面上的位置，同理命名其他的文件也会在主界面的上方出现\n\n\n\nmakedown 语法\npermalink\n可以用于自定义所创建页面的URL。例如，permalink：/Jekyll/ 表示创建的页面会在主页面URL中后加上/Jekyll\n\nlayout\n表示自己所使用的界面样式，常见的值有post\n\n._config.yml\n\n\n  defaults：可用于写一些默认值，例如为layout设置默认值（要注意以下冒号的位置）\n    defaults:\n  - \n scope:\n   path: &quot;&quot;  # 这里填写此默认值影响的返回路径\n values:   # 这里补充默认值\n     layout: &quot;post&quot;\n    \n    再例如对图片文件的加载：\n    defaults:\n  -\n scope:\n   path: &quot;assets/img&quot;\n values:\n   image: true\n    \n    该例子表示，在html文件中可能加载图片信息的位置会在，assets/img的文件夹下寻找\n  \n\n\n\n常用指令\n\n  jekyll new 工程名  创建工程\n  bundle exec jekyll server   启动项目，启动项目之后可以在浏览器中访问http://127.0.0.1:400/看到效果。\n  jekyll new PATH --blank  创建新的空项目\n  jekyll build 或 jekyll b 构建项目，生成可部署的 _site 目录\n  jekyll serve 或 jekyll s  构建并运行项目，会自动监听文件变化，不需要反复执行\n  jekyll clean  清除所有的构建产物\n  jekyll new-theme  创建一个新的主题脚手架\n  jekyll doctor  诊断，输出所有已经废弃的依赖包或者有问题的配置\n\n"
} ,
  
  {
    "title"    : "MySql 学习笔记",
    "category" : "",
    "tags"     : " MySql, 数据库",
    "url"      : "/mysql",
    "date"     : "December 3, 2022",
    "excerpt"  : "MySQL是一种关系型数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。\n\n\n前言\n本人比较懒，所以专门挑了一个篇幅比较少的MySql来写博客，主要还是针对笔记的性质来写的。如果有错欢迎指正。\n\n\n\nMySql 基本语法\n1.分组\nGROUP BY 字段名 [HAVING 条件表达式]\n\n2.去重\n在 select的字段前面加上distinct就可以去重\n\n3.插入多行数据\n\n格式：\ninsert into 表名[（字段名1...",
  "content"  : "MySQL是一种关系型数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。\n\n\n前言\n本人比较懒，所以专门挑了一个篇幅比较少的MySql来写博客，主要还是针对笔记的性质来写的。如果有错欢迎指正。\n\n\n\nMySql 基本语法\n1.分组\nGROUP BY 字段名 [HAVING 条件表达式]\n\n2.去重\n在 select的字段前面加上distinct就可以去重\n\n3.插入多行数据\n\n格式：\ninsert into 表名[（字段名1，字段名2,…）] values(值\\(a_1\\)，值\\(b_1\\),…), (值\\(a_2\\),值\\(b_2\\),…)\n\n示例：\ninsert into mywork\nvalues(&quot;小明&quot;,18),(&quot;小红&quot;,20)\n\n\n4.外连接\n语法：\nselect 字段列表 from 表1 [inner] join 表2 on 连接条件;\n示例:\n\nselect * \nfrom wuhan.commercialhousing \njoin secondhouse on district regexp qy\nlimit 10;\n\n\n同理还有左外连接：left join，右外连接：right join\n\n5.排序\n\n排序语句：order by 字段值[ desc | asc]\n其中 asc是表示升序（默认），表示降序\n\n示例：\nselect customer_number\nfrom Orders\ngroup by customer_number\norder by COUNT(*) desc\n\n\n6.if语句\n\n语法：IF(expr1,expr2,expr3)\n\n如果 expr1 是TRUE (或者expr1 &amp;lt;&amp;gt; 0 且 expr1 &amp;lt;&amp;gt; NULL)，则 IF()的返回值为expr2; 否则返回值则为 expr3。IF() 的返回值为数字值或字符串值，具体情况视其所在语境而定。\n\n7.ifnull语句\n\n语法：IFNULL(expr1,expr2)\nexpr1不为NULL，则 IFNULL() 的返回值为expr1; 否则其返回值为 expr2。IFNULL()的返回值是数字或是字符串，具体情况取决于其所使用的语境。\n\n8.正则语句\n\n关键字：regexp\n\n使用语法：被检测字符串 regexp [binary] 正则语句\n不区分大小写（即大写和小写都匹配）。为区分大小写，可以使用 BINARY 关键字例如：\nWHHERE name REGEXP BINARY &#39;Hern .000&#39;\n\n\n9.存在判断语句 exists\n\n当我们只需要判断某些满足特定条件的数据是否存在时，为了提高效率，我们不需要将所有的数据捞出来判断，只需要判断是否存在就可以了。\n采用exists即可满足需求。\n示例：\nselect exists (SELECT *\n        from  a \n        where\n        money&amp;gt;0 and time&amp;gt;&#39;2021-03-05&#39;;\n)\n\n\n10.表格合并\n\nUNION操作符合并两个或多个 SELECT 语句的结果。\nUNION关键字应处于两次查询之间\n默认地，UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL。\n注意：union的优先级低于order by，即先合并再排序。\n示例1：\nSELECT column_name(s) FROM table1\nUNION\nSELECT column_name(s) FROM table2;\n\n示例2：\nSELECT column_name(s) FROM table1\nUNION ALL\nSELECT column_name(s) FROM table2;\n\n\n11.数据修改 update\n语法：\nUPDATE &amp;lt;表名&amp;gt; SET 字段 1=值 1 [,字段 2=值 2… ] \n[WHERE 子句 ]\n[ORDER BY 子句] [LIMIT 子句]\n\n\n\n\nmysql常用函数\n\n日期比较函数：datediff\n\n语法：DATEDIFF(date1,date2)\n参数说明\ndate1: 比较日期1\ndate2: 比较日期2\n\nDATEDIFF函数返回date1 - date2的计算结果，date1和date2两个参数需是有效的日期或日期时间值;如果参数传递的是日期时间值，DATEDIFF函数仅将日期部分用于计算，并忽略时间部分(只有值的日期部分参与计算)\n\n示例：\nSELECT DATEDIFF(&#39;2022-04-29&#39;,&#39;2022-04-30&#39;); --返回 -1\nSELECT DATEDIFF(&#39;2022-04-30&#39;,&#39;2022-04-29&#39;); --返回 1\n\n\n日期加减函数：date_add\n\n语法：date_add(‘某个日期时间’,interval 1 时间种类名)\n示例：\n\nselect date_add(data, interval 1 year); --加1年\nselect date_add(fata, interval 1 month); --加1月\n\n\nquarter:季，week:周，day:天，hour:小时，minute:分钟，second:秒，microsecond:毫秒\n注：也可以不用变量，直接加减某个时间，如：select date_add(‘1998-01-01’, interval 1 day);\n\n字符串专题\n字符串拼接：concat\n\n将给入的参数逐一拼接\n例如：\nconcat(‘%’,’abc’,’%’) --结果为%abc%\n\n字符串与日期的相互转换\n使用语法：\nDATE_FORMAT(date,format) 日期转字符串\nSTR_TO_DATE(str,format) 字符串转日期\n示例：\n\nselect DATE_FORMAT(now(),&#39;%Y-%m-%d %H:%i:%s&#39;);\n\n返回：2022-12-01 10:07:41\n\nselect str_to_date(&#39;2022-8-7&#39;,&#39;%Y&#39;)\n\n返回：2022-00-00\n因为这里只获取到了年份，但是作为datetime对象需要补全月份和日所以会有-00-00出现。\n\n组内字符串拼接 group_concat\n\n语法：\nGROUP_CONCAT([DISTINCT] column1 [ORDER BY column2 ASC|DESC] [SEPARATOR seq])\n\n\n将分组中column1这一列对应的多行的值按照column2 升序或者降序进行连接，其中分隔符为seq\n如果用到了DISTINCT，将表示将不重复的column1按照column2升序或者降序连接\n如果没有指定SEPARATOR的话，也就是说没有写，那么就会默认以 ‘,’分隔\n\n字符串截取 substring\n语法格式：SUBSTRING(str, begin, end)\nsubstring函数可以将字符串str从下标begin到end截取下来（下标从1开始计算）（闭区间包括begin和end），其中end默认为空，当end省略时表示截取到字符串最后。\nmysq支持逆向访问，即可以使用负数表示下标，负数的下标即从右边开始计算的下标。\n示例：\nselect substring(&quot;01234&quot;,1,2);\t-- 01\nselect substring(&quot;01234&quot;,1);\t-- 01234\nselect substring(&quot;01234&quot;,1,100); -- 01234\nselect substring(&quot;01234&quot;,-1);\t-- 4\n\n\n字符串大小写转换\nupper(str)  字符串中所有字母转大写\nlower(str)  字符串中所有字母转小写\n\n\n\n技巧语法\n\n查询排名前n的数据\n\n使用limit n语句实现（该语句需要放在查询结果的最后）\n\n示例：\n\nSELECT * FROM wuhan.secondhouse limit 10;\n\n\n使用正则配对字符串\n\n使用regexp关键字实现\n格式： 字段值 regexp 正则字符串\n示例：\n\nselect distinct district,house_type,wq_area,wq_num,yqy_area,yqy_num\nfrom commercialhousing\nwhere district regexp &#39;江岸&#39;;\n\n"
} 
  
  
  
]
