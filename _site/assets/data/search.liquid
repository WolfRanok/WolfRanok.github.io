[
  
  {
    "title"    : "机器学习三大基础库",
    "category" : "",
    "tags"     : " 机器学习, python, numpy, pandas, matplotlib",
    "url"      : "/machine",
    "date"     : "December 6, 2022",
    "excerpt"  : "机器学习是研究怎样使用计算机模拟或实现人类学习活动的科学，是人工智能中最具智能特征，最前沿的研究领域之一。自20世纪80年代以来，机器学习作为实现人工智能的途径，在人工智能界引起了广泛的兴趣，特别是近十几年来，机器学习领域的研究工作发展很快，它已成为人工智能的重要课题之一。机器学习不仅在基于知识的系统中得到应用，而且在自然语言理解、非单调推理、机器视觉、模式识别等许多领域也得到了广泛应用。一个系统是否具有学习能力已成为是否具有“智能”的一个标志。\n\n\n\n前言\n\n本次博客主要内容为以下三个p...",
  "content"  : "机器学习是研究怎样使用计算机模拟或实现人类学习活动的科学，是人工智能中最具智能特征，最前沿的研究领域之一。自20世纪80年代以来，机器学习作为实现人工智能的途径，在人工智能界引起了广泛的兴趣，特别是近十几年来，机器学习领域的研究工作发展很快，它已成为人工智能的重要课题之一。机器学习不仅在基于知识的系统中得到应用，而且在自然语言理解、非单调推理、机器视觉、模式识别等许多领域也得到了广泛应用。一个系统是否具有学习能力已成为是否具有“智能”的一个标志。\n\n\n\n前言\n\n本次博客主要内容为以下三个python库\n\n  numpy\n  pandas\n  matplotlib\n\n\n前两个库numpy、pandas主要作用是对于数据存储与数据处理，并且广泛适用于很多机器学习的模型。而matplotlib是作图的好帮手，主要用户机器模型数据的可视化。\n\nnumpy（机器学习前缀知识）\n属性\n\n  数组的维数：对象名.ndim\n  数组的每个维度的数量：对象名.shape返回一个元组，元组中的数字表示该维度的长度。\n  元素总个数：对象名.size\n  成员的数据类型：对象名.dtype\n  矩阵的转置：对象名.T\n  对象名.flat 表示返回一个可以遍历所有元素的迭代器\n  numpy.nan 表示无穷\n  xxx\n\n\n功能型小函数\n\n\n  numpy.sum 求和\n  numpy.min 求最小值\n  numpy.max 求最大值\n  numpy.average 求平均值\n  numpy.median 求中位数\n  numpy.cumsum 返回前缀和向量\n  numpy.diff 返回一个差分数组（少一位）\n  numpy.argmin 求最小值的索引（从0开始计算）\n  numpy.argmax 求最大值的索引（从0开始计算）\n  numpy.nonzero返回n个向量，表示非元素所在位置的索引。\n  numpy.sort 返回对数组排序的结果，如果是多维则只会对一维排序（每一行）。\n  numpy.transpose 返回矩阵转置的结果\n  对象名.flatten() 返回该对象的一维展开（即变成一个行向量）\n  对象名.copy() 返回该对象的值拷贝（直接使用“=”是引用拷贝）注意不同于列表使用对象名[:]不能实现值拷贝，必须使用copy函数\n  numpy.random.randn 按正太分布的概率产生随机数数组\n  numpy.all(逻辑表达式) 逻辑表达式后半段 通过用这种方式将矩阵中所有数据参与计算返回一个bool判断矩阵中是不是所有元素都满足这个式子。\n  numpy.any(数组对象)逻辑表达式后半段 通过用这种方式将矩阵中所有数据参与计算返回一个bool判断矩阵中是否存在某个元素满足这个式子。\n\n\n示例（以numpy.sum为例）\n函数的默认计算区域是所有元素，当想要指定维度使用时需要使用axis来指定，axis从\n0开始计数。特别的对于一个矩阵来说，axis=0表示对每一列求和，axis=1表示对每一行求和。\n代码示例：\n\nimport numpy as np\n\na = np.arange(4).reshape(2,2)\nprint(a)\nprint(np.sum(a),np.sum(a,axis=1))\n\n程序运行截图：\n[[0 1]\n [2 3]]\n6 [1 5]\n\n\n矩阵索引\n以二维数组（矩阵）为例\n\n访问单元素的方法\na[i][j]，或 a[i,j]\n\n访问多元素的方法\n访问第i+1行的所有元素\na[i,:]\n访问第j+1列的所有元素\na[:,j]\n\n矩阵初始化 array\n函数签名：\narray(p_object, dtype=None, *args, **kwargs):\n\n上面的构造器接受以下参数：\n\n  object 任何暴露数组接口方法的对象都会返回一个数组或任何（嵌套）序列。\n  dtype 数组的所需数据类型，可选。\n  copy 可选，默认为true，对象是否被复制。\n  order C（按行）、F（按列）或A（任意，默认）。\n  subok 默认情况下，返回的数组被强制为基类数组。 如果为true，则返回子类。\n  ndmin 指定返回数组的最小维数。\n\n\n示例：\narray = numpy.array([[1,2,3],[4,5,6]].numpy.int64)\n\n滤波器clip\n\n函数签名：\ndef clip(a, a_min, a_max, out=None, **kwargs):\n\n将数组中小于a_min的值取a_min，将数组中大于a_max的值取a_max\n代码示例：\nimport numpy as np\n\na = np.arange(12)\n\nprint(np.clip(a,5,9))\n\n程序运行截图：\n[5 5 5 5 5 5 6 7 8 9 9 9]\n\n创建一个全1数组ones\n函数签名：\ndef ones(shape, dtype=None, order=&#39;C&#39;, *, like=None):\n\n示例：\nnumpy.noes((2,3,4)) # 创建一个2叶3行4列的全1矩阵\n\n\n创建一个全0数组zeros\n函数签名：\ndef zeros(shape, dtype=None, order=&#39;C&#39;, *args, **kwargs):\n\n\n示例：\nnumpy.zeros((2,3,4)) # 创建一个2叶3行4列的全0矩阵。\n\n\n创建有序数组arange\n函数签名：\ndef arange(start=None, *args, **kwargs):\n\n示例1（创建一个0~9的行向量）：\nnumpy.arange(10)\n\n程序输出：[0 1 2 3 4 5 6 7 8 9]\n\n示例2（创建一个5~9的行向量）：\nnumpy.arenge(5,10)\n\n程序输出：[5 6 7 8 9]\n\n示例3（创建一个以3为步长1~10的行向量）\nnumpy.arange(1,11,3)\n\n程序输出：[ 1  4  7  10]\n\n示例4（创建一个0~9的2行5列的矩阵）\nnumpy.arange(10).reshape(2,5) # 规模必须与元素个数相匹配\n\n程序输出：\n[[0 1 2 3 4]\n [5 6 7 8 9]]\n\n\n创建一个均匀划分的线段 linspace\n函数签名：\ndef linspace(start, stop, num=50, endpoint=True, retstep=False,type=None,axis=0):\n\n作用：以start为开始以stop结束以num为划分次数创建一个行向量。\n\n示例1（一般示例）：\nnumpy.linspace(0，10，2)\n\n程序输出：\n[ 0. 10.]\n\n示例2（重组元素为一个2*5的矩阵）\nnumpy.linspace(0,10,10).reshape(2,5)\n\n程序输出：\n[[ 0.          1.11111111  2.22222222  3.33333333  4.44444444]\n [ 5.55555556  6.66666667  7.77777778  8.88888889 10.        ]]\n\n\nnumpy的运算\n矩阵加减法：\n代码示例：\na = np.array([10,20,30,40])\nb = np.arange(1,5)\nprint(a-b)\nprint(a+b)\n\n程序运行截图：\n[ 9 18 27 36]\n[11 22 33 44]\n\n\n矩阵点乘：\n代码示例1（矩阵点乘）：\nimport numpy as np\n\na = np.array([10,20,30,40])\nb = np.arange(1,5)\nprint(a*b)\n\n程序运行截图：[ 10  40  90 160]\n\n代码示例2（矩阵乘数字）：\nimport numpy as np\n\na = np.array([10,20,30,40])\n\nprint(a*5)\n\n程序运行截图：[ 50 100 150 200]\n\n矩阵乘法：\n示例1（使用np.dot函数实现矩阵乘法）\n代码示例：\nimport numpy as np\n\na = np.arange(1,4).reshape(1,3)\nb = np.arange(1,4).reshape(3,1)\n\nc_dot = np.dot(a,b)\nd_dot = np.dot(b,a)\nprint(c_dot,d_dot,sep=&#39;\\n&#39;)\n\n程序运行截图：\n[[14]]\n[[1 2 3]\n [2 4 6] \n [3 6 9]]\n\n示例二（使用@符号实现矩阵乘法）：\n\n代码示例：\nimport numpy as np\n\na = np.arange(1,4).reshape(1,3)\nb = np.arange(1,4).reshape(3,1)\n\nprint(a@b,b@a,sep=&#39;\\n&#39;)\n\n程序运行截图：\n[[14]]\n[[1 2 3]\n [2 4 6]\n [3 6 9]]\n\n数组的逻辑判断：\n\n数组可以直接进行逻辑判断，其返回值为与元素组同规模的bool型结果数组。\n可以使用对象[逻辑表达式] 来过滤符合条件的项，返回一个行向量。\n\n代码示例：\nimport numpy as np\n\na = np.arange(10)\nprint(a &amp;lt; 3)\ns = np.random.random((4,4))\nprint(s[s &amp;gt; 0.5])\n\n程序运行截图：\n[ True  True  True False False False False False False False]\n[0.50784044 0.51138057 0.75612031 0.61457462 0.9712732  0.79497591]\n\n矩阵元素的函数运算：\n代码示例：\nimport numpy as np\n\na = np.arange(10)\nprint(np.sin(a))\n\n程序运行截图：\n[ 0.          0.84147098  0.90929743  0.14112001 -0.7568025  -0.95892427\n -0.2794155   0.6569866   0.98935825  0.41211849]\n\n\n创建一个元素值在0~1之间的随机矩阵\n示例（创建一个元素值在0~1之间的2行4列的随机矩阵）：\n代码示例：\nimport numpy as np\n\na = np.random.random((2,4))\n\nprint(a)\n\n程序运行截图：\n[[0.24853676 0.47803948 0.04436044 0.92552742]\n [0.61756337 0.31913713 0.83677922 0.51923448]]\n\n\n合并数组\n上下合并函数签名：\ndef vstack(tup):\n\n左右合并函数签名：\ndef hstack(tup):\n\n代码演示：\nimport numpy as np\n\na = np.array([1,2,3,4])\nb = np.array([4,3,5,8])\nprint(np.vstack((a,b)))\nprint(np.hstack((a,b)))\n\n程序运行截图：\n[[1 2 3 4]\n [4 3 5 8]]\n[1 2 3 4 4 3 5 8]\n\n数组分割 split or array_split\n等量数组分割 split\n\n函数签名：\ndef split(ary, indices_or_sections, axis=0):\n\n注意：axis表示对照切割的维度，例如对于矩阵而言axis=0表示横向切割，axis=1表示纵向切割，切割必须是对等切割否则报错。\n代码展示：\nimport numpy as np\n\nA = np.arange(12).reshape(3,4)\nprint(A)\nprint(&quot;纵向切割&quot;)\nprint(np.split(A,2,axis=1))\nprint(&quot;横向切割&quot;)\nprint(np.split(A,3,axis=0))\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n不等量数组分割 array_split\n函数签名：\ndef array_split(ary, indices_or_sections, axis=0):\n\n注意：这里与函数split最大的区别就是可以实现不等分的分法。前面等分，后面几项少分。\n代码展示：\nimport numpy as np\n\nA = np.arange(12).reshape(3,4)\n\nprint(A)\nprint(&quot;纵向切割&quot;)\nprint(np.array_split(A,3,axis=1))\nprint(&quot;横向切割&quot;)\nprint(np.array_split(A,2,axis=0))\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\npandas（机器学习前缀知识）\n属性\n\n  dtypes 获取所有列的数据格式\n  columns 获取所有列名\n  values 去除行名和列名，返回所有的内容，返回对象是numpy.ndarry。\n  T 获得矩阵的转置（列名和行名也会一起转）。\n    功能型小函数\n  \n  fillna(x) 将序列中出现的nan转变为x\n  isnull返回一个bool矩阵当原矩阵中该数值为nan时为true，非nan数据时为false。可以与numpy.any，numpy.all配套使用。\n  读取csv文件pd.read_csv(文件名)\n\n\n初始化矩阵\n创建矩阵 Series\n创建方式类似于numpy\n代码展示：\nimport pandas as pd\n\ns = pd.Series([1,3,6,44,1])\nprint(s)\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n定义有名称的数据 DataFrame\n说明：\nindex表示行标题，columns表示列标题，默认名称为从0开始的有序数列\n注意：每一行对应的数据数量要保持一致。\n示例1（使用序列创建）\n代码展示：\nimport pandas as pd\nmport numpy as np\ns = \nd.DataFrame(np.random.randn(3,4),index=[&#39;x&#39;,&#39;y&#39;,&#39;x&#39;],columns=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;])\nprint(s)\n\n程序运行截图:\n\n\n    \n    \n        \n    \n    \n\n\n示例2（使用字典创建）\n代码展示：\nimport pandas as pd\n\ns = pd.DataFrame({\n    &quot;a&quot;: [1,3],\n    &quot;b&quot;: [1.2,4],\n    &quot;c&quot;: [1.5,84],\n    &quot;d&quot;: [0.2,6]\n})\nprint(s)\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n数组访问\nloc （名称）表示法\n说明：\nloc[ [行名序列]，[列名序列] ]直接访问\nloc[ 行名序列i：行名序列j，列名序列i：列名序列j ]切片访问（切片是闭区间）\n\n两者可以混合使用。\n\n代码展示：\nimport pandas as pd\nimport numpy as np\n\ndates = pd.date_range(&#39;20221001&#39;, periods=6)\ns = pd.DataFrame(np.random.randn(6, 4), index=dates, columns=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])\n\nprint(s)\nprint(&#39;单个数据访问&#39;,s.loc[&quot;20221002&quot;,&#39;a&#39;],sep=&#39;\\n&#39;)\nprint(&#39;多行单列&#39;,s.loc[[&#39;20221002&#39;,&#39;20221001&#39;],&#39;b&#39;],sep=&#39;\\n&#39;)\nprint(&#39;单行多列&#39;,s.loc[&#39;20221002&#39;,[1,2]],sep=&#39;\\n&#39;)\nprint(&#39;多行多列&#39;,s.loc[[&#39;20221002&#39;,&#39;20221001&#39;],[&#39;a&#39;,&#39;b&#39;]],sep=&#39;\\n&#39;)\nprint(&#39;多行多列切片访问&#39;,s.loc[&#39;20221001&#39;:&#39;20221002&#39;,[&#39;a&#39;,&#39;b&#39;]],sep=&#39;\\n&#39;)\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\niloc（下标）表示法\n说明：\n使用方式等同于loc但是序列名变成了索引号（从0开始计数）（不同于loc的是使用切片表示法时是左开右闭区间）\n代码展示：\nimport pandas as pd\nimport numpy as np\n\ndates = pd.date_range(&#39;20221001&#39;, periods=6)\ns = pd.DataFrame(np.random.randn(6, 4), index=dates, columns=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])\n\nprint(s)\nprint(&#39;单个数据访问&#39;,s.iloc[1,1],sep=&#39;\\n&#39;)\nprint(&#39;多行单列&#39;,s.iloc[0:3,3],sep=&#39;\\n&#39;)\nprint(&#39;单行多列&#39;,s.iloc[0,0:3],sep=&#39;\\n&#39;)\nprint(&#39;多行多列&#39;,s.iloc[0:2,[0,3]],sep=&#39;\\n&#39;)\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n访问一列\n访问方式：\n\n对象名[列名]（适用于所有情况的访问方式）\n对象名.列名（这种访问方式仅适用于标题为字符串型的情况）\n\n代码展示：\nimport pandas as pd\nimport numpy as np\ndates = pd.date_range(&#39;20221001&#39;, periods=6)\ns = pd.DataFrame(np.random.randn(6, 4), index=dates, columns=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])\nprint(s)\nprint(s[&#39;a&#39;])\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n访问一行数据 loc\n代码展示：\nimport pandas as pd\nimport numpy as np\n\ndates = pd.date_range(&#39;20221001&#39;, periods=6)\ns = pd.DataFrame(np.random.randn(6, 4), index=dates, columns=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])\n\nprint(s)\nprint(s.loc[&quot;20221002&quot;])\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n访问多行数据\n\n多行数据直接访问语法：\n对象名[start:end] 这里的start、end既可以是数字用于表示序列的索引，当行名不是整数型时也可以直接使用行名（行名可以是字符串）\n\n数组修改\n说明：\n与赋值相似，对已存在的数值进行修改就是修改，对不存在的数据就是添加可以通过修改不存在的行列使得数据的行列增加（未知数据用NAN代替）\n代码展示：\nimport pandas as pd\nimport numpy as np\n\ndates = pd.date_range(&#39;20221001&#39;, periods=6)\ns = pd.DataFrame(np.random.randn(6, 4), index=dates, columns=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])\nprint(s)\nprint(&quot;修改数值&quot;)\ns.a[s.a &amp;lt; 0] = 0\nprint(s)\nprint(&quot;增加行&quot;)\ns.loc[&#39;new_index&#39;] = np.nan\nprint(s)\nprint(&quot;增加列&quot;)\ns.loc[:,&quot;new_columns&quot;] = np.array([0,1,2,3,4,5,6])\nprint(s)\nprint(&quot;同时增加行和列&quot;)\ns.loc[8,&#39;f&#39;] = np.nan\nprint(s)\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n删除行列 dropna\n说明：\n\naxis = 0 时表示删除行，1表示删除列\n\nhow参数有两个值：\n\n\n  “any”：如果存在任何NAN值，则删除该行或列。\n  “all”：如果所有值都为NAN值，则删除该行或列。\n\n\n注意：dropna 只是返回修改后的结果不会改变原本的值\n代码展示：\nimport pandas as pd\nimport numpy as np\n\ndates = pd.date_range(&#39;20221001&#39;, periods=6)\ns = pd.DataFrame(np.random.randn(6, 4), index=dates, columns=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])\n\nprint(s)\ns.iloc[0,0] = np.nan\ns.iloc[2] = np.nan\ns.iloc[:,3] = np.nan\nprint(s)\nprint(&quot;axis == 0 时表示删除行，1表示删除列&quot;)\ns = s.dropna(axis=0,how=&#39;all&#39;)\nprint(s)\ns = s.dropna(axis=1,how=&#39;all&#39;)\nprint(s)\ns = s.dropna(axis=0,how=&#39;any&#39;)\nprint(s)\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n读写excle文件 read_excle or .to_excle\n注意：\n\nread_excle 得到的是一个pandas对象，之前数据访问修改删除等操作依然成立。\nto_excle创建时会添加一列行名，可以使用index=False 去除行名的添加。\n脚本编程\n逻辑表达式筛选：\n\n使用对象名[逻辑表达式]方式筛选。\n代码展示：\nimport pandas as pd\nimport numpy as np\n\ndates = pd.date_range(&#39;20221001&#39;, periods=6)\ns = pd.DataFrame(np.random.randn(6, 4), index=dates, columns=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])\nprint(s)\nprint(&#39;第0列数据大于0的数据有：&#39;)\nprint(s[s.iloc[:,0] &amp;gt; 0])\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n数据分析 describe\n代码展示：\nimport pandas as pd\n\ns = pd.DataFrame({\n    &quot;a&quot;: [1,3],\n    &quot;b&quot;: [1.2,4],\n    &quot;c&quot;: [1.5,84],\n    &quot;d&quot;: [2,6.2]\n})\nprint(s.describe(),sep=&#39;\\n&#39;)\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n排序 sort_index &amp;amp; sort_values\nsort_index 对行列名排序\n说明：\naxis = 0表示对行名进行排序，1表示对列名进行排序。\n排序默认升序排序，当ascending = True 表示倒序排序\n函数签名：\ndef sort_index(\n    self,\n    axis: Axis = 0,\n    level: Level | None = None,\n    ascending: bool | int | Sequence[bool | int] = True,\n    inplace: bool = False,\n    kind: str = &quot;quicksort&quot;,\n    na_position: str = &quot;last&quot;,\n    sort_remaining: bool = True,\n    ignore_index: bool = False,\n    key: IndexKeyFunc = None,\n):\n\n代码展示：\nimport pandas as pd\ns = pd.DataFrame({\n    &quot;a&quot;: [1, 3],\n    &quot;b&quot;: [1.2, 4],\n    &quot;c&quot;: [1.5, 84],\n    &quot;d&quot;: [2, 6.2]\n})\nprint(s.sort_index(axis=0, ascending=False), sep=&#39;\\n\\n&#39;)\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\nsort_values对数据列排序\n函数签名：\ndef sort_values(  # type: ignore[override]\n    self,\n    by,\n    axis: Axis = 0,\n    ascending=True,\n    inplace: bool = False,\n    kind: str = &quot;quicksort&quot;,\n    na_position: str = &quot;last&quot;,\n    ignore_index: bool = False,\n    key: ValueKeyFunc = None,\n):\n\n代码展示：\nimport pandas as pd\n\ns = pd.DataFrame({\n    &quot;a&quot;: [1, 3],\n    &quot;b&quot;: [1.2, 4],\n    &quot;c&quot;: [1.5, 84],\n    &quot;d&quot;: [2, 6.2]\n})\n\nprint(s.sort_values(&#39;a&#39;,ascending=False))\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n合并数组 merge\n说明：\nhow 有4个取值：inner（默认）、outer、left、right 分别表示内连接、外连接、左外连接、右外连接。\non 表示连接是使用的列（类似于外键）\nindictor == True时，在结果列中增加一列以显示每一个数据连接的方式默认为False，可以给indictor赋予字符串，以表示新列的名称\nleft_\tindex &amp;amp; right_index同时为True时可以按行名合并，默认都为False，两者必须同为True才能生效。\nsuffixex当给其一个包含两个字符串的元组时，合并时若出现同名字段，则会加上这两个字符串后缀。\n函数签名：\ndef merge(\n    left: DataFrame | Series,\n    right: DataFrame | Series,\n    how: str = &quot;inner&quot;,\n    on: IndexLabel | None = None,\n    left_on: IndexLabel | None = None,\n    right_on: IndexLabel | None = None,\n    left_index: bool = False,\n    right_index: bool = False,\n    sort: bool = False,\n    suffixes: Suffixes = (&quot;_x&quot;, &quot;_y&quot;),\n    copy: bool = True,\n    indicator: bool = False,\n    validate: str | None = None,\n) -&amp;gt; DataFrame:\n\n\n案例演示\n示例1（依照指定列进行合并）：\n代码演示：\nimport numpy as np\nimport pandas as pd\n\nleft = pd.DataFrame({\n    &#39;key&#39;: [&#39;K0&#39;, &#39;k1&#39;, &#39;k2&#39;, &#39;k3&#39;],\n    &#39;A&#39;: [&#39;A0&#39;, &#39;A1&#39;, &#39;A2&#39;, &#39;A3&#39;],\n    &#39;B&#39;: [&#39;B0&#39;, &#39;B1&#39;, &#39;B2&#39;, &#39;B3&#39;]\n})\n\nright = pd.DataFrame({\n    &#39;key&#39;:[&#39;K0&#39;, &#39;k1&#39;, &#39;k2&#39;, &#39;k3&#39;],\n    &#39;C&#39;:[&#39;C0&#39;,&#39;C1&#39;,&#39;C2&#39;,&#39;C2&#39;],\n    &#39;D&#39;:[&#39;D0&#39;,&#39;D1&#39;,&#39;D2&#39;,&#39;D3&#39;]\n})\n\nprint(left)\nprint(right)\nres = pd.merge(left,right,on=&#39;key&#39;)\nprint(res)\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n示例2依照多列进行合并\n代码演示：\nimport numpy as np\nimport pandas as pd\n\nleft = pd.DataFrame({\n    &#39;key1&#39;: [&#39;K0&#39;, &#39;k0&#39;, &#39;k1&#39;, &#39;k2&#39;],\n    &#39;key2&#39;: [&#39;K0&#39;, &#39;k1&#39;, &#39;k0&#39;, &#39;k1&#39;],\n    &#39;A&#39;: [&#39;A0&#39;, &#39;A1&#39;, &#39;A2&#39;, &#39;A3&#39;],\n    &#39;B&#39;: [&#39;B0&#39;, &#39;B1&#39;, &#39;B2&#39;, &#39;B3&#39;]\n})\n\nright = pd.DataFrame({\n    &#39;key1&#39;: [&#39;K0&#39;, &#39;k1&#39;, &#39;k1&#39;, &#39;k2&#39;],\n    &#39;key2&#39;: [&#39;K0&#39;, &#39;k0&#39;, &#39;k0&#39;, &#39;k0&#39;],\n    &#39;C&#39;: [&#39;C0&#39;, &#39;C1&#39;, &#39;C2&#39;, &#39;C2&#39;],\n    &#39;D&#39;: [&#39;D0&#39;, &#39;D1&#39;, &#39;D2&#39;, &#39;D3&#39;]\n})\n\nprint(left)\nprint(right)\n# how = [&#39;left&#39;,&#39;right&#39;,&#39;inner&#39;,&#39;outer&#39;]\nprint(&#39;内连接&#39;)\nprint(pd.merge(left, right, on=[&#39;key1&#39;,&#39;key2&#39;],how=&#39;inner&#39;))\nprint(&#39;全外连接&#39;)\nprint(pd.merge(left, right, on=[&#39;key1&#39;,&#39;key2&#39;],how=&#39;outer&#39;))\nprint(&#39;左外连接&#39;)\nprint(pd.merge(left, right, on=[&#39;key1&#39;,&#39;key2&#39;],how=&#39;left&#39;))\nprint(&#39;右外连接&#39;)\nprint(pd.merge(left, right, on=[&#39;key1&#39;,&#39;key2&#39;],how=&#39;right&#39;))\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n示例3（显示每一列的合并方式）\n代码演示：\nimport pandas as pd\ndf1 = pd.DataFrame({&#39;col1&#39;:[0,1],&#39;col_left&#39;:[&#39;a&#39;,&#39;b&#39;]})\ndf2 = pd.DataFrame({&#39;col1&#39;:[1,2,2],&#39;col_right&#39;:[2,2,2]})\nprint(df1)\nprint(df2)\nres = pd.merge(df1,df2,on=&#39;col1&#39;,indicator=True,how=&#39;outer&#39;)\nprint(res)\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n示例4（依照行名进行合并）\n代码演示：\nimport pandas as pd\nleft = pd.DataFrame({\n    &#39;A&#39;:[&#39;A0&#39;,&#39;A1&#39;,&#39;A2&#39;],\n    &#39;B&#39;:[&#39;B0&#39;,&#39;B1&#39;,&#39;B2&#39;]},\n    index=[&#39;K0&#39;,&#39;K1&#39;,&#39;K2&#39;])\nright = pd.DataFrame({\n    &#39;C&#39;:[&#39;C0&#39;,&#39;C2&#39;,&#39;C3&#39;],\n    &#39;D&#39;:[&#39;D0&#39;,&#39;D2&#39;,&#39;D3&#39;]},\n    index=[&#39;K0&#39;,&#39;K2&#39;,&#39;K3&#39;])\nprint(left)\nprint(right)\nres = pd.merge(left,right,right_index=True,left_index=True,how=&#39;outer&#39;)\nprint(res)\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n示例5（同名字段加后缀）\n代码演示：\nimport pandas as pd\nboys = pd.DataFrame({&#39;k&#39;: [&#39;K0&#39;, &#39;k1&#39;, &#39;k2&#39;], &#39;age&#39;: [1, 2, 3]})\ngirls = pd.DataFrame({&#39;k&#39;: [&#39;K0&#39;, &#39;K1&#39;, &#39;K2&#39;], &#39;age&#39;: [4, 5, 6]})\nprint(boys)\nprint(girls)\nres = pd.merge(boys,girls,on=&#39;k&#39;,suffixes=(&#39;_boy&#39;,&#39;_girl&#39;),how=&#39;outer&#39;)\nprint(res)\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n合并数组 concat\n说明：\naxis == 0(默认) 表示竖向的合并，1表示横向合并\nignore == True表示纵向合并时忽略原行序列从新有序定义行标号，默认False\njoin 表示纵向连接方式默认为outer外连接（默认），还可以选择 inner 内连接\n注意：当竖向合并时，列名不一致（不包括次序不一致）将产生新列（全外连接）\n\n示例1\n代码展示：\nimport pandas as pd\nimport numpy as np\n\ndf1 = pd.DataFrame(np.ones((3,4))*0,columns=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;])\ndf2 = pd.DataFrame(np.ones((3,4))*1,columns=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;])\ndf3 = pd.DataFrame(np.ones((3,4))*2,columns=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;])\n\nprint(pd.concat([df1,df2,df3],axis=0,ignore_index=True))\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n示例2（纵向连接，两种连接的比较）\n代码演示：\nimport pandas as pd\nimport numpy as np\n\ndf1 = pd.DataFrame(np.ones((3,4))*0,index=[1,2,3],columns=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;])\ndf2 = pd.DataFrame(np.ones((3,4))*1,index=[2,3,4],columns=[&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;])\n\nprint(pd.concat([df1,df2],axis=0,join=&#39;outer&#39;))\nprint(pd.concat([df1,df2],axis=0,join=&#39;inner&#39;))\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n示例三（横向连接的4种方式比较）\n注意：\n代码演示：\nimport pandas as pd\nimport numpy as np\n\ndf1 = pd.DataFrame(np.ones((3,4))*0,index=[1,2,3],columns=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;])\ndf2 = pd.DataFrame(np.ones((3,4))*1,index=[2,3,4],columns=[&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;])\nprint(&quot;全外连接&quot;)\nprint(pd.concat([df1,df2],axis=1))\nprint(&quot;左外链接&quot;)\nprint(pd.concat([df1,df2.reindex(df1.index)],axis=1))\nprint(&quot;右外连接&quot;)\nprint(pd.concat([df2,df1.reindex(df2.index)],axis=1))\nprint(&quot;内连接&quot;)\nprint(pd.concat([df2.reindex(df1.reindex(df2.index).index)],axis=1))\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n数据筛选query\nDataFrame.query(expr, inplace=False, **kwargs)，用于通过boolean表达式来查询dataframe中的列。\n主要参数为expr，它是字符串表达式，有如下说明：\n\n可以引用变量，方法是在变量前添加一个@字符，例如@a + b。\n可以在反引号内将包含空格或运算符的列名引用起来。 这样，您还可以转义以数字开头或Python关键字的名称。 基本上是无效的Python标识符。\n\nmatplotlib（图像绘制）\n\n函数应用\n函数签名：\ndef plot(*args, scalex=True, scaley=True, data=None, **kwargs):\n\n\n\n  x: 横坐标，可选的， 默认为 range(len(y))\n  y: 纵坐标，即数据项，可以是一维或多维的列表或数组\n  markersize: 标记大小\n  color: 线条颜色\n  marker: 数据标记的形状，默认是没有标记\n  linestyle: 线条样式，默认为实线\n代码演示：\n\n\nimport matplotlib.pyplot as plt\n\nx = [1, 2, 3]\ny = [1, 2, 3]\n# 以下两种写法等价，\nplt.plot(x, y, color=&#39;green&#39;, marker=&#39;o&#39;, linestyle=&#39;dashed&#39;, linewidth=2, markersize=12)\n# plt.flot(x, y, &#39;go--&#39;，linewidth=2, markersize=12)\n# 可以在一个画布上绘制多张图片，\ny1 = [4, 5, 6]\nplt.plot(x, y1, color=&#39;red&#39;, marker=&#39;*&#39;, linestyle=&#39;solid&#39;, linewidth=2, markersize=12)\nplt.show()\n\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n重要示例\n\n示例1（创建4个折线图）\n说明：使用plot实现，其中show函数主要实现图像的展示工作。\n代码演示：\n\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndata = pd.DataFrame(np.random.randn(1000,4),index=np.arange(1000),columns=list(&quot;ABCD&quot;))\n\ndata = data.cumsum()    # 累加\ndata.plot()\nplt.show()\n\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n示例二（创建2个散点图）\n代码演示：\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndata = pd.DataFrame(np.random.randn(1000,4),index=np.arange(1000),columns=list(&quot;ABCD&quot;))\ndata = data.cumsum()    # 累加\nax = data.plot.scatter(x=&#39;A&#39;,y=&#39;B&#39;,color=&#39;DarkBlue&#39;,label=&quot;Class 1&quot;)\ndata.plot.scatter(x=&#39;A&#39;,y=&#39;C&#39;,color=&#39;DarkGreen&#39;,label=&quot;Class 2&quot;,ax=ax)\nplt.show()\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n日常问题\n图形中文乱码\n\n解决方法：更改字体防止图形乱码\nfrom matplotlib import pyplot as pl\npl.rcParams[&#39;font.sans-serif&#39;] = [&#39;SimHei&#39;]\n\n"
} ,
  
  {
    "title"    : "python 多线程与多进程",
    "category" : "",
    "tags"     : " python, 多线程, 多进程",
    "url"      : "/process",
    "date"     : "December 5, 2022",
    "excerpt"  : "进程是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。线程是进程中的一部分，也是进程的的实际运作单位，它也是操作系统中的最小运算调度单位。\n\n\n前言\n多线程与多进程还是比较实用的。本博客以应用为目的展示两个基础的类。\n\n多进程 Process\n\nprocess模块是一个创建进程的模块，借助这个模块，就可以完成进程的创建。\nfrom multiprocessing import Process\n\n参数介绍\nProcess(group=N...",
  "content"  : "进程是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。线程是进程中的一部分，也是进程的的实际运作单位，它也是操作系统中的最小运算调度单位。\n\n\n前言\n多线程与多进程还是比较实用的。本博客以应用为目的展示两个基础的类。\n\n多进程 Process\n\nprocess模块是一个创建进程的模块，借助这个模块，就可以完成进程的创建。\nfrom multiprocessing import Process\n\n参数介绍\nProcess(group=None, target=None, name=None, args=(), kwargs={})\n\n\n\n  group——参数未使用，值始终为None\n  target——表示调用对象，即子进程要执行的任务\n  args——表示调用对象的位置参数元组，args=(1,2,’egon’,)\n  kwargs——表示调用对象的字典，kwargs={‘name’:’egon’,’age’:18}\n  name——为子进程的名称\n\n\n方法介绍\n\n  obj.start()：启动进程，并调用该子进程中的obj.run()\n  obj.run()：进程启动时运行的方法，正是它去调用target指定的函数，我们自定义类的类中一定要实现该方法\n  obj.terminate()：强制终止进程obj，不会进行任何清理操作，如果obj创建了子进程，该子进程就成了僵尸进程，使用该方法需要特别小心这种情况。如果obj还保存了一个锁那么也将不会被释放，进而导致死锁\n  obj.is_alive()：如果obj仍然运行，返回True\n  obj.join([timeout])：主线程等待obj终止（强调：是主线程处于等的状态，而obj是处于运行的状态）。timeout是可选的超时时间，需要强调的是，obj.join只能join住start开启的进程，而不能join住run开启的进程\n\n\n属性介绍\n\n  obj.daemon：默认值为False，如果设为True，代表obj为后台运行的守护进程，当obj的父进程终止时，obj也随之终止，并且设定为True后，obj不能创建自己的新进程，必须在\n  obj.start()：之前设置\n  obj.name：进程的名称\n  obj.pid：进程的pid\n  obj.exitcode：进程在运行时为None、如果为–N，表示被信号N结束(了解即可)\n  obj.authkey：进程的身份验证键,默认是由os.urandom()随机生成的32字符的字符串。这个键的用途是为涉及网络连接的底层进程间通信提供安全性，这类连接只有在具有相同的身份验证键时才能成功（了解即可）\n\n\n使用案例\nfrom multiprocessing import Process\nimport os\n\ndef worker(arg):\n    # 返回父子进程的pid\n    print(os.getpid(), os.getppid())\n\n\nif __name__ == &quot;__main__&quot;:\n    print(&#39;I am parent process&#39;)\n    jobs = []\n    for i in range(5):\n        p = Process(target=worker, args=(i,))\n        jobs.append(p)\n        p.start()\n\n方法介绍\n\n\n    \n    \n        \n    \n    \n\n\n使用样例\n利用函数使用多线程\nfrom threading import Thread\na = 0\ndef work():\n    global a\n    a += 1\n    print(a，end=’’)\n\nif __name__ == &#39;__main__&#39;:\n    childs = []\n    for i in range(5):\n        childs.append(Thread(target=work))\n        childs[-1].start()\n\n\n程序运行结果：\n1 2 3 4 5\n如果创建的不是线程而是进程则资源不会共享，运行结果会是：\n1 1 1 1 1\n\n利用类重写Thrrad方法实现多线程\nfrom threading import Thread\nimport time\nnum = 0\nchilds = []\nclass MyThread(Thread):\n    def run(self):\n        self.t = num\n\n        for _ in range(3):\n            print(self.t, &#39;线程正在工作&#39;)\n            time.sleep(0.5)\n\n\nfor i in range(3):\n    num = i + 1\n    childs.append(MyThread())\n    childs[-1].start()\n\n运行结果之一：\n1 线程正在工作\n2 线程正在工作\n3 线程正在工作\n132 线程正在工作 线程正在工作 \n线程正在工作\n\n13 线程正在工作\n2 线程正在工作\n 线程正在工作\n\n可以看到输出十分的杂乱，说明确实是多线程输出。\n"
} ,
  
  {
    "title"    : "OpenStack 期末复习",
    "category" : "",
    "tags"     : " OpenStack, 期末考试",
    "url"      : "/openstack",
    "date"     : "December 4, 2022",
    "excerpt"  : "OpenStack是Rackspace和NASA共同成立的一个开源项目，它是为云计算服务的，提供存储空间、计算能力等资源服务的Web Service。简单来说，OpenStack就是一个操作系统，一套软件，一套IaaS（基础设施即服务）软件，对资源进行管理，并且以服务的形式提供给上层应用或者用户去使用。\n\n\n\n前言\n\n以下为openstack的期末复习，考试考点整理，内容比较多且知识点生僻难懂，请好好准备，祝愿各位可以在期末获取一个好成绩！\n\n\n\n第一章考点\n\nOpenStack 的主要项...",
  "content"  : "OpenStack是Rackspace和NASA共同成立的一个开源项目，它是为云计算服务的，提供存储空间、计算能力等资源服务的Web Service。简单来说，OpenStack就是一个操作系统，一套软件，一套IaaS（基础设施即服务）软件，对资源进行管理，并且以服务的形式提供给上层应用或者用户去使用。\n\n\n\n前言\n\n以下为openstack的期末复习，考试考点整理，内容比较多且知识点生僻难懂，请好好准备，祝愿各位可以在期末获取一个好成绩！\n\n\n\n第一章考点\n\nOpenStack 的主要项目以及对应的项目名称\n\n\n  \n    \n      服务\n      直译\n      项目名称\n    \n  \n  \n    \n      Dashboard\n      仪表盘\n      Horizon\n    \n    \n      Computer\n      计算\n      Nova\n    \n    \n      Natwork\n      网络\n      Neutron\n    \n    \n      Object Storage\n      对象存储\n      Swift\n    \n    \n      Block Storage\n      块存储\n      Cindar\n    \n    \n      Identity\n      身份\n      Keystone\n    \n    \n      Image\n      镜像\n      Glance\n    \n    \n      Telemetry\n      计量\n      Ceilometer\n    \n    \n      Orchestration\n      编排\n      Heat\n    \n    \n      Database\n      数据库\n      Trove\n    \n    \n      Data Processing\n      数据处理\n      Sahara\n    \n  \n\n\n\n\n第四章考点\n\nREST 含义解释\nREST 是 Representational State Transfer 的缩写，通常译为表现层状态转化\n\n客户端在使用HTTP提供的四种操作（GET、POST、PUT、DELETE）访问服务器上的资源时，这些操作会让服务端的状态发生转化，而这种转化是建立在表现层之上的，所以被称之为表现层转化。\n\n\nOpenStack 的认证与API 请求流程\n\n\n  向云管理员提供的身份端点请求一个认证令牌。\n  如果请求成功，服务器会返回一个认证令牌。\n  发送API请求，并在X-Auht-Token头部包含上一步返回的令牌认证。\n  如果遇到未授权（401）的错误，则需要重新请求另一个令牌。\n\n\n获取OpenStack认证令牌\n\n\n  进入demo环境：source keystonerc_demo\n  运行命令cURL来请求一个令牌。\n\n\n发送API请求\n\n\n  设置OS_TOKEN环境变量，将其值设为令牌ID： export OS_TOKEN=令牌ID\n  设置OS_PROJECT_NAME环境变量：export OS_PROJECT_NAME=demo\n  设置OS_COMPUTE_API环境变量：export OS_COMPUTE_API=http://192.168.199.21:8774/v2.1\n  使用Compute API列出示例类型。\n\n\n\n第五章\n\nKeystone的管理层次结构\n\n\n    \n    \n        \n    \n    \n\n\n问：在一个域中的用户User1是否可以管理项目Project1\n\n答：可以，因为用户User1是系统管理员，拥有对项目Project1的管理权限。\n\n\nKeystone认证流程图\n这张图需要背下来。\n\n\n    \n    \n        \n    \n    \n\n\n对图片的解释：\n\n\n  用户向Keystone提供凭证，Keystone验证通过后向用户返回令牌的同时还会返回一个通用目录。\n  用户使用该令牌向该目录列表中的端点请求该用户对应的项目信息，Keystone验证通过后返回用户对应的项目列表\n  用户从列表中选择要访问的项目再次向Keystone发出请求，Keystone验证通过后返回管理该项目的服务列表，并允许访问该项目的令牌。\n  用户会通过这个服务和通用目录映射找到服务的端点，并通过端点找到实际服务组件的位置。\n  用户在凭借项目令牌和端点来访问实际上的服务组件。\n  服务组件会向Keystone提供这个用户项目令牌进行验证，Keystone验证通过后会返回一系列的确认信息和附加信息给服务\n  服务执行一系列操作。\n\n\n配置文件中对两个值的解释\n\n”” 空字符串\n表示“always”（总是）\n\n”!” 感叹号\n表示“nerver”或者“nobady”，即拒绝。\n\n小知识点\n\n\n  oslo.policy是json格式的文件。\n  openstack是使用python语言实现的。\n\n"
} ,
  
  {
    "title"    : "Jekyll 入门指导",
    "category" : "",
    "tags"     : " Jekyll, web前端",
    "url"      : "/jekyll",
    "date"     : "December 4, 2022",
    "excerpt"  : "jekyll是一个简单的免费的Blog生成工具，类似WordPress。但是和WordPress又有很大的不同，原因是jekyll只是一个生成静态网页的工具，不需要数据库支持。但是可以配合第三方服务,例如Disqus。最关键的是jekyll可以免费部署在Github上，而且可以绑定自己的域名。\n\n\n\n前言\n\n该博客的部署使用的就是Jekyll框架，Jekyll是一门很成熟的技术（也可能是有点老的缘故），他可以将makedown格式的文档转化成一个个静态的页面，即便你没有系统的学过前端三件套...",
  "content"  : "jekyll是一个简单的免费的Blog生成工具，类似WordPress。但是和WordPress又有很大的不同，原因是jekyll只是一个生成静态网页的工具，不需要数据库支持。但是可以配合第三方服务,例如Disqus。最关键的是jekyll可以免费部署在Github上，而且可以绑定自己的域名。\n\n\n\n前言\n\n该博客的部署使用的就是Jekyll框架，Jekyll是一门很成熟的技术（也可能是有点老的缘故），他可以将makedown格式的文档转化成一个个静态的页面，即便你没有系统的学过前端三件套也可以制作自己的主页（真的太棒了！）。\n\n对于使用者来说只需要找到对应的资源模板，套用jekyll即可得到你想要的博客。\n\n如果你想要了解更多，这个是Jekyll官网的传送门 \\(\\Longrightarrow\\) Jekyll\n\n\n\nJekyll 基础知识\n\n基本结构\nJekyll 也遵循「约定大于配置」的基本原则，所以上手成本极低。\n\n在新创建的项目目录下，有几个重要的文件夹：\n\n_layouts\n\n用于存放各种布局.html 的文件用于对.md文件的转换，在md设置的消息头中的变量，.md文件选择了layout布局之后，会引入对应的布局.html中，html会存放这些变量的默认值，\n\n_drafts\n\n用于存放.md博客的草稿，不会再jekyll工作的时候生成，需要使用指令jekyll server –draft 才会显示在界面中\n_posts\n\n用于存放博客文章\n_site\n\n用于存放项目构建完成之后所生成的静态文件，也就是说，静态网站的所有文件都会来源于此，其中 CSS 文件、JS 文件以及图片文件，会存放在该目录下的 assets 文件夹中。我们可以直接把该目录下的文件拿去部署\n\n除此之外，还有一些其他文件：\n_config.yml\n\n是项目的配置文件，一些全局配置会写在这个文件内，比如 collections（后续推文会讲解），默认文件/路径，等等。总之，这里可以自定义很多东西\n\n.gitignore\n\n创建项目时会自动生成，不需要纳入到 CVS 的文件存放于此，它可以限制一些元素在_site 中的生成\n\nGemfile &amp;amp; Gemfile.lock\n\n存放项目所依赖的 Ruby gems，里面拥有存放页面的样式信息，当新加入了主题配置之后，需要使用bundle install指令安装新的配置才能使用。需要使用新的主题时，需要在_config.yml文件的there做更改。注意，使用了新的布局之后可能会导致一些布局不可用，例如“post”，因为在新的主题上可能没有定义这样的布局。所以使用新的布局之后要在_layout中查看一下是否有对应的布局可以使用。\n\nabout.md\n\n会存放有关在界面中的about的内容，生成的页面会出现在主界面上的位置，同理命名其他的文件也会在主界面的上方出现\n\n\n\nmakedown 语法\npermalink\n可以用于自定义所创建页面的URL。例如，permalink：/Jekyll/ 表示创建的页面会在主页面URL中后加上/Jekyll\n\nlayout\n表示自己所使用的界面样式，常见的值有post\n\n._config.yml\n\n\n  defaults：可用于写一些默认值，例如为layout设置默认值（要注意以下冒号的位置）\n    defaults:\n  - \n scope:\n   path: &quot;&quot;  # 这里填写此默认值影响的返回路径\n values:   # 这里补充默认值\n     layout: &quot;post&quot;\n    \n    再例如对图片文件的加载：\n    defaults:\n  -\n scope:\n   path: &quot;assets/img&quot;\n values:\n   image: true\n    \n    该例子表示，在html文件中可能加载图片信息的位置会在，assets/img的文件夹下寻找\n  \n\n\n\n常用指令\n\n  jekyll new 工程名  创建工程\n  bundle exec jekyll server   启动项目，启动项目之后可以在浏览器中访问http://127.0.0.1:400/看到效果。\n  jekyll new PATH --blank  创建新的空项目\n  jekyll build 或 jekyll b 构建项目，生成可部署的 _site 目录\n  jekyll serve 或 jekyll s  构建并运行项目，会自动监听文件变化，不需要反复执行\n  jekyll clean  清除所有的构建产物\n  jekyll new-theme  创建一个新的主题脚手架\n  jekyll doctor  诊断，输出所有已经废弃的依赖包或者有问题的配置\n\n"
} ,
  
  {
    "title"    : "MySql 学习笔记",
    "category" : "",
    "tags"     : " MySql, 数据库",
    "url"      : "/mysql",
    "date"     : "December 3, 2022",
    "excerpt"  : "MySQL是一种关系型数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。\n\n\n前言\n本人比较懒，所以专门挑了一个篇幅比较少的MySql来写博客，主要还是针对笔记的性质来写的。如果有错欢迎指正。\n\n\n\nMySql 基本语法\n1.分组\nGROUP BY 字段名 [HAVING 条件表达式]\n\n2.去重\n在 select的字段前面加上distinct就可以去重\n\n3.插入多行数据\n\n格式：\ninsert into 表名[（字段名1...",
  "content"  : "MySQL是一种关系型数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。\n\n\n前言\n本人比较懒，所以专门挑了一个篇幅比较少的MySql来写博客，主要还是针对笔记的性质来写的。如果有错欢迎指正。\n\n\n\nMySql 基本语法\n1.分组\nGROUP BY 字段名 [HAVING 条件表达式]\n\n2.去重\n在 select的字段前面加上distinct就可以去重\n\n3.插入多行数据\n\n格式：\ninsert into 表名[（字段名1，字段名2,…）] values(值\\(a_1\\)，值\\(b_1\\),…), (值\\(a_2\\),值\\(b_2\\),…)\n\n示例：\ninsert into mywork\nvalues(&quot;小明&quot;,18),(&quot;小红&quot;,20)\n\n\n4.外连接\n语法：\nselect 字段列表 from 表1 [inner] join 表2 on 连接条件;\n示例:\n\nselect * \nfrom wuhan.commercialhousing \njoin secondhouse on district regexp qy\nlimit 10;\n\n\n同理还有左外连接：left join，右外连接：right join\n\n5.排序\n\n排序语句：order by 字段值[ desc | asc]\n其中 asc是表示升序（默认），表示降序\n\n示例：\nselect customer_number\nfrom Orders\ngroup by customer_number\norder by COUNT(*) desc\n\n\n6.if语句\n\n语法：IF(expr1,expr2,expr3)\n\n如果 expr1 是TRUE (或者expr1 &amp;lt;&amp;gt; 0 且 expr1 &amp;lt;&amp;gt; NULL)，则 IF()的返回值为expr2; 否则返回值则为 expr3。IF() 的返回值为数字值或字符串值，具体情况视其所在语境而定。\n\n7.ifnull语句\n\n语法：IFNULL(expr1,expr2)\nexpr1不为NULL，则 IFNULL() 的返回值为expr1; 否则其返回值为 expr2。IFNULL()的返回值是数字或是字符串，具体情况取决于其所使用的语境。\n\n8.正则语句\n\n关键字：regexp\n\n使用语法：被检测字符串 regexp [binary] 正则语句\n不区分大小写（即大写和小写都匹配）。为区分大小写，可以使用 BINARY 关键字例如：\nWHHERE name REGEXP BINARY &#39;Hern .000&#39;\n\n\n9.存在判断语句 exists\n\n当我们只需要判断某些满足特定条件的数据是否存在时，为了提高效率，我们不需要将所有的数据捞出来判断，只需要判断是否存在就可以了。\n采用exists即可满足需求。\n示例：\nselect exists (SELECT *\n        from  a \n        where\n        money&amp;gt;0 and time&amp;gt;&#39;2021-03-05&#39;;\n)\n\n\n10.表格合并\n\nUNION操作符合并两个或多个 SELECT 语句的结果。\nUNION关键字应处于两次查询之间\n默认地，UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL。\n示例1：\nSELECT column_name(s) FROM table1\nUNION\nSELECT column_name(s) FROM table2;\n\n示例2：\nSELECT column_name(s) FROM table1\nUNION ALL\nSELECT column_name(s) FROM table2;\n\n\nmysql常用函数\n\n日期比较函数：datediff\n\n语法：DATEDIFF(date1,date2)\n参数说明\ndate1: 比较日期1\ndate2: 比较日期2\n\nDATEDIFF函数返回date1 - date2的计算结果，date1和date2两个参数需是有效的日期或日期时间值;如果参数传递的是日期时间值，DATEDIFF函数仅将日期部分用于计算，并忽略时间部分(只有值的日期部分参与计算)\n\n示例：\nSELECT DATEDIFF(&#39;2022-04-29&#39;,&#39;2022-04-30&#39;); --返回 -1\nSELECT DATEDIFF(&#39;2022-04-30&#39;,&#39;2022-04-29&#39;); --返回 1\n\n\n日期加减函数：date_add\n\n语法：date_add(‘某个日期时间’,interval 1 时间种类名)\n示例：\n\nselect date_add(data, interval 1 year); --加1年\nselect date_add(fata, interval 1 month); --加1月\n\n\nquarter:季，week:周，day:天，hour:小时，minute:分钟，second:秒，microsecond:毫秒\n注：也可以不用变量，直接加减某个时间，如：select date_add(‘1998-01-01’, interval 1 day);\n\n字符串专题\n字符串拼接：concat\n\n将给入的参数逐一拼接\n例如：\nconcat(‘%’,’abc’,’%’) --结果为%abc%\n\n字符串与日期的相互转换\n使用语法：\nDATE_FORMAT(date,format) 日期转字符串\nSTR_TO_DATE(str,format) 字符串转日期\n示例：\n\nselect DATE_FORMAT(now(),&#39;%Y-%m-%d %H:%i:%s&#39;);\n\n返回：2022-12-01 10:07:41\n\nselect str_to_date(&#39;2022-8-7&#39;,&#39;%Y&#39;)\n\n返回：2022-00-00\n因为这里只获取到了年份，但是作为datetime对象需要补全月份和日所以会有-00-00出现。\n\n组内字符串拼接 group_concat\n\n语法：\nGROUP_CONCAT([DISTINCT] column1 [ORDER BY column2 ASC|DESC] [SEPARATOR seq])\n\n\n将分组中column1这一列对应的多行的值按照column2 升序或者降序进行连接，其中分隔符为seq\n如果用到了DISTINCT，将表示将不重复的column1按照column2升序或者降序连接\n如果没有指定SEPARATOR的话，也就是说没有写，那么就会默认以 ‘,’分隔\n\n字符串截取 substring\n语法格式：SUBSTRING(str, begin, end)\nsubstring函数可以将字符串str从下标begin到end截取下来（下标从1开始计算）（闭区间包括begin和end），其中end默认为空，当end省略时表示截取到字符串最后。\nmysq支持逆向访问，即可以使用负数表示下标，负数的下标即从右边开始计算的下标。\n示例：\nselect substring(&quot;01234&quot;,1,2);\t-- 01\nselect substring(&quot;01234&quot;,1);\t-- 01234\nselect substring(&quot;01234&quot;,1,100); -- 01234\nselect substring(&quot;01234&quot;,-1);\t-- 4\n\n\n字符串大小写转换\nupper(str)  字符串中所有字母转大写\nlower(str)  字符串中所有字母转小写\n\n技巧语法\n\n查询排名前n的数据\n\n使用limit n语句实现（该语句需要放在查询结果的最后）\n\n示例：\n\nSELECT * FROM wuhan.secondhouse limit 10;\n\n\n使用正则配对字符串\n\n使用regexp关键字实现\n格式： 字段值 regexp 正则字符串\n示例：\n\nselect distinct district,house_type,wq_area,wq_num,yqy_area,yqy_num\nfrom commercialhousing\nwhere district regexp &#39;江岸&#39;;\n\n"
} ,
  
  {
    "title"    : "博客测试",
    "category" : "",
    "tags"     : " Test, Image",
    "url"      : "/demo",
    "date"     : "October 18, 2013",
    "excerpt"  : "这里写需要展示在外部的内容，且需要与正文隔一个空行\n\n一级标题\n二级标题\n三级标题\n四级标题\n五级标题\n六级标题\n\n\n需要说明的一点是，makedown完全支持html格式的代码\n\n百度一下 超链接需要是http格式的\n\n这是一个公式 \\(a^2+b^2 &amp;gt; 2ab\\)\n\n这是一个行内代码块\n\n在写代码的时候可以用指定语言的方式来表现出不同的高亮，代码块之间需要有一个空行\ndef showw():\n    print(&quot;这是一个python代码块&quot;)\n\n\nvoid show(){\n ...",
  "content"  : "这里写需要展示在外部的内容，且需要与正文隔一个空行\n\n一级标题\n二级标题\n三级标题\n四级标题\n五级标题\n六级标题\n\n\n需要说明的一点是，makedown完全支持html格式的代码\n\n百度一下 超链接需要是http格式的\n\n这是一个公式 \\(a^2+b^2 &amp;gt; 2ab\\)\n\n这是一个行内代码块\n\n在写代码的时候可以用指定语言的方式来表现出不同的高亮，代码块之间需要有一个空行\ndef showw():\n    print(&quot;这是一个python代码块&quot;)\n\n\nvoid show(){\n    cout&amp;lt;&amp;lt;&quot;这是一个C++代码块&quot;;\n}\n\n\n斜体文字\n\n斜体文字\n\n粗体文字\n\n粗体文字\n\n粗斜体文字\n\n粗斜体文字\n\n\n\n\n\n\n\n删除线\n\n下划线\n\n\n  警告内容\n\n\n表格是制作方式类似于latex\n\n\n  \n    \n      hex\n      dec\n      oct\n    \n  \n  \n    \n      0\n      0\n      0\n    \n    \n      5\n      5\n      5\n    \n    \n      A\n      10\n      12\n    \n    \n      F\n      16\n      20\n    \n    \n      F5\n      21\n      25\n    \n  \n\n\n导入图片,图片的主路径在assets/img处\n不加column=1 参数的话图片就会居中\n\n\n    \n    \n        \n    \n    \n\n\n导入多张图片，只需要在图片导入的位置用，分隔即可\n\n\n    \n    \n        \n    \n    \n    \n        \n    \n    \n\n\n"
} 
  
  
  
]
