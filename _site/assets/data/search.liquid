[
  
  {
    "title"    : "毛概期末整理",
    "category" : "",
    "tags"     : " 毛概, 期末考试",
    "url"      : "/maogai",
    "date"     : "June 11, 2023",
    "excerpt"  : "  毛概是毛泽东思想和中国特色社会主义理论体系概论的简称。学习毛概有利于刚进入大学的学生思想的转变，更好的完成大学期间学习任务，提高大学生自我素质，增加应对现实中各种挑战的能力，尽快适应新的学习生活环境，完成大学期间的各项发展任务，成为社会发展的有用之才。\n\n\n\n前言\n  本次博客整理，针对毛概期末考试，知识点较多，请提前准备。\n  其中选择题部分可以在，学习通中找到对应的答案。本博客也对此作出整理\n\n\n\n目录\n\n\n  前言\n  目录\n  正文\n    \n      选择题\n       ...",
  "content"  : "  毛概是毛泽东思想和中国特色社会主义理论体系概论的简称。学习毛概有利于刚进入大学的学生思想的转变，更好的完成大学期间学习任务，提高大学生自我素质，增加应对现实中各种挑战的能力，尽快适应新的学习生活环境，完成大学期间的各项发展任务，成为社会发展的有用之才。\n\n\n\n前言\n  本次博客整理，针对毛概期末考试，知识点较多，请提前准备。\n  其中选择题部分可以在，学习通中找到对应的答案。本博客也对此作出整理\n\n\n\n目录\n\n\n  前言\n  目录\n  正文\n    \n      选择题\n        \n          导论部分\n          第一章\n          第二章\n          第三章\n          第四章\n          第五章\n          第六章\n          第七章\n          第八章\n          新思想第一章\n          新思想第二章\n          新思想第三章\n          新思想第四章\n          新思想第五章\n          新思想第六章\n        \n      \n      大题部分\n        \n          1 马克思主义中国化时代化的原因※\n          2 马克思主义中国化时代化的理论成果及其关系※\n          3 近代中国社会的性质、主要矛盾※\n          4 过渡时期社会的性质、经济成分、阶级构成和主要矛盾※\n          5 社会主义改造的历史经验※\n          6 社会主义改造完成后社会主要矛盾※\n          7 社会主义建设道路初步探索的意义和经验教训※\n          8 中国特色社会主义进入新时代的社会主要矛盾※\n          9 邓小平理论首要的基本的理论问题和精髓※\n          10 4.\t社会主义的本质※\n          11 “三个代表”重要思想回答的重大问题和核心观点及其关系※\n          12 科学发展观回答的重大问题和科学内涵※\n          13 习近平新时代中国特色社会主义思想回答的重大时代课题※\n          14 习近平新时代中国特色社会主义思想的历史地位※\n          15 中国式现代化的内涵、中国特色和本质要求※\n          16 新发展格局的内涵，构建新发展格局的意义和重点任务※\n        \n      \n    \n  \n\n\n\n正文\n\n选择题\n\n导论部分\n1\n【单选题】马克思主义中国化的第一个理论成果是（ ）。\n\nA、毛泽东思想\nB、邓小平理论\nC、“三个代表”重要思想\nD、科学发展观\n\n\n正确答案： A\n\n2\n【单选题】马克思主义中国化的命题是（ ）提出的。\n\nA、马克思\nB、列宁\nC、毛泽东\nD、邓小平\n\n\n正确答案： C\n\n3\n【单选题】在毛泽东思想的指导下，党领导人民完成了新民主主义革命，建立了中华人民共和国，中华民族从此（ ）了。\n\nA、站起来\nB、富起来\nC、强起来\nD、大起来\n\n\n正确答案： A\n\n4\n【单选题】100年来，中国共产党团结带领中国人民进行的一切奋斗、一切牺牲、一切创造，归结起来就是一个主题（ ）。\n\nA、实现民族独立、人民解放\nB、实现中华民族伟大复兴\nC、实现现代化\nD、实现共同富裕\n\n\n正确答案： B\n\n5\n【单选题】马克思主义中国化最新成果是（ ）。\n\nA、邓小平理论\nB、“三个代表”重要思想\nC、科学发展观\nD、习近平新时代中国特色社会主义思想\n\n\n正确答案： D\n\n1\n【多选题】马克思主义中国化的原因包括（ ）。\n\nA、解决中国实际问题的客观需要\nB、马克思主义理论发展的内在要求\nC、马克思主义理论提供了解决中国问题的现成答案\nD、马克思主义只能在中国发展\n\n\n正确答案： AB\n\n2\n【多选题】马克思主义中国化的两大理论成果是（ ）。\n\nA、毛泽东思想\nB、邓小平理论\nC、中国特色社会主义理论体系\nD、习近平新时代中国特色社会主义思想\n\n\n正确答案： AC\n\n3\n【多选题】中国特色社会主义理论体系包括（ ）。\n\nA、邓小平理论\nB、“三个代表”重要思想\nC、科学发展观\nD、习近平新时代中国特色社会主义思想\n\n\n正确答案： ABCD\n\n4\n【多选题】中国共产党百年创造的伟大成就是（ ）。\n\nA、创造了新民主主义革命的伟大成就\nB、创造了社会主义革命和建设的伟大成就\nC、创造了改革开放和社会主义现代化建设的伟大成就\nD、创造了新时代中国特色社会主义的伟大成就\n\n\n正确答案： ABCD\n\n5\n【多选题】学习本课程的目的是（ ）。\n\nA、准确把握马克思主义中国化进程中形成的理论成果\nB、深刻认识中国共产党领导人民进行的革命、建设、改革的历史进程、历史变革、历史成就\nC、透彻理解中国共产党在新时代坚持的基本理论、基本路线、基本方略\nD、切实提升运用马克思主义立场、观点和方法认识问题、分析问题和解决问题能力\n\n\n正确答案： ABCD\n\n\n\n第一章\n\n1\n【单选题】毛泽东思想形成的时代背景是（ ）。\n\nA、和平与发展\nB、战争与革命\nC、改革开放\nD、信息革命\n\n\n正确答案： B\n\n2\n【单选题】毛泽东思想形成的实践基础是（ ）。\n\nA、党领导的革命和建设的实践\nB、党领导的改革开放\nC、党领导的新民主主义革命\nD、党领导的社会主义建设\n\n\n正确答案： A\n\n3\n【单选题】把毛泽东思想确立为党的指导思想并写入党章是在（ ）。\n\nA、中共六大\nB、中共七大\nC、中共八大\nD、中共九大\n\n\n正确答案： B\n\n4\n【单选题】毛泽东思想围绕的主题是（ ）。\n\nA、中国革命和建设\nB、中国改革开放\nC、中国特色社会主义建设\nD、中华民族伟大复兴\n\n\n正确答案： A\n\n5\n【单选题】党的根本工作路线是（ ）。\n\nA、实事求是\nB、群众路线\nC、独立自主\nD、为人民服务\n\n\n正确答案： B\n\n1\n【多选题】毛泽东思想是（ ）。\n\nA、马克思主义中国化的第一个理论成果\nB、马克思列宁主义在中国的运用和发展\nC、关于中国革命和建设的正确理论原则和经验总结\nD、中国共产党集体智慧的结晶\n\n\n正确答案： ABCD\n\n2\n【多选题】毛泽东思想的主要内容包括新民主主义革命理论、社会主义革命和社会主义建设理论，还有（ ）。\n\nA、革命军队建设和军事战略的理论\nB、政策和策略的理论\nC、思想政治工作和文化工作的理论\nD、党的建设理论\n\n\n正确答案： ABCD\n\n3\n【多选题】毛泽东的哲学著作有（ ）。\n\nA、《反对本本主义》\nB、《实践论》\nC、《矛盾论》\nD、《人的正确思想是从哪里来的？》\n\n\n正确答案： ABCD\n\n4\n【多选题】毛泽东思想活的灵魂包括（ ）。\n\nA、实事求是\nB、群众路线\nC、独立自主\nD、与时俱进\n\n\n正确答案： ABC\n\n5\n【多选题】关于毛泽东的评价正确的是（ ）。\n\nA、毛泽东是伟大的马克思主义者，伟大的无产阶级革命家、战略家和理论家\nB、毛泽东晚年犯了严重错误，他的错误是第一位的，功绩是第二位的\nC、他为中国共产党和中国人民解放军的创立和发展做出了不可磨灭的贡献\nD、他对中国革命的功绩远远大于他的过失\n\n\n正确答案： ACD\n\n\n\n第二章\n\n1\n【单选题】新民主主义革命的性质是（ ）。\n\nA、无产阶级社会主义革命\nB、资产阶级民主主义革命\nC、农民革命\nD、土地革命\n\n\n正确答案： B\n\n2\n【单选题】新民主主义国家的国体是（ ）。\n\nA、资产阶级专政\nB、无产阶级专政\nC、人民民主专政\nD、各革命阶级联合专政\n\n\n正确答案： D\n\n3\n【单选题】近代中国革命斗争的主要形式是（ ）。\n\nA、工人罢工\nB、商人罢市\nC、学生罢课\nD、武装斗争\n\n\n正确答案： D\n\n4\n【单选题】新民主主义革命时期加强党的建设，必须把（ ）放在首位。\n\nA、思想建设\nB、组织建设\nC、作风建设\nD、制度建设\n\n\n正确答案： A\n\n5\n【单选题】新民主主义革命的道路是（ ）。\n\nA、城市包围农村，武装夺取政权\nB、农村包围城市，武装夺取政权\nC、城市包围农村，和平夺取政权\nD、农村包围城市，和平夺取政权\n\n\n正确答案： B\n\n1\n【多选题】新民主主义革命的对象包括（ ）。\n\nA、帝国主义\nB、封建主义\nC、民族资本主义\nD、官僚资本主义\n\n\n正确答案： ABD\n\n2\n【多选题】新民主主义革命的动力包括（ ）。\n\nA、无产阶级\nB、农民阶级\nC、城市小资产阶级\nD、民族资产阶级\n\n\n正确答案： ABCD\n\n3\n【多选题】近代中国无产阶级的特殊优点有（ ）。\n\nA、富于组织纪律性\nB、革命最坚决最彻底\nC、分布集中，便于组织和团结\nD、和农民有天然联系，便于结成工农联盟\n\n\n正确答案： BCD\n\n4\n【多选题】新民主主义的经济纲领是（ ）。\n\nA、没收封建地主阶级的土地归农民所有\nB、没收官僚资产阶级的垄断资本归新民主主义的国家所有\nC、没收民族工商业\nD、保护民族工商业\n\n\n正确答案： ABD\n\n5\n【多选题】新民主主义革命的三大法宝是（ ）。\n\nA、统一战线\nB、武装斗争\nC、党的建设\nD、土地革命\n\n\n正确答案： ABC\n\n\n\n第三章\n\n1\n【单选题】过渡时期我国社会的性质是（ ）。\n\nA、半殖民地半封建社会\nB、新民主主义社会\nC、资本主义社会\nD、社会主义社会\n\n\n正确答案： B\n\n2\n【单选题】新民主主义社会的主要矛盾是（ ）。\n\nA、地主阶级和农民阶级矛盾\nB、资产阶级和无产阶级矛盾\nC、无产阶级和小资产阶级矛盾\nD、农民阶级和小资产阶级矛盾\n\n\n正确答案： B\n\n3\n【单选题】中国共产党在过渡时期总路线的主体是（ ）。\n\nA、实现国家的社会主义工业化\nB、实现国家对农业的社会主义改造\nC、实现国家对手工业的社会主义改造\nD、实现国家对资本主义工商业的社会主义改造\n\n\n正确答案： A\n\n4\n【单选题】我国农业社会主义改造的道路是（ ）。\n\nA、直接没收\nB、和平赎买\nC、互助合作\nD、自愿上交\n\n\n正确答案： C\n\n5\n【单选题】社会主义制度在中国确立的标志是（ ）。\n\nA、1949年新中国成立\nB、1952年民主革命任务完成\nC、1954年《中华人民共和国宪法》颁布\nD、1956年底社会主义改造基本完成\n\n\n正确答案： D\n\n1\n【多选题】新民主主义社会的阶级构成是（ ）。\n\nA、工人阶级\nB、农民阶级\nC、小资产阶级\nD、民族资产阶级\n\n\n正确答案： ABCD\n\n2\n【多选题】我国农业社会主义改造步骤有（ ）。\n\nA、农业生产互助组\nB、初级农业生产合作社\nC、高级农业生产合作社\nD、社会主义集体农庄\n\n\n正确答案： ABC\n\n3\n【多选题】我国能够采取赎买的方式对资本主义工商业进行和平改造的原因有（ ）。\n\nA、在社会主义革命阶段，民族资产阶级既有剥削工人取得利润的一面，又有拥护宪法、愿意接受社会主义改造的一面\nB、中国共产党与民族资产阶级长期保持着统一战线的关系\nC、我国已经有了以工人阶级为领导、工农联盟为基础的人民民主专政的国家政权\nD、建立了强大的社会主义国营经济并掌握了国家的经济命脉\n\n\n正确答案： ABCD\n\n4\n【多选题】我国社会主义改造的历史经验有（ ）。\n\nA、社会主义工业化建设与社会主义改造同时并举\nB、采取积极引导、逐步过渡的方式\nC、用和平方法进行改造\nD、走互助合作的道路\n\n\n正确答案： ABC\n\n5\n【多选题】1956年底，我国社会主义改造基本完成，标志着（ ）。\n\nA、社会主义制度在我国已经确立\nB、我国进入了社会主义初级阶段\nC、我国步入了社会主义改革时期\nD、我国实现了新民主主义向社会主义过渡\n\n\n正确答案： ABD\n\n\n\n第四章\n1\n【单选题】毛泽东在《论十大关系》中提出社会主义建设的基本方针是（ ）。\n\nA、多快好省地建设社会主义\nB、以经济建设为中心\nC、以阶级斗争为纲\nD、调动一切积极因素为社会主义事业服务\n\n\n2\n【单选题】我国社会主义社会基本矛盾性质是（ ）。\n\nA、对抗性的矛盾\nB、非对抗性的矛盾\nC、适应性的矛盾\nD、非适应性的矛盾\n\n\n3\n【单选题】毛泽东指出，解决人民内部矛盾的方法是（ ）。\n\nA、民主方法\nB、专政方法\nC、法律制裁方法\nD、劳动改造方法\n\n\n4\n【单选题】毛泽东强调，社会主义国家政治生活的主题是（ ）。\n\nA、阶级斗争\nB、革命\nC、正确处理人民内部矛盾\nD、经济建设\n\n\n5\n【单选题】中国共产党强调，我国实现四个现代化关键在于（ ）。\n\nA、农业现代化\nB、工业现代化\nC、国防现代化\nD、科学技术现代化\n\n\n1\n【多选题】我国社会主义社会存在两类不同性质矛盾是指（ ）。\n\nA、主要矛盾\nB、基本矛盾\nC、敌我矛盾\nD、人民内部矛盾\n\n\n2\n【多选题】处理人民内部矛盾的民主方法有（ ）。\n\nA、讨论的方法\nB、批评的方法\nC、说服教育的方法\nD、强迫劳动的方法\n\n\n3\n【多选题】毛泽东关于走中国工业化道路的思想包括（ ）。\n\nA、把重工业作为我国经济建设的重点\nB、必须充分注意发展农业和轻工业\nC、以农业为基础，以工业为主导，以农轻重为序发展国民经济的总方针\nD、一整套“两条腿走路”的工业化发展思路\n\n\n4\n【多选题】毛泽东提出，社会主义可以分为两个阶段（ ）。\n\nA、不发达的社会主义\nB、比较发达的社会主义\nC、社会主义初级阶段\nD、社会主义高级阶段\n\n\n5\n【多选题】我国社会主义建设道路初步探索的意义有（ ）。\n\nA、巩固和发展了我国的社会主义制度\nB、为开创中国特色社会主义提供了宝贵经验、理论准备、物质基础\nC、丰富了科学社会主义的理论和实践\nD、为其他国家的社会主义建设提供了经验和借鉴\n\n\n\n\n第五章\n\n1\n【单选题】当今时代主题是（ ）。\n\nA、和平与发展\nB、战争与革命\nC、改革与开放\nD、创新与变革\n\n\n2\n【单选题】我国发展新的历史方位是（ ）。\n\nA、中国特色社会主义进入了新时代\nB、中国特色社会主义进入了新阶段\nC、中国特色社会主义进入了新时期\nD、中国特色社会主义进入了新征程\n\n\n3\n【单选题】中国特色社会主义理论体系形成发展的实践基础是（ ）。\n\nA、党领导的新民主主义革命\nB、党领导的社会主义改造\nC、党领导的社会主义建设\nD、党领导的改革开放和社会主义现代化建设\n\n\n4\n【单选题】提出了“建设有中国特色的社会主义”的重大命题是（ ）。\n\nA、毛泽东\nB、邓小平\nC、江泽民\nD、胡锦涛\n\n\n5\n【单选题】（ ）把习近平新时代中国特色社会主义思想确立为党的指导思想。\n\nA、党的十七大\nB、党的十八大\nC、党的十九大\nD、党的二十大\n\n\n1\n【多选题】百年未有之大变局是指（ ）。\n\nA、当前国际格局和国际体系正在发生深刻调整\nB、全球治理体系正在发生深刻变革\nC、国际力量对比正在发生近代以来最具革命性的变化\nD、世界范围呈现出影响人类历史进程和趋向的重大态势\n\n\n2\n【多选题】习近平新时代中国特色社会主义思想回答的时代课题是（ ）。\n\nA、什么是马克思主义中国化时代化，怎样推进马克思主义中国化时代化\nB、新时代坚持和发展什么样的中国特色社会主义、怎样坚持和发展中国特色社会主义\nC、建设什么样的社会主义现代化强国、怎样建设社会主义现代化强国\nD、建设什么样的长期执政的马克思主义政党、怎样建设长期执政的马克思主义政党\n\n\n3\n【多选题】习近平新时代中国特色社会主义思想的主要内容是（ ）。\n\nA、“十个明确”\nB、“十四个坚持”\nC、“十三个方面成就”\nD、“十个结合”\n\n\n4\n【多选题】习近平新时代中国特色社会主义思想的历史地位是（ ）。\n\nA、当代中国马克思主义、21世纪马克思主义\nB、中华文化和中国精神的时代精华\nC、中国特色社会主义理论体系的重要组成部分\nD、实现中华民族伟大复兴的行动指南\n\n\n5\n【多选题】中国特色社会主义理论体系是（ ）。\n\nA、马克思主义中国化时代化的重大理论成果\nB、全党全国各族人民团结奋斗的共同思想基础\nC、坚持和发展中国特色社会主义的行动指南\nD、全面推进中华民族伟大复兴的根本指针\n\n\n\n\n第六章\n\n1\n【单选题】邓小平理论回答的首要的基本理论问题是（ ）。\n\nA、什么是马克思主义中国化，怎样马克思主义中国化\nB、什么是社会主义，怎样建设社会主义\nC、建设什么样的党，怎样建设党\nD、实现什么样的发展，怎样发展\n\n\n正确答案： B\n\n2\n【单选题】邓小平理论的精髓是（ ）。\n\nA、解放思想、实事求是\nB、与时俱进、求真务实\nC、改革开放、自力更生\nD、发展生产、共同富裕\n\n\n正确答案： A\n\n3\n【单选题】社会主义的根本任务是（ ）。\n\nA、消灭剥削\nB、改革开放\nC、发展生产力\nD、实现共同富裕\n\n\n正确答案： C\n\n4\n【单选题】社会主义社会发展的直接动力是（ ）。\n\nA、革命\nB、创新\nC、开放\nD、改革\n\n\n正确答案： D\n\n5\n【单选题】中国特色社会主义理论体系的开篇之作是（ ）。\n\nA、邓小平理论\nB、“三个代表”重要思想\nC、科学发展观\nD、习近平新时代中国特色社会主义思想\n\n\n正确答案： A\n\n1\n【多选题】社会主义的本质是（ ）。\n\nA、解放生产力，发展生产力\nB、消灭剥削，消除两极分化\nC、最终达到共同富裕\nD、按劳分配\n\n\n正确答案： ABC\n\n2\n【多选题】党在社会主义初级阶段的基本路线中“两个基本点”是指（ ）。\n\nA、坚持党的领导\nB、坚持四项基本原则\nC、坚持改革开放\nD、坚持独立自主，自力更生\n\n\n正确答案： BC\n\n3\n【多选题】邓小平提出的“三步走”发展战略是（ ）。\n\nA、从1981年到1990年实现国民生产总值比1980年翻一番，解决人民的温饱问题\nB、从1991年到20世纪末，使国民生产总值再翻一番，达到小康水平\nC、到建党一百周年时，全面建成小康社会\nD、到21世纪中叶，国民生产总值再翻两番，达到中等发达国家水平，基本实现现代化\n\n\n正确答案： ABD\n\n4\n【多选题】社会主义市场经济理论的要点有（ ）。\n\nA、计划经济和市场经济不是划分社会制度的标志，计划经济不等于社会主义，市场经济也不等于资本主义\nB、计划和市场都是经济手段，对经济活动的调节各有优势和长处，社会主义实行市场经济要把两者结合起来\nC、市场经济作为资源配置的一种方式本身不具有制度属性，可以和不同的社会制度结合，但它和不同社会制度结合具有不同的性质\nD、计划经济是社会主义的基本特征，市场经济是资本主义特有的东西\n\n\n正确答案： ABC\n\n5\n【多选题】邓小平提出的“两手抓”的思想有（ ）。\n\nA、一手抓工业，一手抓农业\nB、一手抓物质文明，一手抓精神文明\nC、一手抓建设，一手抓法制\nD、一手抓改革开放，一手抓惩治腐败\n\n\n正确答案： BCD\n\n\n\n第七章\n\n1\n【单选题】“三个代表”重要思想回答的重大问题是（ ）。\n\nA、什么是马克思主义中国化，怎样马克思主义中国化\nB、什么是社会主义，怎样建设社会主义\nC、建设什么样的党，怎样建设党\nD、实现什么样的发展，怎样发展\n\n\n正确答案： C\n\n2\n【单选题】党执政兴国的第一要务是（ ）。\n\nA、发展\nB、改革\nC、开放\nD、创新\n\n\n正确答案： A\n\n3\n【单选题】党的十四大确立了我国经济体制改革的目标是（ ）。\n\nA、建立公有制为主体，多种所有制经济共同发展的经济制度\nB、实行按劳分配为主体，多种分配方式并存的收入分配制度\nC、建立完善的社会保障体系\nD、建立社会主义市场经济体制\n\n\n正确答案： D\n\n4\n【单选题】党领导人民治理国家的基本方略是（ ）。\n\nA、依法治国\nB、以德治国\nC、依人治国\nD、以仁治国\n\n\n正确答案： A\n\n5\n【单选题】标志着我国对外开放进入了一个新的阶段是（ ）。\n\nA、创办经济特区\nB、加入世界贸易组织\nC、建立自贸区\nD、建立自由港\n\n\n正确答案： B\n\n1\n【多选题】“三个代表”重要思想的核心观点是（ ）。\n\nA、始终代表中国先进生产力的发展要求\nB、始终代表中国先进文化的前进方向\nC、始终代表中国最广大人民的根本利益\nD、始终代表发展中国家利益\n\n\n正确答案： ABC\n\n2\n【多选题】正确认识和处理改革、发展、稳定的关系，要（ ）。\n\nA、把改革的力度、发展的速度和社会可承受的程度统一起来\nB、把不断改善人民生活作为处理改革发展稳定关系的重要结合点\nC、在社会稳定中推进改革发展，通过改革发展促进社会稳定\nD、坚持发展是第一要务，为了发展可以牺牲稳定\n\n\n正确答案： ABC\n\n3\n【多选题】党的十五大把“三步走”战略的第三步进一步具体化，提出了三个阶段性目标是（ ）。\n\nA、21世纪第一个10年，实现国民生产总值比2000年翻一番，使人民的小康生活更加富裕，形成比较完善的社会主义市场经济体制\nB、到建党100周年时，全面建成小康社会\nC、到建党100周年时，使国民经济更加发展，各项制度更加完善\nD、到21世纪中叶新中国成立100周年时，基本实现现代化，建成富强民主文明的社会主义国家\n\n\n正确答案： ACD\n\n4\n【多选题】在党的十六大报告中，江泽民把社会主义（ ）一起确立为社会主义现代化全面发展的三大基本目标。\n\nA、物质文明\nB、政治文明\nC、社会文明\nD、精神文明\n\n\n正确答案： ABD\n\n5\n【多选题】江泽民提出领导干部要“三讲”，是指（ ）。\n\nA、讲纪律\nB、讲学习\nC、讲政治\nD、讲正气\n\n\n正确答案： BCD\n\n\n\n第八章\n\n1\n【单选题】科学发展观回答的重大问题是（ ）。\n\nA、什么是马克思主义中国化，怎样马克思主义中国化\nB、什么是社会主义，怎样建设社会主义\nC、建设什么样的党，怎样建设党\nD、实现什么样的发展，怎样发展\n\n\n正确答案： D\n\n2\n【单选题】科学发展观的核心立场是（ ）。\n\nA、发展\nB、以人为本\nC、全面协调可持续\nD、统筹兼顾\n\n\n正确答案： B\n\n3\n【单选题】转变经济发展方式的重大战略决策（ ）。\n\nA、实施创新驱动发展战略\nB、全面深化经济体制改革\nC、促进区域协调发展\nD、推动城乡发展一体化\n\n\n正确答案： A\n\n4\n【单选题】社会主义民主政治的本质和核心要求（ ）。\n\nA、党的领导\nB、人民当家作主\nC、依法治国\nD、自由人权\n\n\n正确答案： B\n\n5\n【单选题】（ ）是中国特色社会主义的本质属性。\n\nA、繁荣富强\nB、民主法治\nC、社会和谐\nD、生态优美\n\n\n正确答案： C\n\n1\n【多选题】科学发展观的基本要求是（ ）。\n\nA、全面\nB、共享\nC、协调\nD、可持续\n\n\n正确答案： ACD\n\n2\n【多选题】社会主义核心价值体系的基本内容包括（ ）。\n\nA、马克思主义指导思想\nB、中国特色社会主义共同理想\nC、以爱国主义为核心的民族精神和以改革创新为核心的时代精神\nD、社会主义荣辱观\n\n\n正确答案： ABCD\n\n3\n【多选题】构建社会主义和谐社会的总要求是（ ）。\n\nA、民主法治、公平正义\nB、诚信友爱、充满活力\nC、安定有序、人与自然和谐相处\nD、共建共享\n\n\n正确答案： ABC\n\n4\n【多选题】建设社会主义生态文明必须树立的生态文明理念有（ ）。\n\nA、改造自然\nB、尊重自然\nC、顺应自然\nD、保护自然\n\n\n正确答案： BCD\n\n5\n【多选题】新形势下，党面临的考验有（ ）。\n\nA、执政考验\nB、改革开放考验\nC、市场经济考验\nD、外部环境考验\n\n\n正确答案： ABCD\n\n\n\n新思想第一章\n\n1\n【单选题】马克思主义中国化时代化的最新理论成果是（ ）。\n\nA、邓小平理论\nB、“三个代表”重要思想\nC、科学发展观\nD、习近平新时代中国特色社会主义思想\n\n\n正确答案： D\n\n2\n【单选题】新时代我国社会主要矛盾是（ ）。\n\nA、人民对于建立先进的工业国的要求同落后的农业国的现实之间的矛盾\nB、人民对于经济文化迅速发展的需要同当前经济文化不能满足人民需要的状况之间的矛盾\nC、人民日益增长的物质文化需要同落后的社会生产之间的矛盾\nD、人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾\n\n\n正确答案： D\n\n3\n【单选题】习近平新时代中国特色社会主义思想始终坚持以（ ）为中心。\n\nA、经济\nB、人民\nC、发展\nD、改革\n\n\n正确答案： B\n\n4\n【单选题】习近平新时代中国特色社会主义思想的主要创立者是（ ）。\n\nA、习近平\nB、江泽民\nC、胡锦涛\nD、邓小平\n\n\n正确答案： A\n\n5\n【单选题】（ ）把习近平新时代中国特色社会主义思想确立为党的指导思想。\n\nA、党的十七大\nB、党的十八大\nC、党的十九大\nD、党的二十大\n\n\n正确答案： C\n\n1\n【多选题】坚持和发展中国特色社会主义的总任务是（ ）。\n\nA、实现社会主义现代化\nB、实现中华民族伟大复兴\nC、实现共同富裕\nD、实现全面小康\n\n\n正确答案： AB\n\n2\n【多选题】习近平新时代中国特色社会主义思想回答的时代课题是（ ）。\n\nA、什么是马克思主义中国化时代化，怎样推进马克思主义中国化时代化\nB、新时代坚持和发展什么样的中国特色社会主义、怎样坚持和发展中国特色社会主义\nC、建设什么样的社会主义现代化强国、怎样建设社会主义现代化强国\nD、建设什么样的长期执政的马克思主义政党、怎样建设长期执政的马克思主义政党\n\n\n正确答案： BCD\n\n3\n【多选题】习近平新时代中国特色社会主义思想的主要内容包括（ ）。\n\nA、“十个明确”\nB、“十四个坚持”\nC、“十三个方面成就”\nD、“三个务必”\n\n\n正确答案： ABC\n\n4\n【多选题】习近平新时代中国特色社会主义思想的世界观和方法论是（ ）。\n\nA、必须坚持人民至上和自信自立\nB、必须坚持守正创新和问题导向\nC、必须坚持改革开放和独立自主\nD、必须坚持系统观念和胸怀天下\n\n\n正确答案： ABD\n\n5\n【多选题】习近平新时代中国特色社会主义思想的历史地位是（ ）。\n\nA、当代中国马克思主义、21世纪马克思主义\nB、中国特色社会主义理论体系的开篇之作\nC、中华文化和中国精神的时代精华\nD、实现中华民族伟大复兴的行动指南\n\n\n正确答案： ACD\n\n\n\n新思想第二章\n\n1\n【单选题】从2020年到2035年，我国发展目标是（ ）。\n\nA、解决温饱问题\nB、全面建成小康社会\nC、基本实现现代化\nD、建成社会主义现代化强国\n\n\n正确答案： C\n\n2\n【单选题】决定当代中国命运的关键一招是（ ）。\n\nA、实现国家统一\nB、党的自我革命\nC、改革开放\nD、全面依法治国\n\n\n正确答案： C\n\n3\n【单选题】全面深化改革要坚持的原则是（ ）。\n\nA、坚持和完善中国特色社会主义制度\nB、坚持党对改革的集中统一领导\nC、坚持人民立场\nD、坚持社会主义市场经济改革方向\n\n\n正确答案： B\n\n4\n【单选题】（ ）是伟大的自我革命。\n\nA、全面建设社会主义现代化国家\nB、全面深化改革\nC、全面依法治国\nD、全面从严治党\n\n\n正确答案： D\n\n5\n【单选题】全面从严治党，要把（ ）摆在首位。\n\nA、政治建设\nB、思想建设\nC、组织建设\nD、作风建设\n\n\n正确答案： A\n\n1\n【多选题】“四个全面”战略布局中战略举措是（ ）。\n\nA、全面深化改革\nB、全面依法治国\nC、全面从严治党\nD、全面建设社会主义现代化国家\n\n\n正确答案： ABC\n\n2\n【多选题】全面深化改革的总目标是（ ）。\n\nA、完善和发展中国特色社会主义制度\nB、推进国家治理体系和治理能力现代化\nC、建立完善的社会主义市场经济体制\nD、建立完善的社会治理体制\n\n\n正确答案： AB\n\n3\n【多选题】全面依法治国的总目标是（ ）。\n\nA、完善和发展中国特色社会主义制度\nB、推进国家治理体系和治理能力现代化\nC、建设中国特色社会主义法治体系\nD、建设社会主义法治国家\n\n\n正确答案： CD\n\n4\n【多选题】走中国特色社会主义法治道路（ ）。\n\nA、是学习西方先进法治经验的必然结果\nB、是历史的必然结论\nC、是由我国社会主义国家性质所决定的\nD、是立足我国基本国情的必然选择\n\n\n正确答案： BCD\n\n5\n【多选题】中国特色社会主义法治道路的核心要义是（ ）。\n\nA、坚持党的领导\nB、坚持中国特色社会主义制度\nC、维护公平正义\nD、贯彻中国特色社会主义法治理论\n\n\n正确答案： ABD\n\n\n\n新思想第三章\n\n1\n【单选题】新发展格局是指（ ）。\n\nA、以国内大循环为主体、以国际大双循环为辅助\nB、以国际大循环为主体、以国内大双循环为辅助\nC、以国内大循环为主体、国内国际双循环相互促进\nD、以国际大循环为主体、国内国际双循环相互促进\n\n\n正确答案： C\n\n2\n【单选题】我国的根本政治制度是（ ）。\n\nA、人民代表大会制度\nB、中国共产党领导的多党合作和政治协商制度\nC、民族区域自治制度\nD、基层群众自治制度\n\n\n正确答案： A\n\n3\n【单选题】（ ）是中国社会主义民主政治中独特的、独有的、独到的民主形式。\n\nA、选举民主\nB、协商民主\nC、人民民主\nD、全面民主\n\n\n正确答案： B\n\n4\n【单选题】（ ）是一个国家、一个民族发展中更基本、更深沉、更持久的力量。\n\nA、道路自信\nB、理论自信\nC、制度自信\nD、文化自信\n\n\n正确答案： D\n\n5\n【单选题】我国社会建设的重点是（ ）。\n\nA、保障和改善民生\nB、创新社会管理\nC、建设平安中国\nD、建设美丽中国\n\n\n正确答案： A\n\n1\n【多选题】我国进入了新发展阶段的依据是（ ）。\n\nA、从理论依据来看，新发展阶段是社会主义初级阶段中的一个阶段\nB、从历史依据来看，新发展阶段是我们党带领人民迎来从站起来、富起来到强起来历史性跨越的新阶段\nC、从现实依据来看，我们已经拥有开启新征程、实现新的更高目标的雄厚物质基础\nD、从国际比较来看，我国已经进入世界发达国家行列\n\n\n正确答案： ABC\n\n2\n【多选题】新时代爱国统一战线的组成包括（ ）。\n\nA、全体社会主义劳动者\nB、社会主义事业的建设者\nC、拥护社会主义的爱国者\nD、拥护祖国统一和致力于中华民族伟大复兴的爱国者\n\n\n正确答案： ABCD\n\n3\n【多选题】社会主义核心价值观的基本内容是（ ）。\n\nA、富强、民主、文明、和谐\nB、自由、平等、公正、法治\nC、自强、弘毅、求是、拓新\nD、爱国、敬业、诚信、友善\n\n\n正确答案： ABD\n\n4\n【多选题】经济发展与改善民生的关系是（ ）。\n\nA、经济发展是改善民生的前提\nB、抓民生可以促进经济发展\nC、经济发展为改善民生提供物质基础\nD、改善民生是经济发展的目的\n\n\n正确答案： ABCD\n\n5\n【多选题】关于绿水青山就是金山银山理解正确的是（ ）。\n\nA、阐述了经济发展和生态环境保护的关系\nB、揭示了保护生态环境就是保护生产力、改善生态环境就是发展生产力的道理\nC、绿水青山既是自然财富、生态财富，又是社会财富、经济财富\nD、保护生态环境就是保护自然价值和增值自然资本，就是保护经济社会发展潜力和后劲，使绿水青山持续发挥生态效益和经济社会效益\n\n\n正确答案： ABCD\n\n\n\n新思想第四章\n\n1\n【单选题】（ ）是安邦定国的重要基石。\n\nA、社会和谐\nB、国家安全\nC、民族团结\nD、国家统一\n\n\n正确答案： B\n\n2\n【单选题】总体国家安全观是（ ）提出的。\n\nA、邓小平\nB、江泽民\nC、胡锦涛\nD、习近平\n\n\n正确答案： D\n\n3\n【单选题】维护国家安全和社会安定的根本保证是（ ）。\n\nA、坚持推进国家安全体系和能力现代化\nB、坚持统筹发展和安全\nC、坚持党对国家安全工作的绝对领导\nD、坚持中国特色国家安全道路\n\n\n正确答案： C\n\n4\n【单选题】坚持总体国家安全观，要以（ ）为宗旨。\n\nA、人民安全\nB、政治安全\nC、经济安全\nD、文化安全\n\n\n正确答案： A\n\n5\n【单选题】坚持总体国家安全观，把（ ）放在首要位置。\n\nA、人民安全\nB、政治安全\nC、经济安全\nD、文化安全\n\n\n正确答案： B\n\n1\n【多选题】关于总体国家安全观理解正确的是（ ）。\n\nA、关键在“总体”\nB、强调打总体战\nC、突出的是大安全理念\nD、强调科学统筹\n\n\n正确答案： ABCD\n\n2\n【多选题】中华优秀传统文化中蕴含着丰富的国家安全战略思想有（ ）。\n\nA、安而不忘危，存而不忘亡，治而不忘乱\nB、民为邦本，本固邦宁\nC、内事文而和，外事武而义\nD、亲人善邻，国之宝也\n\n\n正确答案： ABCD\n\n3\n【多选题】做好国家安全工作要加强科学统筹，做到（ ）。\n\nA、统筹发展和安全\nB、统筹开放和安全\nC、统筹传统安全和非传统安全\nD、统筹自身安全和共同安全\n\n\n正确答案： ABCD\n\n4\n【多选题】政治安全的核心是政权安全和制度安全，最根本的就是（ ）。\n\nA、维护中国共产党的领导和执政地位\nB、维护中国特色社会主义制度\nC、维护国家主权和安全\nD、维护最广大人民的根本利益\n\n\n正确答案： AB\n\n5\n【多选题】总体国家安全观是（ ）。\n\nA、党历史上第一个被确立为国家安全工作指导思想的重大战略思想\nB、马克思主义国家安全理论中国化的最新成果\nC、习近平新时代中国特色社会主义思想的重要组成部分\nD、新时代国家安全工作的根本遵循和行动指南\n\n\n正确答案： ABCD\n\n\n新思想第五章\n\n1\n【单选题】中国坚持以（ ）为底线维护国家主权、安全、发展利益。\n\nA、国际责任\nB、国家核心利益\nC、世界和平\nD、独立自主\n\n\n正确答案： B\n\n2\n【单选题】中国坚持以（ ）为理念引领全球治理体系改革。\n\nA、平等互信\nB、合作共赢\nC、公平正义\nD、相互尊重\n\n\n正确答案： C\n\n3\n【单选题】中国坚持以（ ）为原则推动“一带一路”建设。\n\nA、共商共建共享\nB、互利共赢\nC、公平正义\nD、独立自主\n\n\n正确答案： A\n\n4\n【单选题】中国外交政策的宗旨是（ ）。\n\nA、维护世界和平和促进共同发展\nB、维护国家主权和利益\nC、建立国际政治经济新秩序\nD、反对霸权主义和强权政治\n\n\n正确答案： A\n\n5\n【单选题】“一带一路”倡议是（ ）提出的。\n\nA、邓小平\nB、江泽民\nC、胡锦涛\nD、习近平\n\n\n正确答案： D\n\n1\n【多选题】习近平外交思想是（ ）。\n\nA、习近平新时代中国特色社会主义思想的重要组成部分\nB、马克思主义基本原理同中国特色大国外交实践相结合的重大理论结晶\nC、以习近平同志为核心的党中央治国理政思想在外交领域的集中体现\nD、新时代我国对外工作的根本遵循和行动指南\n\n\n正确答案： ABCD\n\n2\n【多选题】新型国际关系“新”在（ ）。\n\nA、共建共享\nB、相互尊重\nC、公平正义\nD、合作共赢\n\n\n正确答案： BCD\n\n3\n【多选题】构建人类命运共同体的核心是（ ）。\n\nA、政治上，要相互尊重、平等协商，坚决摒弃冷战思维和强权政治，走对话而不对抗、结伴而不结盟的国与国交往新路\nB、安全上，要坚持以对话解决争端、以协商化解分歧，统筹应对传统和非传统安全威胁，反对一切形式的恐怖主义\nC、经济上，要同舟共济，促进贸易和投资自由化便利化，推动经济全球化朝着更加开放、包容、普惠、平衡、共赢的方向发展\nD、文化上，要尊重世界文明多样性，以文明交流超越文明隔阂、文明互鉴超越文明冲突、文明共存超越文明优越\nE、生态上，要坚持环境友好，合作应对气候变化，保护好人类赖以生存的地球家园\n\n\n正确答案： ABCDE\n\n4\n【多选题】“一带一路”是指（ ）。\n\nA、“丝绸之路经济带”\nB、“21世纪海上丝绸之路”\nC、长江经济带\nD、中欧铁路\n\n\n正确答案： AB\n\n5\n【多选题】丝绸之路精神的核心是（ ）。\n\nA、和平合作\nB、开放包容\nC、互学互鉴\nD、互利共赢\n\n\n正确答案： ABCD\n\n\n\n新思想第六章\n\n1\n【单选题】中国特色社会主义最本质的特征是（ ）。\n\nA、党的领导\nB、人民当家作主\nC、依法治国\nD、社会和谐\n\n\n正确答案： A\n\n2\n【单选题】中国特色社会主义制度的最大优势是（ ）。\n\nA、人民当家作主\nB、协商民主\nC、党的领导\nD、法律面前人人平等\n\n\n正确答案： C\n\n3\n【单选题】我国最高政治领导力量是（ ）。\n\nA、全国人民代表大会\nB、中国共产党\nC、国务院\nD、中国人民政治协商会议\n\n\n正确答案： B\n\n4\n【单选题】实现中华民族伟大复兴关键在（ ）。\n\nA、改革开放\nB、依法治国\nC、以人民为中心\nD、党\n\n\n正确答案： D\n\n5\n【单选题】我国的根本领导制度是（ ）。\n\nA、党的领导制度\nB、人民代表大会制度\nC、民族区域自治制度\nD、基层群众自治制度\n\n\n正确答案： A\n\n1\n【多选题】中国共产党的性质是（ ）。\n\nA、中国工人阶级的先锋队\nB、中国人民先锋队\nC、中华民族的先锋队\nD、全体中国人的先锋队\n\n\n正确答案： ABC\n\n2\n【多选题】党的领导是中国特色社会主义制度的最大优势，是因为（ ）。\n\nA、中国特色社会主义制度是党领导人民创建的\nB、党的领导是充分发挥中国特色社会主义制度优势的根本保障\nC、中国特色社会主义制度本身固有的\nD、党的自身优势是中国特色社会主义制度优势的主要来源\n\n\n正确答案： ABD\n\n3\n【多选题】党的领导决策核心是（ ）。\n\nA、中央委员会\nB、中央政治局\nC、中央政治局常委会\nD、全国代表大会\n\n\n正确答案： ABC\n\n4\n【多选题】党是最高政治领导力量，原因是（ ）。\n\nA、与生俱来的\nB、由国家性质所决定的\nC、由国家宪法所确立的\nD、被中国革命、建设、改革伟大实践所证明的\n\n\n正确答案： BCD\n\n5\n【多选题】民主和集中的关系是（ ）。\n\nA、两者互为条件、相辅相成、缺一不可\nB、两者互为前提、相互促进\nC、民主是正确集中的前提和基础\nD、集中是民主的必然要求和归宿\n\n\n正确答案： ACD\n\n\n\n大题部分\n\n1 马克思主义中国化时代化的原因※\n\n  一是马克思主义理论本身发展的内在要求\n  二是解决中国实际问题的客观需要。\n\n2 马克思主义中国化时代化的理论成果及其关系※\n\n  （1）理论成果：在马克思主义中国化时代化的历史进程中，产生了毛泽东思想邓小平理论、“三个代表”重要思想、科学发展观、习近平新时代中国特色社会主义思想。（分为毛泽东思想和中国特色社会主义理论体系两个大类）\n\n  （2）关系：马克思主义中国化时代化的理论成果是–脉相承又与时俱进的关系。\n①一方面，毛泽东思想所蕴含的马克思主义的立场、观点和方法，为中国特色社会主义理论体系提供了基本遵循。\n②另一方面，中国特色社会主义理论体系在新的历史条件下进一步丰富和发展了毛泽东思想。\n③毛泽东思想和中国特色社会主义理论体系都是马克思列宁主义在中国的发展和运用，都以独创性的理论成果丰富和发展了马克思主义的理论宝库\n\n3 近代中国社会的性质、主要矛盾※\n  ①近代中国社会的性质：半殖民地半封建社会\n  ②主要矛盾：帝国主义和中华民族的矛盾，封建主义和人民大众的矛盾。\n\n4 过渡时期社会的性质、经济成分、阶级构成和主要矛盾※\n  ①社会性质：新民主主义社会\n  ②经济成分：社会主义性质的国营经济、半社会主义性质的合作社经济(个体经济向社会主义集体经济过渡的形式)、农民和手工业者的个体经济、私人资本主义经济、国家资本主义经济(私人资本主义经济向社会主义国营经济过渡的形式)\n  ③阶级构成：中国社会的阶级构成主要是工人阶级、农民阶级、其他小资产阶级、民族资产阶级等基本的阶级力量。\n  ④主要矛盾：三种基本经济成分及与之相联系的三种基本的阶级力量之间的矛盾集中表现为社会主义和资本主义两条道路，工人阶级和资产阶级两个阶级的矛盾\n\n5 社会主义改造的历史经验※\n  第一，坚持社会主义工业化建设与社会主义改造同时并举\n  第二，采取积极引导，逐步过渡的方式\n  第三，用和平方法进行改造\n\n6 社会主义改造完成后社会主要矛盾※\n  人民对于经济文化迅速发展的需要，同当前经济文化不能满足人民需要的状况之间的矛盾\n\n7 社会主义建设道路初步探索的意义和经验教训※\n\n  （1）初步探索的意义:\n  ①巩固和发展了我国的社会主义制度。\n  ②为开创中国特色社会主义提供了宝贵经验、理论准备、物质基础。\n  ③丰富了科学社会主义的理论和实践。\n\n  （2）经验教训:\n  ①必须把马克思主义与中国实际相结合，探索符合中国特点的社会主义建设道路。\n  ②必须正确认识社会主义社会的主要矛盾和根本任务，集中力量发展生产力。\n  ③必须从实际出发进行社会主义建设，建设规模和速度要与国力相适应，不能急于求成。\n  ④必须发展社会主义民主，健全社会主义法制。\n  ⑤必须坚持党的民主集中制和集体领导制度，加强执政党建设。\n  ⑥必须坚持对外开放，借鉴和吸收人类文明成果建设社会主义，不能关起门来搞建设。\n\n8 中国特色社会主义进入新时代的社会主要矛盾※\n\n  人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾。\n\n9 邓小平理论首要的基本的理论问题和精髓※\n\n  首要的基本的理论问题是：在中国这样一个经济文化比较落后的国家，建设什么样的社会主义，怎样建设社会主义是一个首要的基本的理论问题\n精髓：解放思想，实事求是，是邓小平理论的精髓\n\n10 4.\t社会主义的本质※\n  社会主义的本质是解放生产力，发展生产力，消灭剥削，消除两极分化，最终达到共同富裕\n\n11 “三个代表”重要思想回答的重大问题和核心观点及其关系※\n\n  ①三个代表重要思想回答的重大问题是建设什么样的党？怎样建设党的问题\n\n  ②核心观点：我们党始终代表中国先进生产力的发展要求，代表中国先进文化的前进方向，代表中国最广大人民的根本利益\n\n  ③关系：代表中国先进生产力的发展要求，代表中国先进文化的前进方向，代表中国最广大人民的根本利益是统一的，整体相互关系相互促进发展先进生产力是发展先进文化，实现最广大人民根本利益的基础条件，人民群众是先进生产力和先进文化的创造主体，也是实现自身利益的根本力量，不断发展先进生产力和先进文化，归根到底都是为了满足人民日益增长的物质文化生活需要，不断实现最广大人民的根本利益。(不确定)\n\n12 科学发展观回答的重大问题和科学内涵※\n\n  科学发展观回答的重大问题是:实现什么样的发展，怎样进行发展的问题\n\n  科学内涵：\n  一，推动经济社会发展是科学发展观的第一要义\n  二，以人为本是科学发展观的核心立场\n  三，全面协调可持续是科学发展观的基本要求\n  四，统筹兼顾是科学发展观的根本方法\n\n13 习近平新时代中国特色社会主义思想回答的重大时代课题※\n\n  一、新时代坚持和发展什么样的中国特色社会主义、怎样坚持和发展中国特色社会主义\n  二、建设什么样的社会主义现代化强国、怎样建设社会主义现代化强国\n  三、建设什么样的长期执政的马克思主义政党、怎样建设长期执政的马克思主义政党\n\n14 习近平新时代中国特色社会主义思想的历史地位※\n  一、开辟马克思主义中国化时代化的新境界\n  二、实现中华民族伟大复兴的行动指南\n  三、建设美好世界的中国智慧和中国方案\n\n15 中国式现代化的内涵、中国特色和本质要求※\n  ①内涵：中国式现代化，是中国共产党领导的社会主义现代化，既有各国现代化的共同特征，更有基于自己国情的中国特色。\n  ②中国特色：中国式现代化是人口规模巨大的现代化、是全体人民共同富裕的现代化、是物质文明和精神文明相协调的现代化、是人与自然和谐共生的现代化、是走和平发展道路的现代化。\n  ③本质要求：坚持中国共产党领导，坚持中国特色社会主义，实现高质量发展，发展全过程人民民主，丰富人民精神世界，实现全体人民共同富裕，促进人与自然和谐共生，推动构建人类命运共同体，创造人类文明新形态\n\n16 新发展格局的内涵，构建新发展格局的意义和重点任务※\n  ①内涵：构建新发展格局是重塑我国国际合作和竞争新优势的战略抉择是把握未来发展主动权的战略性布局和先手棋。\n  ②意义：立足新发展阶段，贯彻新发展理念，要致力构建以国内大循环为主体、国内国际双循环相互促进的新发展格局。\n  ③重点任务：构建新发型格局\n"
} ,
  
  {
    "title"    : "大数据技术原理与应用",
    "category" : "",
    "tags"     : " big data, java, 期末考试",
    "url"      : "/bigdata",
    "date"     : "June 5, 2023",
    "excerpt"  : "  “大数据技术原理与应用”是一门介绍大数据技术的课程。通过学习这门课程，学生可以深入了解大数据技术的原理和应用，并学会如何使用各种工具和技术来处理和管理大数据。此外，该课程还涵盖了大数据架构、设计和性能优化等方面的内容，这些知识对于开展大规模数据处理和分析项目非常重要。因此，“大数据技术原理与应用”对于计算机科学和数据科学领域的学生和从业人员，以及对大数据感兴趣的其他人士都有很大的意义。\n\n\n前言\n  本博客是本人反复听了上课的28分钟录音，听了8个小时左右辛苦肝出来的。如果你可以看到这...",
  "content"  : "  “大数据技术原理与应用”是一门介绍大数据技术的课程。通过学习这门课程，学生可以深入了解大数据技术的原理和应用，并学会如何使用各种工具和技术来处理和管理大数据。此外，该课程还涵盖了大数据架构、设计和性能优化等方面的内容，这些知识对于开展大规模数据处理和分析项目非常重要。因此，“大数据技术原理与应用”对于计算机科学和数据科学领域的学生和从业人员，以及对大数据感兴趣的其他人士都有很大的意义。\n\n\n前言\n  本博客是本人反复听了上课的28分钟录音，听了8个小时左右辛苦肝出来的。如果你可以看到这篇博客，说明我对你有足够的信任，请不要辜负这份信任。\n\n\n  未经本人允许，请不要分享本博客出去，分享方式包括但不限于分享链接，截图等。\n\n\n\n考题整理\n\n客观题部分（50分）\n\n1. Hadoop运行模式有哪些？\n\n\n  单机模式\n  伪分布式模式\n  完全分布式模式\n\n\n\n\n2. 单机模式和伪分布式模式的区别\n\n  单机模式：Hadoop只在一台机器上运行，存储采用本地文件系统，没有采用分布式文件系统HDFS。\n  伪分布式：Hadoop存储采用分布式文件系统HDFS，而且HDFS的名称结点和数据结点位于集群的不同机器上。\n\n\n\n3. 伪分布式的安装\n\n3.1 Hadoop的开发和运行需要什么环境？\n\n  需要Java环境在hadoop-env.sh 中配置\n\n3.2 伪分布式的安装需要修改哪些配置文件？\n\n  需要修改文件：core-site.xml hdfs-site.xml\n\n3.3有关fs.defaultFS的配置的两种问法\n\n3.3.1问法一：fs.defaultFS的参数在哪一个配置文件中进行配置？\n\n  在core-site.xml中配置\n\n3.3.3问法二：配置NameBode地址时由哪一个参数指定的\n\n  由core-site.xml中的dfs.namenode.dir参数指定\n\n\n\n4 Hadoop的核心功能组件\n\n\n  可能会考填空或简答。\n\n\n4.1 填空的问法：请列举出两个除hdfs和MapReduce之外的两个文件\n\n\n  HBase\n  Hive\n  Pig\n  Mahout\n  ZooKeeper\n  Flume\n  Sqoop\n  Ambari\n\n\n4.2 简答题的问法：请举两个核心组件并说明其作用\n\n\n  HBase：是一个提供高可靠性、高性能、可伸缩、实时读写、分布式的列式数据库\n  Hive：是一个基于hadoop数据仓库工具\n  Pig：是一种数据流语言和运行环境\n  Mahout：是一个开源的项目，它提供了一些可扩展的机器学习领域经典算法的实现\n  ZooKeeper：是一个高效和可靠的协同工作系统。\n\n\n\n\nNamenode\n\n\n  Datanode会定时的为Namenode发送心跳\n\n\n5.1用于存储数据块信息的目录结构的是哪一个结点？\n\n  Namenode\n\n5.2 从功能的角度分析Namenode主要用于存储什么信息（不确定）\n\n  NameNode存储着文件系统树以及文件树中所有的文件和文件夹的元数据信息\n\n5.3在HDFS中保存着两个数据结构，请说明这两个数据结构是什么，有什么用？\n\n  这两个数据结构分别是FsImage和Editlog。\n  FsImage用于维护文件系统树以及文件树中所有的文件和文件夹的元数据。\n  EditLog用于操作日志文件以及记录了所有针对文件的创建、删除、重命名等操作。\n\n\n\n6 DataNode的主要功能是什么？\n\n  负责管理它所在结点上存储的数据的读写,及存储数据（存放数据）\n\n\n  DataNode和DataNode之间会进行进程通信\n\n\n\n\n7 Hadoop集群主要瓶颈是什么？\n\n  不是CPU，主要瓶颈是磁盘IO\n\n\n\n8 ssh免密登录是为了什么/目的是什么？\n\n\n  启动集群不需要输入密码\n  进程之间可以免密通信\n  免密登录不是必须的\n\n\n\n\n9 Hadoop的启停命令\n\n\n  start-all.sh：启动所有的Hadoop守护进程\n  stop-all.sh：停止所有的Hadoop守护进程\n  start-dfs.sh：启动Hadoop HDFS守护进程NameNode、SecondaryNameNode和DataNode\n  stop-dfs.sh：停止Hadoop HDFS守护进程NameNode、SecondaryNameNode和DataNode\n  单独启动某个进程：hadoop-daemons.sh start name\n  单独关闭某个进程：hadoop-daemons.sh stop name\n  启动YARN命令：start-yarn.sh\n  关闭YARN命令：stop-yarn.sh\n\n\n\n\n10 Hadoop是否支持随机读取\n\n  不支持\n\n\n\n11 ：指令相关\n\n11.1列举两个HDFS常用的shell命令\n\n\n  Hadoop fs -ls  用于展示在指定目录下的文件详细信息\n  Hadoop fs -cat  将指定文件的内容输出到标准输出\n  Hadoop fs -mkdir [-p]  创建一个或多个文件夹，-p选型用于递归的创建子文件夹\n  Hadoop fs -cp   将文件从源路径复制到目标路径\n\n\n11.2 列举两个常用的java API\n\n\n  org.apache.hadoop.fs.FSDataInputStream：文件输入流，用于读Hadoop文件\n  org.apache.hadoop.fs.FSDataOutputStream:文件输出流，用于写Hadoop文件\n  org.apache.hadoop.fs.Path：用于表示hadoop文件系统中一个文件或者目录的路径\n\n\n\n\n12 Hadoop的特性\n\n12.1 简答题的写法（写5个，不需要解释）：\n\n\n  高可靠性\n  高效性\n  高可扩展性\n  高容错性\n  成本低\n  运行的在linux系统上\n  支持各种编程语言\n\n\n12.2 填空题的写法（挑两个即可）：\n\n\n  高可靠性\n  高效性\n  高可扩展性\n  高容错性\n  成本低\n  运行的在linux系统上\n  支持各种编程语言\n\n\n\n\n综合应用（50分）\n\n13 Hive\n\n  大致题面：br\n\n  给你一段数据（两种数据）：\n\n  第一种：100 \\t zhansan \\t 18\n  第二种：100，zhansan，18\n\n13.1 使用HQL语言创建一个数据库,并指定路径\n\n  create database database_name location ‘path’;\n\n13.2 在指定的数据库中创建表\n\n  use 指定的数据库;\n  如果是第一种数据则写：\n  create table table_name(hight int, name string,age int) ROW FORMAT DELIMITED FIELDS TERMINATED BY ‘\\t’\n\n  如果是第二种数据则写：\n  create table table_name(hight int, name string,age int) ROW FORMAT DELIMITED FIELDS TERMINATED BY ‘,’\n\n13.3 装载数据\n\n  load data [local] inpath &amp;lt; path路径&amp;gt; into table \n\n\n  这里local表示在本地文件中获取，即如果在本地才需要加上\n\n\n13.4 删除（非空）数据库\n\n  drop database  cascade\n\n\n\n14 Hbase\n14.1 设计逻辑结构\n  题面：给你一个json串，设计一个逻辑结构\n\n\n    \n    \n        \n    \n    \n\n\n   答\n\n\n    \n    \n        \n    \n    \n\n\n14.2 如何确定一个单元格？\n\n  以下面这个为例。\n\n\n    \n    \n        \n    \n    \n\n\n   现在以确定一个姓名为LiuJun的人为例：\n行键“201505002”，列族“info”限定符“email”和时间戳“1230016521”这四个坐标值确定的单元格[“201505002”,”Info”,”email”,”1230016521”]\n\n14.2.2问法二：我们的单元格是通过坐标来决定的，这四维坐标分别是什么？\n\n[“行键”,”列族”,”列限定符”,”时间戳”]\n\n\n14.3 创建表\n\n以第一题的表格为例：\n\ncreate &#39;myTable&#39;, {NAME =&amp;gt; &#39;personal_info&#39;}, {NAME =&amp;gt; &#39;office_info&#39;}\n\n14.4 插入数据\n\n  可以使用 put 命令向 HBase 表格中的特定单元格添加数据。以下是向名为 myTable 的表格中，行键为 row1，列族为 cf1，列名为 column1 的单元格添加数据的示例：\n\nput &#39;myTable&#39;, &#39;row1&#39;, &#39;cf1:column1&#39;, &#39;value1&#39;\n\n\n  其中，myTable 是表格的名称，row1 是行键，cf1 是列族名称，column1 是列名。要将值 value1 添加到该单元格，请将其作为最后一个参数传递给 put 命令。\n\n\n\n15 mapreduce\n\n15.1MapReduce的编程规范\n\n用户编写的程序分成三个部分：\n\n1：Mapper\n\n  用户自定义的Mapper要继承自己的父类\n  Mapper的输入数据是KV对的形式（KV类型可自己定义）\n  Mapper中的业务逻辑写在map()方法中\n  Mapper的输出数据是KV对的形式（KV类型可自定义）\n\n\n2：Reducer\n\n  用户自定义的Reducer要继承自己的父类\n  Reducer的输入数据类型对应Mapper输出数据类型\n  Reducer中的业务逻辑写在reduce()方法中\n  ReduceTask进程对每一组相同K的&amp;lt; k,v&amp;gt;组调用一次reduce()方法\n\n\n3：Driver\n相当于Yarn集群的客户端，用于提交我们整个程序到YARN集群，提交的是封装了MapReduce程序相关运行参数的job对象。\n\n15.2自定义数据类型\n\n\n  实现Writable接口\n  空参构造\n  重写序列化方法\n  重写反序列化方法\n  如果需要把结果显示在文件中，则需要重写toString()\n  如果需要将自定义的bean放在key中传输，则要实现Comparable接口\n\n\n15.3代码实现\n\n第一套卷子考点：map逻辑实现\n\n\n    \n    \n        \n    \n    \n\n\n15.3.2第二套卷子考点：Driver逻辑实现\n\n  7点全要考\n\n\n    \n    \n        \n    \n    \n\n\n"
} ,
  
  {
    "title"    : "xcpc模板积累",
    "category" : "",
    "tags"     : " 算法",
    "url"      : "/algorithm",
    "date"     : "May 4, 2023",
    "excerpt"  : "  这是一个竞赛算法模板博客，用于应对xcpc等算法竞赛。此模板不一定是符合大众的模板，我会带有自己的风格。模板我会不断地更新，内容仅供参考。\n\n\n目录\n\n\n  目录\n  算法模板积累\n    \n      图论\n        \n          单源最短路\n            \n              dijiestal\n              SPFA\n            \n          \n          多源最短路\n            \n      ...",
  "content"  : "  这是一个竞赛算法模板博客，用于应对xcpc等算法竞赛。此模板不一定是符合大众的模板，我会带有自己的风格。模板我会不断地更新，内容仅供参考。\n\n\n目录\n\n\n  目录\n  算法模板积累\n    \n      图论\n        \n          单源最短路\n            \n              dijiestal\n              SPFA\n            \n          \n          多源最短路\n            \n              Floyd\n            \n          \n          最小生成树\n            \n              prim\n              Kruskar\n            \n          \n          spfa负环判断\n          差分约束\n          最近公共祖先lca\n          有向图的强连通分量\n          无向图的强连通分量\n            \n              e-dcc缩点\n              v-dcc缩边\n            \n          \n          二分图\n            \n              染色法判断二分图是否合理\n              匈牙利算法 解 二分图的最大匹配数\n            \n          \n        \n      \n      dp\n        \n          背包问题\n            \n              完全背包\n              多重背包的二进制优化\n            \n          \n          数位dp\n        \n      \n      数据结构\n        \n          树状数组\n          线段树\n        \n      \n      数学\n        \n          pow\n          矩阵快速幂\n          逆元计算\n          欧拉筛\n          博弈论\n        \n      \n    \n  \n\n\n\n算法模板积累\n\n\n\n图论\n\n\n\n单源最短路\n\n\n\ndijiestal\nint head[N],edge[N],Next[N],val[N],tt=0;\nvoid add(int x,int y,int z){\n    edge[++tt]=y;\n    val[tt]=z;\n    Next[tt]=head[x];\n    head[x]=tt;\n}\n\nint d[N];\n\nstruct node{\n    int i,d;\n    node(int i=0,int d=0):i(i),d(d){}\n    bool friend operator&amp;lt;(const node &amp;amp;a,const node &amp;amp;b){\n        return a.d&amp;gt;b.d;\n    }\n};\n\nvoid dijiestal(int u){\n    memset(d,0x3f,sizeof d);\n    d[u]=0;\n\n    bool mp[N]={0};\n    priority_queue&amp;lt;node&amp;gt;q;\n    q.push(node(u,0));\n    \n    while(!q.empty()){\n        node e=q.top();\n        q.pop();\n        int x=e.i;\n        if(mp[x]) continue;\n        mp[x]=true;\n\n        for(int i=head[x];i;i=Next[i]){\n            int y=edge[i],y_val=val[i];\n            if(d[y]&amp;gt;d[x]+y_val){\n                d[y]=d[x]+y_val;\n                q.push(node(y,d[y]));\n            }\n        }\n    }\n}\n\n\n\n\nSPFA\n\nstruct node{\n    int val,y;\n    node(int y=0,int val=0):val(val),y(y){}\n};\n\nvector&amp;lt;node&amp;gt;a[M];\nint d[M],b[M];   // b[i]记录在牧场i处有多少只奶牛\nint n,p,c;\n\nint spfa(int u){\n    memset(d,0x3f,sizeof d);\n    d[u]=0;\n    queue&amp;lt;int&amp;gt; q;\n    q.push(u);\n    bool mp[M]={};\n    while(!q.empty()){\n        int x=q.front();\n        q.pop();\n        \n        mp[x]=false;\n        \n        for(node &amp;amp;e:a[x]){\n            int y=e.y,val=e.val;\n            if(d[y]&amp;gt;d[x]+val){\n                d[y]=d[x]+val;\n                if(!mp[y]){\n                    mp[y]=true;\n                    q.push(y);\n                }\n            }\n        }\n    }\n    int res=0;\n    for(int i=1;i&amp;lt;=p;i++){\n        if(b[i]){\n            if(d[i]==MAX) return MAX;\n            res+=b[i]*d[i];\n        }\n    }\n    return res;\n}\n\n\n\n\n多源最短路\n\n\n\nFloyd\n\nmemeset(d,0x3f,sizeof d);\nfor(int i=1,x,y,z;i&amp;lt;=m;i++){\n    cin&amp;gt;&amp;gt;x&amp;gt;&amp;gt;y&amp;gt;&amp;gt;z;\n    d[x][y]=d[y][x]=min(d[x][y],z);\n}\nfor(int k=1;k&amp;lt;=n;i++){\n    for(int i=1;i&amp;lt;=n;i++){\n        for(int j=1;j&amp;lt;=n;j++)\n            d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n    }\n}\n\n\n\n\n最小生成树\n\n\nprim\n\nint d[N],n;\nint res;    // 最小生成树的总路程长度\nint a[N][N];\nstruct node{\n    int i,d;\n    bool friend operator&amp;lt;(const node &amp;amp;a,const node &amp;amp;b){\n        return a.d&amp;gt;b.d;\n    }\n};\n\nvoid prim(int u=1){\n    bool mp[N]={0};\n\n    priority_queue&amp;lt;node&amp;gt;q;\n    q.push({u,0});\n\n    memset(d,0x3f,sizeof d);\n    d[u]=0;\n\n    while(!q.empty()){\n        node e=q.top();\n        q.pop();\n        int x=e.i;\n\n        if(mp[x]) continue;\n        mp[x]=true;\n        res+=e.d;\n\n        for(int y=1;y&amp;lt;=n;y++){\n            if(!mp[y]&amp;amp;&amp;amp;d[y]&amp;gt;a[x][y]){\n                d[y]=a[x][y];\n                q.push({y,d[y]});\n            }\n        }\n    }\n}\n\n\n\nKruskar\n\nint n,k,sum=0;\nint edge[M],head[M],Next[M],val[M],top=0;\nint d[N];\n\nint f[N];\nint Hash[N]={0};\nint get(int x){\n    return f[x]==x?x:f[x]=get(f[x]);\n}\n\nvoid mange(int x,int y){\n    x=get(x);\n    y=get(y);\n    if(x!=y){\n        f[x]=y;\n        Hash[x]=1;\n    }\n}\n\nvoid add(int x,int y,int z){\n    edge[++top]=y;\n    val[top]=z;\n    Next[top]=head[x];\n    head[x]=top;\n}\n\nstruct node{\n    int i,d;\n    node(int i=0,int d=0):i(i),d(d){}\n    friend bool operator&amp;lt;(const node &amp;amp;a,const node &amp;amp;b){\n        return a.d&amp;gt;b.d;\n    }\n};\n\nvoid pirm(int u){\n    bool Hash[N]={0};\n    memset(d,0x3f,sizeof d);\n    priority_queue&amp;lt;node&amp;gt;q;\n    q.push(node(u,0));\n    d[u]=0;\n    while(!q.empty()){\n        int x=q.top().i;\n        q.pop();\n        if(Hash[x]) continue;\n        Hash[x]=true;\n        sum-=d[x];\n        for(int i=head[x];i;i=Next[i]){\n            int y=edge[i],z=val[i];\n            if(!Hash[y]&amp;amp;&amp;amp;z&amp;lt;d[y]){\n                d[y]=z;\n                q.push(node(y,d[y]));\n            }\n        }\n    }\n}\n\n\nspfa负环判断\n\n输入的第一行是两个整数 N,K。\n接下来 K 行，表示分配糖果时需要满足的关系，每行 3 个数字 X,A,B。\n\n\n  如果 X=1．表示第 A 个小朋友分到的糖果必须和第 B个小朋友分到的糖果一样多。\n  如果 X=2，表示第 A 个小朋友分到的糖果必须少于第 B个小朋友分到的糖果。\n  如果 X=3，表示第 A 个小朋友分到的糖果必须不少于第 B个小朋友分到的糖果。\n  如果 X=4，表示第 A 个小朋友分到的糖果必须多于第 B个小朋友分到的糖果。\n  如果 X=5，表示第 A 个小朋友分到的糖果必须不多于第 B 个小朋友分到的糖果。\n\n\n小朋友编号从1到 N。\nbool spfa(){\n    int d[N],cnt[N]={0};\n    bool mp[N];\n    queue&amp;lt;int&amp;gt;q;\n    for(int i=1;i&amp;lt;=n;i++){\n        q.push(i);\n        d[i]=INF;\n        mp[i]=true;\n    }\n    while(!q.empty()){\n        int x=q.front();\n        q.pop();\n        mp[x]=false;\n        for(int i=head[x];i;i=Next[i]){\n            int y=ver[i],z=edge[i];\n            if(d[y]&amp;gt;d[x]+z){\n                d[y]=d[x]+z;\n                cnt[y]=cnt[x]+1;\n                if(cnt[y]&amp;gt;=n) return true;\n                if(!mp[y]){\n                    mp[y]=true;\n                    q.push(y);\n                }\n            }\n        }\n    }\n    return false;\n}\n\n\n\n差分约束\n实质上也是判断负环\n#include&amp;lt;cstring&amp;gt;\n#include&amp;lt;iostream&amp;gt;\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+10;\nconst int K=3e5+10;\nint head[N],Next[K],edge[K],ver[K],tot=0;\n\nvoid add(int x,int y,int z){\n    edge[++tot]=z;\n    ver[tot]=y;\n    Next[tot]=head[x];\n    head[x]=tot;\n}\n\nll d[N]={0};\nbool mp[N];\nint stc[N]={0},top=0;\nint cnt[N]={0};\nint n,k;\nbool spfa(){\n    memset(d,-1,sizeof d);\n    d[0]=0;\n    stc[top++]=0;\n    while(top){\n        int x=stc[--top];\n        mp[x]=false;\n        for(int i=head[x];i;i=Next[i]){\n            int y=ver[i],z=edge[i];\n            if(d[y]&amp;lt;d[x]+z){\n                d[y]=d[x]+z;\n                cnt[y]=cnt[x]+1;\n                if(cnt[y]&amp;gt;=n+1) return true;\n                if(!mp[y]){\n                    mp[y]=true;\n                    stc[top++]=y;\n                }\n            }\n        }\n    }\n    return false;\n}\nint main(){\n    int x,y,t;\n    scanf(&quot;%d %d&quot;,&amp;amp;n,&amp;amp;k);\n    for(int i=1;i&amp;lt;=k;i++){\n        scanf(&quot;%d %d %d&quot;,&amp;amp;t,&amp;amp;x,&amp;amp;y);\n        if(t==1){\n            add(x,y,0);\n            add(y,x,0);\n        }\n        else if(t==2){\n            add(x,y,1);\n        }\n        else if(t==3){\n            add(y,x,0);\n        }\n        else if(t==4){\n            add(y,x,1);\n        }\n        else{\n            add(x,y,0);\n        }\n    }\n    for(int i=1;i&amp;lt;=n;i++) add(0,i,1);\n    if(spfa()){\n        puts(&quot;-1&quot;);\n    }\n    else{\n        ll sum=0;\n        for(int i=1;i&amp;lt;=n;i++)\n            sum+=d[i];\n        printf(&quot;%lld\\n&quot;,sum);\n    }\n    return 0;\n}\n\n\n\n最近公共祖先lca\nconst int N = 4e4 + 5, M = N &amp;lt;&amp;lt; 1;\nstruct E {\n    int v, next;\n} e[M];\nint n, m, t, len, root, u, v, dep[N], f[N][17], h[N];\nvoid add(int u, int v) {\n    e[++len].v = v; e[len].next = h[u]; h[u] = len;\n}\nvoid bfs() {        // 初始化\n    int q[N],tt=0,hh=0;\n    q[tt++]=root;   // 进入一个根节点\n    dep[root] = 1, dep[0] = 0;\n    while (tt!=hh) {\n        int u = q[hh++];\n        for (int j = h[u]; j; j = e[j].next) {\n            int v = e[j].v;\n            if (dep[v]) continue;\n            dep[v] = dep[u] + 1;\n            q[tt++]=v;\n            f[v][0] = u;\n            for (int k = 1; k &amp;lt;= t; k++) f[v][k] = f[f[v][k - 1]][k - 1];\n        }\n    }\n}\nint lca(int x, int y) { // 返回x，y的最近公共祖先\n    if (dep[y] &amp;gt; dep[x]) x=x+y-(y=x);\n    for (int i = t; i &amp;gt;= 0; i--) {\n        if (dep[f[x][i]] &amp;gt;= dep[y]) x = f[x][i];\n    }\n    if (x == y) return x;\n    for (int i = t; i &amp;gt;= 0; i--) {\n        if (f[x][i] != f[y][i]) x = f[x][i], y = f[y][i];\n    }\n    return f[x][0];\n}\n\n\n有向图的强连通分量\nvoid tarjan(int x){\n    low[x]=dfn[x]=++ti;\n    dic[++top]=x;\n    mp[x]=true;\n    for(int i=head[x];~i;i=Next[i]){\n        int y=edge[i];\n        if(!dfn[y]){\n            tarjan(y);\n            low[x]=min(low[x],low[y]);\n        }else if(mp[y]) low[x]=min(low[x],dfn[y]);\n    }\n    if(low[x]==dfn[x]){     // 联通块缩点\n        int y;\n        ecc_cnt++;\n        do{\n            y=dic[top--];\n            id[y]=ecc_cnt;\n            ecc[ecc_cnt].push_back(y);\n            mp[y]=false;\n        }while(x!=y);\n    }\n}\n\n\n无向图的强连通分量\ne-dcc缩点\nint n,m,dcc_cnt;\nint dfn[N],low[N],ti;\nint dic[N],top=0;   // 用于记录边\n\nvoid tarjan(int x,int pre){  // 用于计算桥的算法,pre是边不是点\n    dfn[x]=low[x]=++ti;\n    dic[top++]=x;\n\n    for(int i=head[x];~i;i=Next[i]){    // 注意这里的i表示head要初始化为-1\n        int y=edge[i];\n        if(!dfn[y]){    // 这个点没走过\n            tarjan(y,i);\n            low[x]=min(low[x],low[y]);\n            if(dfn[x]&amp;lt;low[y]){  //这里有桥\n                mp[i]=mp[i^1]=true;\n            }\n        }else if(i!=(pre^1)){   // 这个点走过了，但不是父节点\n            low[x]=min(low[x],dfn[y]);\n        }\n    }\n    if(dfn[x]==low[x]){ // 说明这个是一个连通域的根结点\n        id[x]=++sign;   // 这里将联通域中所有的点压缩为一个点\n        for(int y=dic[--top];y!=x;y=dic[--top]) id[y]=sign;\n    }\n}\n\n\n\nv-dcc缩边\nvoid tarjan(int x){\n    low[x]=dfn[x]=++ti;\n    dic[++top]=x;\n    if(x==root&amp;amp;&amp;amp;head[x]==-1){   // 孤立点\n        dcc_cnt++;\n        dcc[dcc_cnt].push_back(x);\n        return;\n    }\n    int sign=0;\n    for(int i=head[x];~i;i=Next[i]){    // 不是孤立点\n        // 注意这里的i表示head要初始化为-1\n        int y=edge[i];\n        if(!dfn[y]){\n            tarjan(y);\n            low[x]=min(low[x],low[y]);\n            if(dfn[x]&amp;lt;=low[y]){\n                sign++;\n                if(sign&amp;gt;1||x!=root) mp[x]=true;\n                dcc_cnt++;\n                int z;\n                do{\n                    z=dic[top--];\n                    dcc[dcc_cnt].push_back(z);\n                }while(z!=y);\n                dcc[dcc_cnt].push_back(x);\n            }\n        }\n        else low[x]=min(low[x],dfn[y]);\n    }\n}\n\n\n二分图\n\n染色法判断二分图是否合理\nbool dfs(int x,int c){  // 结点，颜色，阈值\n    color[x]=c;\n    for(int i=head[x];i;i=Next[i]){\n        int y=edge[i],val_y=val[i];\n        if(color[y]==color[x]) return false;\n        if(!color[y]&amp;amp;&amp;amp;!dfs(y,3-c,mid)) return false;\n    }\n    return true;\n}\n\nbool check(){\n    memset(color,0,sizeof color);\n    for(int i=1;i&amp;lt;=n;i++){\n        if(!color[i]){\n            if(!dfs(i,1)) return false;     // 出现矛盾就返回\n        }\n    }\n    return true;\n}\n\n\n匈牙利算法 解 二分图的最大匹配数\n二分图的：\n最小覆盖点的数量可以用匈牙利算法求解\n最小覆盖点的数量 = 最大匹配数\n最大独立集 = 总点数 - 最小覆盖点的数量\n\nbool mp[M];  // 表示i是否被访问过\nint match[M];   // 表示i的配对对象是match[i],0表示还没有配对上\nbool dfs(int x){\n    for(int i=head[x];i;i=Next[i]){ // 递归的寻找可以与x配对的点\n        int y=ver[i];\n        if(!mp[y]){  // 这个点没有访问过\n            mp[y]=true; // 标记一下表示访问过了\n            if(!match[y]||dfs(match[y])){   // 找到一个没有配对过的点，或者一个可以让出y的方案\n                match[y]=x; // 回溯的标注与其配对的点\n                return true;\n            }\n        }\n    }\n    return false;   // 没找到可以增广的点\n}\n\n\nint main(){\n    *\n    *\n    *\n    int res=0;  // 表示二分图的最大匹配数\n    for(int i=1;i&amp;lt;=n;i++){  // 注意！！这里枚举的是二分图的左部（右部也可以）\n        memset(mp,0,sizeof mp);  // 这一步不能少\n        if(dfs(i)) \n    }\n    return 0;\n}\n\n\ndp\n背包问题\n完全背包\nfor(int i = 1 ; i&amp;lt;=n ;i++){\n    for(int j = v[i] ; j&amp;lt;=m ;j++)\n        f[j] = max(f[j],f[j-v[i]]+w[i]);\n}\n\n\n多重背包的二进制优化\nwhile(n--){\n    scanf(&quot;%d %d %d&quot;,&amp;amp;v,&amp;amp;w,&amp;amp;s);\n    int k;\n    for(k=1;k&amp;lt;=s;k&amp;lt;&amp;lt;=1){\n        s-=k;\n        for(int i=m;i&amp;gt;=v*k;i--)\n        dp[i]=max(dp[i],dp[i-k*v]+k*w);\n    }\n    if(s&amp;gt;0){\n        for(int i=m;i&amp;gt;=s*v;i--)\n        dp[i]=max(dp[i],dp[i-s*v]+w*s);\n    }\n}\n\n\n数位dp\n这个板子不具有一般性，请结合题目来理解：\n\n如果一个正整数每一个数位都是 互不相同 的，我们称它是 特殊整数 。\n\n给你一个正整数 \\(n\\) ，请你返回区间 \\([1, n]\\) 之间特殊整数的数目。\n\n示例：\n输入:\n    20\n\n\n输出\n    19\n\n\nint f[15][1&amp;lt;&amp;lt;10];   // 前面出现了数字的合法情况下（当前数字允许是0），这里存储的是一般情况下（不受限制）的情况\nint n;\nstring s;   // 字符串表示的数字\n\n// is_limt表示是否受到了前面数字的约束\n// is_num第i个数前面是否填了数字\nint dfs(int i,int mask,bool is_limt,bool is_num){\n    if(i==n) return is_num; // 合法返回1\n        \n    if(!is_limt&amp;amp;&amp;amp;is_num&amp;amp;&amp;amp;f[i][mask]!=-1) return f[i][mask];\n        \n    int res=0;\n    if(!is_num) res=dfs(i+1,mask,false,false);  // 前面全是0的状态是可以传导的，且前面是0那就对后面的数字不存在约束\n\n    // 如果受到限制，那么就必须要设置最大值为s[i]，否则最大值可以到9\n    int up=is_limt?s[i]-&#39;0&#39;:9;\n\n    // is_sum==false表示前面没有填写数字，那么这一位需要从1开始，否则可以从0开始\n    for(int d=1-is_num;d&amp;lt;=up;d++)   // 遍历选择的数字\n        if(!(mask &amp;gt;&amp;gt; d &amp;amp; 1))    // 这个数字没有填写过\n            res+=dfs(i+1,mask|(1&amp;lt;&amp;lt;d),d==up&amp;amp;&amp;amp;is_limt,true);\n    if(!is_limt&amp;amp;&amp;amp;is_num) f[i][mask]=res;\n    return res;\n\n}\n\n\n数据结构\n\n树状数组\n点修改，区间查询\nvoid add(int i,ll d){\n    for(;i&amp;lt;N;i+=i&amp;amp;-i) b[i]+=d;\n}\n\nll ask(int i){\n    ll res=0;\n    for(;i;i-=i&amp;amp;-i) res+=b[i];\n    return res;\n}\n\n\n\n线段树\n\n区间修改，区间查询\n\nconst int N=2e5+10;\nint n,m;\nint a[N];\n\nstruct node{\n    int l,r;\n    ll sum,add;\n    #define l(p) tree[p].l\n    #define r(p) tree[p].r\n    #define add(p) tree[p].add\n    #define sum(p) tree[p].sum\n}tree[N*4];\n\nvoid build(int p,int l,int r){\n    l(p)=l,r(p)=r;\n    if(l==r){\n        sum(p)=a[l];\n        return;\n    }\n    int mid=(l+r)/2;\n    build(p*2,l,mid);\n    build(p*2+1,mid+1,r);\n    sum(p)=sum(p*2)+sum(p*2+1);\n};\n\nvoid spead(int p){\n    if(add(p)){\n        sum(p*2)+=add(p)*(r(p*2)-l(p*2)+1);\n        sum(p*2+1)+=add(p)*(r(p*2+1)-l(p*2+1)+1);\n        add(p*2)+=add(p);\n        add(p*2+1)+=add(p);\n        add(p)=0;\n    }\n}\n\nvoid change(int p,int l,int r,int d){\n    if(l&amp;lt;=l(p)&amp;amp;&amp;amp;r(p)&amp;lt;=r){\n        sum(p)+=d*(r(p)-l(p)+1);\n        add(p)+=d;\n        return;\n    }\n    spead(p);\n    int mid=(l(p)+r(p))/2;\n    if(l&amp;lt;=mid) change(p*2,l,r,d);\n    if(mid&amp;lt;r) change(p*2+1,l,r,d);\n    sum(p)=sum(p*2)+sum(p*2+1);\n}\n\nll ask(int p,int l,int r){\n    spead(p);\n    if(l&amp;lt;=l(p)&amp;amp;&amp;amp;r(p)&amp;lt;=r) return sum(p);\n    int mid=(l(p)+r(p))/2;\n    ll res=0;\n    if(l&amp;lt;=mid) res+=ask(p*2,l,r);\n    if(mid&amp;lt;r) res+=ask(p*2+1,l,r);\n    return res;\n}\n\n\n\n\n\n数学\n\npow\n\n\nll pow(ll p,int n){\n    ll res=1;\n    while(n){\n        if(n&amp;amp;1) res*=p;\n        p*=p;\n        res%=mod;\n        p%=mod;\n        n&amp;gt;&amp;gt;=1;\n    }\n    return res;\n}\n\n\n矩阵快速幂\n\n斐波那契前 n 项和\n\n#include&amp;lt;iostream&amp;gt;\n#include&amp;lt;cstring&amp;gt;\nusing namespace std;\ntypedef long long ll;\nll n,mod;\nll res[3]={1,2,4};\nll a[3][3]={ {0,0,-1},\n             {1,0,0},\n             {0,1,2} };\n\nvoid mul(){\n    ll c[4]={0};\n    for(int j=0;j&amp;lt;3;j++){\n        for(int k=0;k&amp;lt;3;k++)\n            c[j]=(c[j]+res[k]*a[k][j])%mod;\n    }\n    memcpy(res,c,sizeof c);\n}\n\nvoid mulself(){\n    ll c[3][3]=0;\n    for(int i=0;i&amp;lt;3;i++)\n        for(int j=0;j&amp;lt;3;j++)\n            for(int k=0;k&amp;lt;3;k++)\n                c[i][j]=(c[i][j]+a[i][k]*a[k][j])%mod;\n    memcpy(a,c,sizeof a);\n}\n\nint main(){\n    cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;mod;\n    n--;\n    \n    while(n){\n        if(n&amp;amp;1) mul();\n        mulself();\n        n&amp;gt;&amp;gt;=1;\n    }\n    cout&amp;lt;&amp;lt;res[0];\n    return 0;\n}\n\n\n逆元计算\nint exgcd(int a,int b,int &amp;amp;x,int &amp;amp;y){\n    if(b==0){x=1,y=0;return a;}\n    int d=exgcd(b,a%b,x,y);\n    int z=x;\n    x=y;\n    y=z-a/b*y;\n    return d;\n}\n\n\n欧拉筛\nint prime[N],m; // 存放素数\nbool mp[N];     // 判断是否为素数\nint v[N]={0};\n\nvoid primes(){\n    for(int i=2;i&amp;lt;=N;i++){\n        if(v[i]==0) prime[m++]=i,v[i]=i,mp[i]=true;\n        for(int j=0;j&amp;lt;m;j++){\n            if(prime[j]&amp;gt;v[i]||prime[j]&amp;gt;N/i) break;\n            v[i*prime[j]]=prime[j];\n        }\n    }\n}\n\n\n博弈论\n\n给定一个有 N\n\n个节点的有向无环图，图中某些节点上有棋子，两名玩家交替移动棋子。\n\n玩家每一步可将任意一颗棋子沿一条有向边移动到另一个点，无法移动者输掉游戏。\n\n对于给定的图和棋子初始位置，双方都会采取最优的行动，询问先手必胜还是先手必败。\n\n对于一个有向无环图来说，如果只有一个棋子那么那个棋子的位置的sg值为0则必败，否则必胜\n如果有多个棋子那么取这些棋子的sg的异或值，异或值为0则必败，否则必胜。\n\n#include&amp;lt;bits/stdc++.h&amp;gt;\nusing namespace std;\n\nconst int N=1e5+10;\n\nint head[N],edge[N],Next[N],tt;\nint n,m,p;\nint a[N];\nvoid add(int x,int y){\n\tedge[++tt]=y;\n\tNext[tt]=head[x];\n\thead[x]=tt;\n}\nint h[N];\n\nint sg(int x){\n\tif(h[x]!=-1) return h[x];\n\tunordered_map&amp;lt;int,bool&amp;gt;mp;\n\tfor(int i=head[x];i;i=Next[i]){\n\t\tint y=edge[i];\n\t\tmp[sg(y)]=true;\n\t}\n\tfor(int i=0;i&amp;lt;=n;i++){\n\t\tif(!mp[i]){\n\t\t\th[x]=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn h[x];\n}\n\nint main(){\n\tscanf(&quot;%d %d %d&quot;,&amp;amp;n,&amp;amp;m,&amp;amp;p);\n\tfor(int i=1,x,y;i&amp;lt;=m;i++){\n\t\tscanf(&quot;%d %d&quot;,&amp;amp;x,&amp;amp;y);\n\t\tadd(x,y);\n\t}\n\tmemset(h,-1,sizeof h);\n\tint res=0;\n\tfor(int i=1;i&amp;lt;=p;i++){\n\t\tscanf(&quot;%d&quot;,a+i);\n\t\tres^=sg(a[i]);\t// 用于计算sj函数 \n\t}\n\tif(res==0) puts(&quot;lose&quot;); \n\telse puts(&quot;win&quot;);\n\treturn 0;\n}\n\n"
} ,
  
  {
    "title"    : "基于svm实现的屏幕翻译项目解析",
    "category" : "",
    "tags"     : " 人工智能, 计算机视觉, python, 机器学习, 爬虫",
    "url"      : "/tranlate",
    "date"     : "February 19, 2023",
    "excerpt"  : "\n  不知不觉间，人工智能慢慢开始走进千家万户。无人驾驶、AI绘图、语音识别、AI聊天都是人工智能的领域。我作为一个智能的学生已经被迷得不行了，在这份热爱的支持下我完成了这份项目。虽然我的项目与当今智能技术无法比拟，但是其中运用到的机器学习模型（如SVM分类器）足以能够让我的项目归类到人工智能。\n\n\n目录\n\n  目录\n  前言\n  项目总目标\n  正文\n    \n      数据收集与数据清洗\n        \n          为什么要收集数据？\n          数据收集\n    ...",
  "content"  : "\n  不知不觉间，人工智能慢慢开始走进千家万户。无人驾驶、AI绘图、语音识别、AI聊天都是人工智能的领域。我作为一个智能的学生已经被迷得不行了，在这份热爱的支持下我完成了这份项目。虽然我的项目与当今智能技术无法比拟，但是其中运用到的机器学习模型（如SVM分类器）足以能够让我的项目归类到人工智能。\n\n\n目录\n\n  目录\n  前言\n  项目总目标\n  正文\n    \n      数据收集与数据清洗\n        \n          为什么要收集数据？\n          数据收集\n          数据规范化\n        \n      \n      建模与机器学习（SVM）\n        \n          对建模的理解与机器学习的理解\n          建模\n            \n              1.随机划分训练集与测试集\n              2.参数调优\n              3.训练\n              4.模型检验\n              5.模型保存\n            \n          \n          数据处理\n        \n      \n      单词 \\&amp;amp; 句子的识别\n        \n          Q \\&amp;amp; A\n          findContours轮廓获取函数说明\n            \n              函数说明\n              函数签名\n              代码演示\n            \n          \n          首先从图片中分离出句子\n          其次从句子中分离出单词\n          最后从单词中分离出字母并识别\n        \n      \n      翻译\n        \n          传统爬虫\n          selenium技术模块介绍\n          selenium与传统爬虫的对比\n            \n              传统爬虫爬百度翻译\n              selenium爬百度翻译\n            \n          \n          selenium效率优化\n            \n              1. 使用显式等待\n              2. 无头浏览器\n              3. 多线程优化\n            \n          \n          翻译实现\n        \n      \n    \n  \n  作者自己的一些话\n\n\n\n\n前言\n  此项目专用于204技术交流会使用，未经本人允许不得外传。为了更好地展示项目，所以在这里写下这篇博客。本博客面向新人，我尽可能的使用了最朴素的方式来表达我的项目技术流程以及算法思想，且文章中不会出现大量生僻难懂的术语，请放心食用。另外，此静态博客网基于Jekyll框架搭建，但对Jekyll的讨论并不在此次技术交流之列中。如果你对Jekyll感兴趣，随时欢迎与我讨论❤️。\n\n  本项目设计以及编码历时共7天，共计划分8个模块，项目大致可以划出以下几个技术分支：\n\n  基于opencv实现的数据清洗与预处理\n  基于svm机器学习分类器识别字母\n  基于selenium无头浏览器实现的翻译爬虫\n  使用threading线程池优化\n\n\n\n\n\n  温馨提示：如果你觉得界面配色有些刺眼，你可以点击右上角的菜单，选择使用圆形按钮切换主题背景。\n\n\n项目总目标\n\n  实现一个可以实时读取屏幕信息，并翻译图中英文的屏幕翻译器。\n\n  效果展示如下图，左右分别为翻译前后的对比：\n\n\n    \n    \n        \n    \n    \n    \n        \n    \n    \n\n\n  项目主要的技术点以及流程如下所示\n\n\n    \n    \n        \n    \n    \n\n\n\n正文\n\n\n\n数据收集与数据清洗\n\n\n为什么要收集数据？\n\n  要翻译屏幕中的英文，首先要做的应该是识别出屏幕中的英文。识别的工作是交由机器学习模型实现的，但是模型并不是一开始就拥有识别英文的能力。事实上你可以将python所提供机器学习模型视为空壳，只有通过不断的喂养其数据，主观的告诉模型什么是对的什么是错的，在不断的训练学习之后模型才有识别的能力。机器学习因此得名“机器学习”。\n\n  什么？你问我为什么不直接去网上下载一个模型？\n  那肯定是（没找到）想要锻炼💪自己呀！\n\n  一般的，一个模型的好坏主要最关键的因素是数据的优劣。数据越多越纯净就越容易训练出优秀的模型。因此数据整理的部分显的尤为重要。\n\n\n数据收集\n\n  模型需要识别的是屏幕中的英文，所以收集的数据也应该是印刷体的的字母图片。不过这类数据资源在网上很少能找得到，少数在Gethub和Kaggle上找到的资源所训练出的模型效果都不尽人意。\n\n  最终还是决定，自己动手创造数据。\n  首先准备好自制的52个大小写英文字母一份。\n\n\n    \n    \n        \n    \n    \n\n\n  每个字母只有一张图片用以供应模型的训练肯定是不够用的，所以应该对数据进行扩充，保证至少每个字母对应能有20张匹配的图片。这里使用到的技术是图片的下采样以做到图片的扩充，简单的理解就是通过对一张图片采用随机的不同程度的模糊化处理从而到多张图片。\n\n  其中对字母A的采样结果示意图如下：\n\n\n    \n    \n        \n    \n    \n\n\n  你问我为什么不多造几个数据，而是使用下采样扩充？\n  （肝不够多）下采样得到的图片是对原有图片的衍生，同样拥有原图像的基本信息，用这样的数据进行训练不会影响模型的效果。\n\n数据规范化\n\n  图像数据需要最终供模型训练，而训练的接口是固定的，因此所有的数据应该有相同的规格。\n\n  我的做法是将数据处理成 \\(20*20\\) 像素的黑白图片素材使用。\n\n  也就是将一个普通的字母图片通过横向纵向的拉伸与压缩变成一个 \\(20*20\\) 标准的图片。显而易见的，这种做法很容易导致图片信息了流失。我在实践中也遇到了这个问题，其中影响最大的就是字母 \\(il\\) 等长宽比差距较大的字母，如果直接通过拉伸与放缩的手段让其规范化的话就会出现以下的结果（左边为原图，右边为处理后的图像）以至于影响到后面建模的效果:\n\n\n    \n    \n        \n    \n    \n    \n        \n    \n    \n\n\n  对此我的做法是显式地判断图片的长宽比，当长宽比超过4时，手动放缩，具体代码如下：\n\n    def resize(self, img):\n        &quot;&quot;&quot;\n        图像需要原先就是灰度图像\n        将图片调整到标准大小20*20\n        :param img: 原图像\n        :return:finish_img\n        &quot;&quot;&quot;\n\n        if img.shape[0] / img.shape[1] &amp;gt; 4:  # 表示长宽比太大了，不适合做拉伸操作\n            ## 待补充，这里需要解决过度拉伸的问题，可能需要寻找填充的方法\n            # 计算需要用于填充的图像的宽高\n            high = img.shape[0]\n            wide = int((img.shape[0] - img.shape[1]) / 2)\n\n            grid = np.zeros((high, wide))  # 计算用于填充的黑色图片\n\n            img = np.hstack((grid, img))  # 左右都做填充\n            img = np.hstack((img, grid))  # 左右都做填充\n\n            # 最后将填充的图像重新转换为20*20的格式\n            img = cv2.resize(img, (20, 20))\n            if self.debug:\n                print(&quot;这里做了一次对称填充&quot;)\n        else:\n            img = cv2.resize(img, (20, 20))\n        # 调整大小并返回\n        return img\n\n\n\n建模与机器学习（SVM）\n\n对建模的理解与机器学习的理解\n  在数据规范化后我们得到了，噪音（杂质）相对较少的 \\(20 * 20\\)的图片信息，但是我们的\\(SVM\\)分类器模型（下面以“\\(SVM\\)”简称）还不能直接使用这些数据，\\(SVM\\)所反映的是多个数值影响一个数值的映射关系函数，可以简单的概括成以下的函数，训练的最终目的就是为了得到这个函数：\n\n\\[f(x) = w_1x_1 + w_2x_2 + w_3x_3 + /dots w_nx_n\\]\n\n\n  其中 \\(x_i\\) 表示自变量，可以理解为对应图片像素点的数值，\\(w_i\\)表示权值，\\(f(x)\\)是最终计算出来的结果。\n\n\n  将之前清洗好的图像，当成一个个\\(n\\)组400维的方程组，使用\\(SVM\\) 算法“解方程”。\n\n\n  400维由来：一个20*20的图片有400个像素点\n\n\n  上面最终计算得到上面的式子，也就是我们所说的一个训练好的模型。\n\n\n建模\n  数据建模，在这里不是指3D建模，而是指一个机器学习的流程。这里数据建模用到了机器学习是本项目可以称之为人工智能的原因之一。接下来将简单讲解机器学习的流程。\n\n1.随机划分训练集与测试集\n\n  将整理好的数据，按照一定比例划分成训练集与测试集，训练集的数据顾名思义是用于训练数据的，测试集的数据是用来检验模型的正确率的。\n\n\n  训练集的数据就好比那些的有答案的课本，我们拿他学习提升自己的能力，而测试集则更像是试卷，用来检测我们的学习成果。\n\n\n2.参数调优\n\n   一个模型往往有很多的参数需要我们定义，这些参数在不同的情况下需要取不同的数值才能使模型达到最优的效果。不同于平时的算法竞赛题目，这些参数值往往不是确定的，需要我们自己去调整。当然，我们不需要自己手动调参，我们可以用网格搜索与k折交叉验证两种方法来解决最优参数的寻找问题。\n\n  这两种算法的主要做法是，将训练集的数据继续分出一个和验证集，通过不断测试与调整，最终计算出最优模型的参数。由于篇幅有限，其具体做法这里不做过多的描述。\n\n3.训练\n\n  模型训练的操作，其实才是机器学习里面最难的部分，不过好在SVM已经被python封装好了，我们只需要提供前面清洗出的数据以及定义参数调优，稍等片刻即可得到训练好的模型。\n\n4.模型检验\n\n  将之前分出的测试集数据代入模型进行预测，计算正确率。当然评价一个模型的好坏的指标有很多其他的评价指标还有\\(R^2\\)，召回率等等，这里不做延伸。\n\n5.模型保存\n\n  每次训练一个模型经常要消耗大量的时间，为此我们需要保存训练好的模型，在下次做识别时就不需要再训练了。\n\n  上面对机器学习的建模过程的描述地十分简单，但是实际的建模过程远比这个要复杂。只要前面在的“数据分析”“数据选择与清洗”“模型选择”“参数设置”等等环节出现了一个错误都有可能把你的人工智能模型训练成“人工智障”，而且前面的繁多步骤也会加大调参排错的难度。我也是花了4天左右的时间才训练出了一个比较过得去的模型。\n\n\n  ⚡如果你也想入门人工智能，那要求你至少要有比较强的python基础，成熟的面向对象的思维，以及强大的心理素质。⚡\n\n\n  以下是py代码实现\n    def train(self):\n        &quot;&quot;&quot;\n        SVM模型实现\n        :return: None\n        &quot;&quot;&quot;\n        ## 数据分析与预处理\n        x_train, y_train, x_test, y_test = self.get_data()\n\n        ## 网格搜索,找到最优参数\n        machine_svm = svm.SVC()\n\n        param_grid = {&#39;C&#39;: range(0, 50, 10)}  # 这里设置了参数的测试范围\n        grid_search = GridSearchCV(machine_svm, param_grid, cv=3)  # 建立网格搜索器模型\n        grid_search.fit(x_train, y_train)  # 开始搜索\n\n        ## 创建分类器对象\n        print(&quot;最优参数是 c= &quot;, grid_search.best_params_)\n        print(&quot;最优模型正确率 = &quot;, grid_search.best_score_)\n        self.machine_svm = grid_search.best_estimator_  # 获取最优模型\n\n        ## 模型训练\n        self.machine_svm.fit(x_train, y_train)\n\n        ## 模型验证\n        result = self.machine_svm.predict(x_test)\n        correct = np.count_nonzero(result == y_test)\n        accuracy = correct / result.size\n\n        print(&quot;测试集正确率：&quot;, accuracy)\n\n        ## 模型保存\n        joblib.dump(self.machine_svm, &#39;model/svm.pkl&#39;)\n\n\n\n\n\n数据处理\n\n  在前面，我们用做了特殊处理的图片对模型进行训练，所以在用该模型进行识别操作时，也需要对被识别图像做同样的操作。在之前清洗数据时我并没有详细讲解具体的操作，所以放到这里详细说明。\n\n  我们想要预测一个图像，显然无法直接对一个RGB格式的图片下手，对于一个RGB格式的图片，它的每一个像素点都由三个数值组成（Rad Green Blue），这不利于识别，所以需要处理成一个数值，这样的处理过程我们称之为灰度化。\n\n  如下方的两个图像就是做了灰度化处理的图像对比。\n\n\n    \n    \n        \n    \n    \n    \n        \n    \n    \n\n\n  为了更好的配对模型，我们需要对灰度图进一步简化，通常的做法是将像素点间的差距拉的尽可能大（离散化），我们通常使用的方式是二值化\n\n  如下方的两个图像是灰度图像做了二值化处理的前后对比。\n\n\n    \n    \n        \n    \n    \n    \n        \n    \n    \n\n\n  二值化后的图像，为过滤或弱化出图形中的小白点（噪音），我们常常采用高斯模糊（打马赛克）以及腐蚀的方法。\n\n  如下图分别为做了高斯模糊和腐蚀操作的二值图像。\n\n\n    \n    \n        \n    \n    \n    \n        \n    \n    \n\n\n  有时，我们会把握不好腐蚀操作的度，以至于一些重要信息也被过滤掉了，为了弥补过滤掉的内容，一般会对腐蚀后的图像做膨胀操作。\n一般的，先对一个图像做腐蚀再对齐做膨胀的组合操作我们称之为开运算。\n\n  如下为两个分别是做了碰撞和开运算的图像。\n\n\n    \n    \n        \n    \n    \n    \n        \n    \n    \n\n\n  通过opencv库实现以上操作，可以帮助我们从一张图片中提取出很多有效的信息。你可以从下面的代码中直观得体会出这个处理流程。\n\n    def change_color(self, img):\n        &quot;&quot;&quot;\n        将图像进行预处理\n        :param img:img 彩图\n        :return: img 二值图\n        &quot;&quot;&quot;\n        ## 原图像备份\n        copy_img = img.copy()\n        self.show(copy_img)\n\n        ## 高斯模糊\n        copy_img = cv2.GaussianBlur(img, (3, 3), 0)\n\n        ## 图像灰度化\n        copy_img = cv2.cvtColor(copy_img, cv2.COLOR_BGR2GRAY)\n        self.show(copy_img)\n\n        ## 图像二值化\n        _, copy_img = cv2.threshold(copy_img, 115, 255, cv2.THRESH_BINARY_INV)\n        self.show(copy_img)\n\n        ## 开运算降噪\n        copy_img = cv2.morphologyEx(copy_img, cv2.MORPH_OPEN, np.ones((2, 2)), iterations=2)\n        self.show(copy_img)\n\n        ## 膨胀运算\n        copy_img = cv2.morphologyEx(copy_img, cv2.MORPH_DILATE, np.ones((5, 5)), iterations=4)\n        self.show(copy_img)\n\n        return copy_img\n\n\n\n单词 &amp;amp; 句子的识别\n\n  在前面的讲解中，我们已经得到了可以识别字母的模型和清洗好的数据。但是模型只有识别字母的能力没有识别单词的功能，更没有识别句子的能力。所以这里我们需要自己想办法将识别出来的字母进行组合拼凑。\n\n\n\nQ &amp;amp; A\n\n  问题1：为什么，模型无法识别单词？\n  答：模型是拿字母图集训练出来的，所以只能识别单词。\n\n  问题2：是否能够训练出能识别单词的模型\n  答：可以，但是成本很大，效率也不高。对于26个字母都需要上百的图形数据取训练，如果换成数不胜数的单词的话，需要的数据那更是数不清。而且单词之间本身就有很多相似的部分，这也会加大识别的难度降低效率。\n\n  问题3：如果模型不能识别单词，那要怎么处理这个问题呢？\n  答：其实使用数据处理中说到的的方法就可以巧妙地处理这个问题，不过还要用到cv中的一个内置函数函数，具体操作请看下文。\n\n\n\nfindContours轮廓获取函数说明\n\n函数说明\n\n   findContours可以作用于，二值图像，查找出图像的所有轮廓信息并返回。\n\n函数签名\n\n    def findContours(image, mode, method, contours=None, hierarchy=None, offset=None):\n\n  image：表示一个二值度图像。\n  mode：使用的二值化的算法。\n  method：轮廓检测的方式。\n\n  函数具体的使用方式这里不做过多的阐述，如果你对此感兴趣，详情请看这里👉findContours函数详细解析\n\n代码演示\n\n  文字的描述或许依然让你难以理解。那么我们来看看下面的代码和效果展示。\n\ndef test_findContours(self, image=None):\n    &quot;&quot;&quot;\n        该函数用于展示findContours的函数\n        :param img: img\n        :return: img,con\n    &quot;&quot;&quot;\n    ## 轮廓提取\n    contours, w1 = cv2.findContours(image, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n    \n    ## 轮廓绘制\n    show_img = cv2.drawContours(copy_img.copy(), contours, -1, (0, 0, 255), 3)\n    self.show(show_img)\n\n\n  如下两图，分别是原图和描绘轮廓后的图形。\n\n\n    \n    \n        \n    \n    \n    \n        \n    \n    \n\n\n\n\n首先从图片中分离出句子\n\n  如何识别出一个句子？其实我们只需要框出句子的轮廓，再根据轮廓信息，从原图像中裁剪出来即可。\n\n  但是前面谈到的findContours函数似乎只能查找出字母的轮廓，那要怎么做？\n\n  其实只要适当的对图像做膨胀运算，让所有的字母粘连在一起，所有的单词粘连在一起，让它们形成一个整体。那这个整体不就是句子的轮廓了吗？怎么样是不是很巧妙？\n\n\n  不能上手就对图像做膨胀运算，这可能会放大一些杂质（噪音）！\n\n\n  下面将处理过程进行展示，处理次序依次是高斯模糊、灰度化、二值化、开运算、膨胀\n\n\n    \n    \n        \n    \n    \n    \n        \n    \n    \n    \n        \n    \n    \n\n\n\n    \n    \n        \n    \n    \n    \n        \n    \n    \n    \n        \n    \n    \n\n\n  代码实现如下。\n\n    def change_color(self, img):\n        &quot;&quot;&quot;\n        将图像进行预处理\n        :param img:img 彩图\n        :return: img 二值图\n        &quot;&quot;&quot;\n        ## 原图像备份\n        copy_img = img.copy()\n        self.show(copy_img)\n\n        ## 高斯模糊\n        copy_img = cv2.GaussianBlur(img, (3, 3), 0)\n\n        ## 图像灰度化\n        copy_img = cv2.cvtColor(copy_img, cv2.COLOR_BGR2GRAY)\n        self.show(copy_img)\n\n        ## 图像二值化\n        _, copy_img = cv2.threshold(copy_img, 115, 255, cv2.THRESH_BINARY_INV)\n        self.show(copy_img)\n\n        ## 开运算降噪\n        copy_img = cv2.morphologyEx(copy_img, cv2.MORPH_OPEN, np.ones((2, 2)), iterations=2)\n        self.show(copy_img)\n\n        ## 膨胀运算\n        copy_img = cv2.morphologyEx(copy_img, cv2.MORPH_DILATE, np.ones((5, 5)), iterations=4)\n        self.show(copy_img)\n\n        return copy_img\n\n\n\n\n其次从句子中分离出单词\n\n  这一步操作其实和，上一步差不多，只不过需要将膨胀运算等的参数略做调整，使得单词中的字母之间互相连接而单词之间不连接。\n\n  除此之外，还要记录单词之间的次序，以便后期整理。\n\n  话不多说，上结果：\n\n\n    \n    \n        \n    \n    \n    \n        \n    \n    \n    \n        \n    \n    \n\n\n\n    \n    \n        \n    \n    \n    \n        \n    \n    \n    \n        \n    \n    \n\n\n  下面是代码展示，相比与句子识别部分的代码，下面还多了单词剪切和手动降噪的等代码逻辑。\n\n    def image_init(self, img=None):\n        &quot;&quot;&quot;\n        该函数用于将图像灰度化，模糊化，二值化等操作得到可以处理的图像\n        :param img: img\n        :return: img,con\n        &quot;&quot;&quot;\n        if img is None:\n            img = self.img\n        copy_img = img.copy()\n\n        ## 高斯滤波\n        img = cv2.GaussianBlur(img, (3, 3), 0)\n\n        ## 灰度化处理\n        gray_img = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)\n\n        ## 二值化\n        _, binary = cv2.threshold(gray_img, 120, 255, cv2.THRESH_BINARY_INV)\n\n        # ## 开运算用以降噪\n        kernel = np.ones((3, 3))\n        image = cv2.morphologyEx(binary, cv2.MORPH_OPEN, kernel, iterations=1)\n\n        ## 膨胀\n        image = cv2.morphologyEx(binary, cv2.MORPH_DILATE, kernel, iterations=4)\n\n        ## 轮廓提取\n        contours, w1 = cv2.findContours(image, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n        show_img = cv2.drawContours(copy_img.copy(), contours, -1, (0, 0, 255), 3)\n\n        ## 提取有效轮廓\n        result = []\n        for item in contours:\n            if cv2.contourArea(item) &amp;lt; self.min_area:  # 过于小的部分抛弃\n                continue\n\n            rect = cv2.boundingRect(item)\n            x, y, weight, height = rect  # 这个是轮廓的信息\n            result.append(rect)  # 收集所有的轮廓信息\n        # contour 所表示的是每一个矩形轮廓的左上点和右下点的坐标\n\n        contours = [[[a[0], a[1]], [a[0] + a[2], a[1] + a[3]]] for a in result]\n\n        ## 剪切对应的轮廓，并返回对应的轮廓矩形的左上点和右下点的坐标集合、\n        result_imgs = []\n        for contour in contours:\n            result_imgs.append(copy_img[contour[0][1]:contour[1][1], contour[0][0]:contour[1][0]])\n\n        return result_imgs, contours\n\n\n\n\n最后从单词中分离出字母并识别\n\n  其实这一步大体与前面步骤相同，只不过可能不需要再进行膨胀运算了，不然的话将字母整理粘合在一起就不好识别了。\n\n  同样的，我们需要记录分离出来的字母的前后次序，以便整理出正确单词。\n\n  对于每一个分离出来的字母图片同样按照之前数据处理的步骤，整理成一个可供SVM分类器识别的二值图片后，进行字母预测。\n\n  将识别好的字母按顺序组成单词，再将单词按照次序整理成句子（有些类似于函数回溯的过程）。那么我们就得到了图片的英文识别结果了。\n\n  那么下面这两张图就是字母分离的结果，也是我们之前所展示过的。\n\n\n    \n    \n        \n    \n    \n    \n        \n    \n    \n\n\n  下面给出，字母图片处理的有关代码逻辑\n\n    def resize(self, img):\n        &quot;&quot;&quot;\n        图像需要原先就是灰度图像\n        将图片调整到标准大小20*20\n        :param img: 原图像\n        :return:finish_img\n        &quot;&quot;&quot;\n\n        if img.shape[0] / img.shape[1] &amp;gt; 4:  # 表示长宽比太大了，不适合做拉伸操作\n            ## 待补充，这里需要解决过度拉伸的问题，可能需要寻找填充的方法\n            # 计算需要用于填充的图像的宽高\n            high = img.shape[0]\n            wide = int((img.shape[0] - img.shape[1])/2)\n\n            grid = np.zeros((high, wide))  # 计算用于填充的黑色图片\n\n            img = np.hstack((grid, img))      # 左右都做填充\n            img = np.hstack((img, grid))  # 左右都做填充\n\n            # 最后将填充的图像重新转换为20*20的格式\n            img = cv2.resize(img, (20, 20))\n\n          else:\n            img = cv2.resize(img, (20, 20))\n\n        # 调整大小并返回\n        return img\n\n\n\n\n翻译\n\n  翻译功能，本项目使用爬虫实现。\n\n传统爬虫\n\n  对于传统的爬虫，其一般步骤是：\n\n\n  抓包，找接口。\n  寻找表单中的一些参数规律，并解析。\n  封装请求头，保存cookie状态，考虑使用代理等。\n  发送表单请求，获取返回信息。\n  解析数据，并保存。\n\n\n  传统的爬虫方式，其实就是通过伪装成浏览器的方式获取网络资源的。这种做法的好处是，小巧轻便，速度快。\n\n  但是其局限性也很大，一旦后台更改了接口访问方式、文本加密方式就可能要重写一个份代码。对于需要保存登录信息的网页，我们使用的cookie也需要时不时更新一下。一些网站带有的反爬机制也会增加传统爬虫的难度。\n\n\n  顺带一提，百度翻译现在已经加密了翻译接口的表单参数，用传统的爬虫已经爬不了了。\n\n\n  所以我选择selenium技术进行爬虫。\n\n\n\nselenium技术模块介绍\n\n  如果说传统爬虫是伪装成浏览器，那么selenium就是模拟成浏览器访问数据。\n\n  什么是“模拟成浏览器”？\n\n  就是像真的浏览器一样，加载一个网页上所有的数据包括，JavaScript，html，png，等等。\n  如果处理得当，这种爬虫可以规避 \\(95%\\) 的反爬监控。\n\n\n\nselenium与传统爬虫的对比\n\n  selenium的工作思路是基于网页html结构的，而传统爬虫是针对的API接口。\n\n  下面以百度翻译的爬取为例来说明这两种方式的区别。\n\n\n\n传统爬虫爬百度翻译\n\n  1. 打开网页，输入数据，开始抓包。\n\n\n    \n    \n        \n    \n    \n\n\n  2. 找到带有，翻译结果的参数。\n\n\n    \n    \n        \n    \n    \n\n\n  3. 根据抓包工具提供的信息封装请求头。\n\n\n    \n    \n        \n    \n    \n\n\n  4. 整理表单数据，发送请求。\n\n  5. 接收返回信息并解析。\n\n\n\nselenium爬百度翻译\n\n  1. 打开网页，找到输入框，从html源码中定位输入框的位置，编写XPATH语句。\n\n\n    \n    \n        \n    \n    \n\n\n  2. 在定位到的输入框组件中，（不需要手动输入）输入数据。\n\n  3. 再次使用XPATH语法，直接从结果框中定位翻译结果。\n\n\n    \n    \n        \n    \n    \n\n\n  selenium的优势在于，不需要繁琐的更新请求头，不用担心接口的更新而导致程序会失效，selenium相比传统的爬虫更加稳定，如果网页没有较大的改变selenium可以一直有效。selenium的难度也不大，只要有一点html基础和XPATH语法就可以灵活使用。\n\n  selenium的劣势也很明显，由于是模拟浏览器，所以会加载很多用不上的信息，比如网页中的图片，视频之类的资源，这会使得爬取的速度下降。\n\n\n\nselenium效率优化\n\n  前面有提到，selenium因加载无用信息而导致速度的下降，对此我们有以下几种方式来加速。\n\n1. 使用显式等待\n\n  网页中的信息往往在没有全部加载出来前（通俗的讲就是，刷新箭头还在转的时候），就已经出现了我们想要的信息，这个时候我们不需要等待直接上手抓数据。\n  这种方式称之为显式等待。\n\n2. 无头浏览器\n\n  所谓的无头浏览器就是，直接不展示界面，让selenium在后台加载数据，省去浏览器展示的时间。\n\n3. 多线程优化\n\n  这是一种传统的的方法。如果要访问多次，那么多个线程加载肯定比一个要快。要注意访问公共资源时上锁。\n\n\n  多线程优化用的好的话，程序效率会大大提升。不过这也同样加大了调试的难度。初学者要慎重使用。\n\n\n\n\n翻译实现\n\n  selenium爬虫的代码实现，部分代码\nclass spider:\n    url = &#39;https://fanyi.baidu.com/&#39;\n    path_ad = &#39;//div[@class=&quot;app-guide-inner&quot;]/div[@class=&quot;app-guide-aside&quot;]/span&#39;\n    path_input = &#39;//div[@class=&quot;textarea-wrap&quot;]/textarea[@class=&quot;textarea&quot;]&#39;\n    path_out = &#39;//p[@class=&quot;ordinary-output target-output clearfix&quot;]/span&#39;\n\n    @staticmethod\n    def get_no_ui_browser():\n        &quot;&quot;&quot;\n        获得一个无界面浏览器对象\n        :return: Chrome\n        &quot;&quot;&quot;\n        chrome_options = Options()\n        chrome_options.add_argument(&#39;--headless&#39;)\n        chrome_options.add_argument(&#39;--disable-gpu&#39;)\n        chrome_options.add_argument(&#39;blink-settings=imagesEnabled=false&#39;)  # 可以选择不加载图片以提升速度\n        browser = webdriver.Chrome(chrome_options=chrome_options)\n\n        return browser\n\n    @staticmethod\n    def get_browser():\n        &quot;&quot;&quot;\n        获得一个有界面浏览器对象（用于展示或者调试）\n        :return:  Chrome\n        &quot;&quot;&quot;\n\n        return webdriver.Chrome()\n\n    def click_object(self, object):\n        &quot;&quot;&quot;\n        用于点击一个元素\n        :param object:元素对象\n        :return: None\n        &quot;&quot;&quot;\n        self.browser.execute_script(&quot;arguments[0].click();&quot;, object)\n\n    def close_ad(self):\n        # 这里显示等待界面中的广告出现\n        try:\n            self.ad = WebDriverWait(self.browser, 1).until(EC.presence_of_element_located((By.XPATH, self.path_ad)))\n        except:\n            return\n        self.click_object(self.ad)\n\n    def __init__(self, debug=False):\n        self.browser = self.get_browser() if debug else self.get_no_ui_browser()  # 获取一个浏览器对象\n        self.browser.implicitly_wait(5)  # 设置隐式等待的时间\n\n        self.browser.get(self.url)  # 打开界面\n        self.close_ad()  # 关闭界面上的广告\n        self.find_button()  # 寻找输入框\n\n    def find_button(self):\n        &quot;&quot;&quot;\n        此方法用于实现常用元素的查找\n        :return: None\n        &quot;&quot;&quot;\n        ## 寻找输入输出框框\n        self.text_input = WebDriverWait(self.browser, 5).until(\n            EC.presence_of_element_located((By.XPATH, self.path_input)))\n        # self.text_out = self.browser.find_element(by=By.XPATH, value=self.path_out)\n\n    def input(self, text):\n        &quot;&quot;&quot;\n        用于给输入框输入句子\n        :param text: 待翻译文本\n        :return: bool\n        &quot;&quot;&quot;\n        self.text_input.clear()  # 清除输入内容\n        self.text_input.send_keys(text)  # 填写被翻译内容\n\n    def get_translate_sentence(self):\n        &quot;&quot;&quot;\n        获取翻译结果\n        :return:翻译结果\n        &quot;&quot;&quot;\n        try:\n            self.text_out = WebDriverWait(self.browser, 5).until(EC.presence_of_element_located((By.XPATH, self.path_out)))\n        except:\n            return &#39;&#39;\n        return self.text_out.text\n\n    def translate_sentence(self, text, wait=0.5):\n        &quot;&quot;&quot;\n        用于实现翻译的逻辑\n        :param text: 需要翻译的文本\n        :return: 翻译结果\n        &quot;&quot;&quot;\n        self.input(text)\n        time.sleep(wait)\n        return self.get_translate_sentence()\n\n\n  在加上多线程优化\nclass translation_queue:\n    number = 5  # 默认开启界面数\n    queue = []  # 浏览器队列\n    hh, tt = 0, 0  # 队列头，队列尾\n\n    def add_browser(self):\n        self.queue.append(spider())\n\n    def __init__(self, number=None):\n        ## 初始化线程池大小\n        if number is not None:\n            self.number = number\n\n        ## 初始化5个浏览器\n        children = []\n        for _ in range(self.number):\n            children.append(Thread(target=self.add_browser))\n            children[-1].start()\n\n        # 等待所有浏览器初始化完毕\n        for i in range(self.number):\n            children[i].join()\n\n    def set_text(self, text):\n        self.queue[self.tt].input(text)\n        self.tt = (self.tt + 1) % self.number\n\n    def get_text(self):\n        text = self.queue[self.hh].get_translate_sentence()\n        self.hh = (self.hh + 1) % self.number\n        return text\n\n\n\n\n作者自己的一些话\n\n  本项目其实只是对人工智能算法模型SVM分类器的一个小小的应用。一个模型能做的事情其实都很小很简单，因此对图片的数据清洗解析简化等的步骤尤为重要，而这些处理步骤其实就是，将我们所能看懂图片信息一步步转化成计算机能读的懂的数据。然后将计算机得到的结果转化成我们能读懂的信息（如图片，文字，视频）。这些转化的任务正是我们程序员的工作。\n\n  在项目实操中，还是遇到了不少的困难，例如训练数据找不到，训练数据洗不干净，模型效率低，字母il分不清，传统爬虫爬不了翻译等等问题。\n\n  程序试错试也是一个复杂的而又漫长的过程，多线程的优化更是进一步加大了编码的难度。\n\n  实现部分远比我当初预想的要难得多，没有团队的支持所有模块都是我一人完成的，平均花了1-2天的时间，虽然很辛苦，但总之项目还是写出来了，代码不多一共1400行，但行行都是心血的付出。\n\n  希望新人们在以后中遇到困难也可以坚持下去，办法总比困难多。只要方向是对的，那么坚持下去就没有错。\n\n\n\n回到顶部\n"
} ,
  
  {
    "title"    : "Java EE",
    "category" : "",
    "tags"     : " java, java ee, 期末考试",
    "url"      : "/javaee",
    "date"     : "December 24, 2022",
    "excerpt"  : "  Java EE，Java 平台企业版（Java Platform Enterprise Edition），之前称为Java 2 Platform, Enterprise Edition (J2EE)，2018年3月更名为 Jakarta EE(这个名称应该还没有得到群众认可)。是 Sun 公司为企业级应用推出的标准平台，用来开发B/S架构软件。Java EE 可以说是一个框架，也可以说是一种规范。\n\n\n\n前言\n  《java EE》是一门与就业相关度较高的一门课程，作为企业级的应用开发...",
  "content"  : "  Java EE，Java 平台企业版（Java Platform Enterprise Edition），之前称为Java 2 Platform, Enterprise Edition (J2EE)，2018年3月更名为 Jakarta EE(这个名称应该还没有得到群众认可)。是 Sun 公司为企业级应用推出的标准平台，用来开发B/S架构软件。Java EE 可以说是一个框架，也可以说是一种规范。\n\n\n\n前言\n  《java EE》是一门与就业相关度较高的一门课程，作为企业级的应用开发，虽然书本上学的ssm框架已经过时，但是作为我们初学者，它的价值还是不小的。\n\n  本博客按知识点整理一些相关内容，祝愿你可以取得一个让自己满意的成绩。\n\n\n问题解析\nSpring中Bean的作用域有哪些，默认是哪一个\n\n  singleton：单例模式（默认），在整个Spring IoC容器中，使用singleton定义的Bean将只有一个实例\n\n  prototype：原型模式，每次通过容器的getBean方法获取prototype定义的Bean时，都将产生一个新的Bean实例\n\n  request：对于每次HTTP请求，使用request定义的Bean都将产生一个新实例，即每次HTTP请求将会产生不同的Bean实例。只有在Web应用中使用Spring时，该作用域才有效\n\n  session：对于每次HTTP Session，使用session定义的Bean豆浆产生一个新实例。同样只有在Web应用中使用Spring时，该作用域才有效\n\n  globalsession：每个全局的HTTP Session，使用session定义的Bean都将产生一个新实例。典型情况下，仅在使用portlet context的时候有效。同样只有在Web应用中使用Spring时，该作用域才有效\n\n\n\nSpring中有哪些注解\n  1. @Controller：将Controller层的类对象交由spring容器生成与管理\n\n  2. @Service：将Service层的类对象交由spring容器生成与管理\n\n  3. @Repository：将Dao层的类对象交由spring容器生成与管理\n\n  4. @Component将类对象交由spring容器生成与管理\n\n\n\nSpring AOP、IOC的概念\n  AOP(Aspect-Oriented Programming:面向切面编程)：是指将那些与业务无关，却被多个业务模块所共同调用逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，提升系统的可维护性。\n\n  IOC就是控制反转，是指程序将创建对象的控制权转交给Spring框架进行管理，由Spring通过java的反射机制根据配置文件在运行时动态的创建实例，并管理各个实例之间的依赖关系。\n\n\n\nSpring AOP中的通知类型\n\n\n  \n    \n      通知类型\n      注解\n      说明\n    \n  \n  \n    \n      before（前置通知）\n      @Before\n      通知方法在目标方法调用之前执行\n    \n    \n      after（后置通知）\n      @After\n      通知方法在目标方法返回或异常后调用\n    \n    \n      after-returning（返回通知）\n      @AfterReturning\n      通知方法会在目标方法返回后调用\n    \n    \n      after-throwing（异常抛出通知）\n      @AfterThrowing\n      通知方法会在目标方法抛出异常后调用\n    \n    \n      around（环绕通知）\n      @Around\n      通知方法会将目标方法封装起来\n    \n  \n\n\n\n\nSpring 实现AOP的动态代理的方式\n\n  1. JDK动态代理（基于接口实现的）：JDK动态代理制能对实现了接口的类生成代理，而不是针对类\n\n  2. CGLIB动态代理（基于类实现的）：CGLIB是针对类实现代理，主要对指定的类生成一个子类，覆盖其中的方法，添加额外功能，因为是继承，所以该类方法不能用final来声明。\n\n\n\nMyBaes如何防止SQL注入问题\n\n  在编写MyBatis的映射语句时，尽量采用“#{xxx}”这样的格式。若不得不使用“${xxx}”这样的参数，要手工地做好过滤工作，来防止SQL注入攻击。\n\n\n\n动态SQL的使用\n\n&amp;lt;select id=&quot;queryList&quot; parameterType=&quot;com.jinzheng.pojo.Book&quot; resultType=&quot;com.jinzheng.pojo.Book&quot;&amp;gt;\n    select * from tb_book\n    &amp;lt;where&amp;gt;\n        &amp;lt;if test=&quot;id != null and id !=&#39;&#39; &quot;&amp;gt;\n            or id = #{id}\n        &amp;lt;/if&amp;gt;\n        &amp;lt;if test=&quot;name != null and name !=&#39;&#39; &quot;&amp;gt;\n            or name like concat(&#39;%&#39;,#{name},&#39;%&#39;)\n        &amp;lt;/if&amp;gt;\n        &amp;lt;if test=&quot;press != null and press !=&#39;&#39; &quot;&amp;gt;\n            or press like concat(&#39;%&#39;,#{press},&#39;%&#39;)\n        &amp;lt;/if&amp;gt;\n        &amp;lt;if test=&quot;author != null and author !=&#39;&#39; &quot;&amp;gt;\n            or author like concat(&#39;%&#39;,#{author},&#39;%&#39;)\n        &amp;lt;/if&amp;gt;\n        &amp;lt;if test=&quot;bookPrice != null and bookPrice !=&#39;&#39; &quot;&amp;gt;\n            or bookPrice = #{bookPrice}\n        &amp;lt;/if&amp;gt;\n    &amp;lt;/where&amp;gt;\n&amp;lt;/select&amp;gt;\n\n\n\n\nSpring MVC的工作原理\n\n\n    \n    \n        \n    \n    \n\n\n\n\n开发Java Web项目的三层架构\n\n  1)：数据访问层：(dao持久层)主要是对原始数据（数据库或者文本文件等存放数据的形式）的操作层，\n而不是指原始数据，也就是说，是对数据的操作，而不是数据库，具体为业务逻辑层或表示层\n提供数据服务．\n\n  2)：业务逻辑层：(service)主要是针对具体的问题的操作，也可以理解成对数据层的操作，对数据业务\n逻辑处理，如果说数据层是积木，那逻辑层就是对这些积木的搭建。具体的讲主要负责对数\n据层的操作。也就是说把一些数据层的操作进行组合。\n\n  3)：表示层：(controller)主要表示WEB方式，如果逻辑层相当强大和完善，\n无论表现层如何定义和更改，逻辑层都能完善地提供服务。\n主要对用户的请求接受，以及数据的返回，为客户端提供应用程序的访问。\n\n\n\nserverlet需要实现的两个方法是什么\n  1. toGet 方法\n  2. toPut 方法\n\nJSP的9个内置对象\n\n  1. Request对象\n  2. Response对象\n  3. Out对象\n  4. session对象\n  5. Application对象\n  6. PageContext对象\n  7. Config对象\n  8. Page（相当于this）对象\n  9. Exception对象\n\n\n\n程序设计题\n1. MyBean\n设计一个数据库访问的代码：\n\npublic void userFindByIdTest() {\n    String resources = &quot;mybatis-config.xml&quot;;\n    Reader reader = null;\n    try {\n        reader = Resources.getResourceAsReader(resources);\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n    SqlSessionFactory sqlMapper = new SqlSessionFactoryBuilder().build(reader);\n    SqlSession session = sqlMapper.openSession();\n    User user = session.selectOne(&quot;findById&quot;, 1);\n    System.out.println(user.getUname());\n    session.close();\n}\n\n\n2. AOP\n基于注解的AOP代码：\n\n注册bean\n\n&amp;lt;bean name=&quot;userDao&quot; class=&quot;com.itheima.demo03.UserDaoImpl&quot;/&amp;gt;\n&amp;lt;bean name=&quot;AnnoAdvice&quot; class=&quot;com.itheima.demo04.AnnoAdvice&quot;/&amp;gt;\n&amp;lt;!-- 开启@aspectj的自动代理支持 --&amp;gt;\n&amp;lt;aop:aspectj-autoproxy/&amp;gt;\n\n\n\n定义通知\n/**\n * 1、在切面中，需要通过指定的注解将方法标识为通知方法\n * @Before：前置通知，在目标对象方法执行之前执行\n * @After：后置通知，在目标对象方法的finally字句中执行\n * @AfterReturning：返回通知，在目标对象方法返回值之后执行\n * @AfterThrowing：异常通知，在目标对象方法的catch字句中执行\n *\n * 2、切入点表达式：设置在标识通知的注解的value属性中\n * execution(public int com.atguigu.spring.aop.annotation.CalculatorImpl.add(int, int)\n * execution(* com.atguigu.spring.aop.annotation.CalculatorImpl.*(..)\n * 第一个*表示任意的访问修饰符和返回值类型\n * 第二个*表示类中任意的方法\n * ..表示任意的参数列表\n * 类的地方也可以使用*，表示包下所有的类\n * 3、重用切入点表达式\n * //@Pointcut声明一个公共的切入点表达式\n * @Pointcut(&quot;execution(* com.atguigu.spring.aop.annotation.CalculatorImpl.*(..))&quot;)\n * public void pointCut(){}\n * 使用方式：@Before(&quot;pointCut()&quot;)\n *\n * 4、获取连接点的信息\n * 在通知方法的参数位置，设置JoinPoint类型的参数，就可以获取连接点所对应方法的信息\n * //获取连接点所对应方法的签名信息\n * Signature signature = joinPoint.getSignature();\n * //获取连接点所对应方法的参数\n * Object[] args = joinPoint.getArgs();\n *\n */\n \n@Component\n@Aspect  //将当前组件标识为切面\npublic class LoggerAspect {\n \n    @Pointcut(&quot;execution(* com.atguigu.spring.aop.annotation.CalculatorImpl.*(..))&quot;)\n    public void pointCut(){}\n \n    //前置通知\n    //@Before(&quot;execution(public int com.atguigu.spring.aop.annotation.CalculatorImpl.add(int, int))&quot;)\n    //@Before(&quot;execution(* com.atguigu.spring.aop.annotation.CalculatorImpl.*(..))&quot;)\n    @Before(&quot;pointCut()&quot;)\n    public void beforeAdviceMethod(JoinPoint joinPoint) {\n        //获取连接点所对应方法的签名信息\n        Signature signature = joinPoint.getSignature();\n        //获取连接点所对应方法的参数\n        Object[] args = joinPoint.getArgs();\n        System.out.println(&quot;LoggerAspect，方法：&quot;+signature.getName()+&quot;，参数：&quot;+ Arrays.toString(args));\n    }\n \n    //后置通知\n    @After(&quot;pointCut()&quot;)\n    public void afterAdviceMethod(JoinPoint joinPoint){\n        // System.out.println(&quot;LoggerAspect,后置通知&quot;);\n        //获取连接点所对应方法的签名信息\n        Signature signature = joinPoint.getSignature();\n        System.out.println(&quot;LoggerAspect，方法：&quot;+signature.getName()+&quot;，执行完毕&quot;);\n    }\n \n    //返回通知\n    /**\n     * 在返回通知中若要获取目标对象方法的返回值\n     * 只需要通过@AfterReturning注解的returning属性\n     * 就可以将通知方法的某个参数指定为接收目标对象方法的返回值的参数\n     */\n    @AfterReturning(value = &quot;pointCut()&quot;, returning = &quot;result&quot;)\n    public void afterReturningAdviceMethod(JoinPoint joinPoint, Object result){\n        // System.out.println(&quot;LoggerAspect,返回通知&quot;);\n        //获取连接点所对应方法的签名信息\n        Signature signature = joinPoint.getSignature();\n        System.out.println(&quot;LoggerAspect，方法：&quot;+signature.getName()+&quot;，结果：&quot;+result);\n    }\n \n      //异常通知\n    @AfterThrowing( &quot;pointCut()&quot;)\n    public void afterThrowingAdviceMethod(JoinPoint joinPoint){\n        //获取连接点所对应方法的签名信息\n        Signature signature = joinPoint.getSignature();\n        System.out.println(&quot;LoggerAspect，方法：&quot;+signature.getName()+&quot;,异常通知&quot;);\n    }\n \n    /**\n     * 在异常通知中若要获取目标对象方法的异常\n     * 只需要通过AfterThrowing注解的throwing属性\n     * 就可以将通知方法的某个参数指定为接收目标对象方法出现的异常的参数\n     */\n    @AfterThrowing(value = &quot;pointCut()&quot;, throwing = &quot;ex&quot;)\n    public void afterThrowingAdviceMethod(JoinPoint joinPoint, Throwable ex){\n        //获取连接点所对应方法的签名信息\n        Signature signature = joinPoint.getSignature();\n        System.out.println(&quot;LoggerAspect，方法：&quot;+signature.getName()+&quot;，异常：&quot;+ex);\n    }\n \n \n    //环绕通知\n    @Around(&quot;pointCut()&quot;)\n    //环绕通知的方法的返回值一定要和目标对象方法的返回值一致\n    public Object aroundAdviceMethod(ProceedingJoinPoint joinPoint){\n        Object result = null;\n        try {\n            System.out.println(&quot;环绕通知--&amp;gt;前置通知&quot;);\n            //表示目标对象方法的执行\n            result = joinPoint.proceed();\n            System.out.println(&quot;环绕通知--&amp;gt;返回通知&quot;);\n        } catch (Throwable throwable) {\n            throwable.printStackTrace();\n            System.out.println(&quot;环绕通知--&amp;gt;异常通知&quot;);\n        } finally {\n            System.out.println(&quot;环绕通知--&amp;gt;后置通知&quot;);\n        }\n        return result;\n    }\n}\n\n\nMyBean XML程序编写\n要求写出对应的增删改查的几种代码\n\n&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&amp;gt;\n&amp;lt;!DOCTYPE mapper\n        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;\n        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&amp;gt;\n&amp;lt;mapper namespace=&quot;com.jinzheng.dao.BookMapper&quot;&amp;gt;\n\n&amp;lt;!--    显示所有目录--&amp;gt;\n    &amp;lt;select id=&quot;findAll&quot; resultType=&quot;com.jinzheng.pojo.Book&quot;&amp;gt;\n        select * from tb_book\n    &amp;lt;/select&amp;gt;\n\n&amp;lt;!--    根据id查询图书信息 --&amp;gt;\n    &amp;lt;select id=&quot;findBookById&quot; parameterType=&quot;Integer&quot;\n            resultType=&quot;com.jinzheng.pojo.Book&quot;&amp;gt;\n        select *\n        from tb_book\n        where id=#{id}\n    &amp;lt;/select&amp;gt;\n\n&amp;lt;!--    添加数据--&amp;gt;\n    &amp;lt;insert id=&quot;addBook&quot; parameterType=&quot;com.jinzheng.pojo.Book&quot;&amp;gt;\n        insert into tb_book values (#{id},#{name},#{press},#{author},#{bookPrice})\n    &amp;lt;/insert&amp;gt;\n\n&amp;lt;!--        删除数据--&amp;gt;\n    &amp;lt;delete id=&quot;deleteById&quot; parameterType=&quot;Integer&quot;&amp;gt;\n        delete from tb_book where id = #{id}\n    &amp;lt;/delete&amp;gt;\n\n&amp;lt;!--    修改数据--&amp;gt;\n    &amp;lt;update id=&quot;updateBook&quot; parameterType=&quot;com.jinzheng.pojo.Book&quot;&amp;gt;\n        update tb_book\n        &amp;lt;set&amp;gt;\n            &amp;lt;if test=&quot;name != null and name != &#39;&#39; &quot;&amp;gt;\n                name = #{name},\n            &amp;lt;/if&amp;gt;\n            &amp;lt;if test=&quot;press != null and press != &#39;&#39; &quot;&amp;gt;\n                press = #{press},\n            &amp;lt;/if&amp;gt;\n            &amp;lt;if test=&quot;author != null and author != &#39;&#39; &quot;&amp;gt;\n                author = #{author},\n            &amp;lt;/if&amp;gt;\n            &amp;lt;if test=&quot;bookPrice != null and bookPrice != &#39;&#39; &quot;&amp;gt;\n                bookPrice = #{bookPrice},\n            &amp;lt;/if&amp;gt;\n\n        &amp;lt;/set&amp;gt;\n        where id = #{id}\n    &amp;lt;/update&amp;gt;\n\n&amp;lt;!--        根据图书信息去模糊查询图书信息(动态SQL)--&amp;gt;\n    &amp;lt;select id=&quot;queryList&quot; parameterType=&quot;com.jinzheng.pojo.Book&quot; resultType=&quot;com.jinzheng.pojo.Book&quot;&amp;gt;\n        select * from tb_book\n        &amp;lt;where&amp;gt;\n            &amp;lt;if test=&quot;id != null and id !=&#39;&#39; &quot;&amp;gt;\n                or id = #{id}\n            &amp;lt;/if&amp;gt;\n            &amp;lt;if test=&quot;name != null and name !=&#39;&#39; &quot;&amp;gt;\n                or name like concat(&#39;%&#39;,#{name},&#39;%&#39;)\n            &amp;lt;/if&amp;gt;\n            &amp;lt;if test=&quot;press != null and press !=&#39;&#39; &quot;&amp;gt;\n                or press like concat(&#39;%&#39;,#{press},&#39;%&#39;)\n            &amp;lt;/if&amp;gt;\n            &amp;lt;if test=&quot;author != null and author !=&#39;&#39; &quot;&amp;gt;\n                or author like concat(&#39;%&#39;,#{author},&#39;%&#39;)\n            &amp;lt;/if&amp;gt;\n            &amp;lt;if test=&quot;bookPrice != null and bookPrice !=&#39;&#39; &quot;&amp;gt;\n                or bookPrice = #{bookPrice}\n            &amp;lt;/if&amp;gt;\n        &amp;lt;/where&amp;gt;\n    &amp;lt;/select&amp;gt;\n\n&amp;lt;/mapper&amp;gt;\n\n\n"
} ,
  
  {
    "title"    : "服务器",
    "category" : "",
    "tags"     : " 服务器, 期末考试",
    "url"      : "/server",
    "date"     : "December 23, 2022",
    "excerpt"  : "  服务器指的是网络环境下为客户机(Client)提供某种服务的专用计算机，服务器安装有网络操作系统和各种服务器应用系统软件(如Web服务、电子邮件服务)的计算机。服务器具有高速的CPU运算能力、长时间的可靠运行、强大的I/O外部数据吞吐能力以及更好的扩展性。\n\n\n\n前言\n  《服务端技术原理与应用》是一门考察类课程，其课程本身难度不大，但是知识点比较多。希望你能好好准备，取得一个好成绩。\n\n\n\n知识点剖析\n\n小点\n\n  在Windows server中，新建的用户属于users组\n  系...",
  "content"  : "  服务器指的是网络环境下为客户机(Client)提供某种服务的专用计算机，服务器安装有网络操作系统和各种服务器应用系统软件(如Web服务、电子邮件服务)的计算机。服务器具有高速的CPU运算能力、长时间的可靠运行、强大的I/O外部数据吞吐能力以及更好的扩展性。\n\n\n\n前言\n  《服务端技术原理与应用》是一门考察类课程，其课程本身难度不大，但是知识点比较多。希望你能好好准备，取得一个好成绩。\n\n\n\n知识点剖析\n\n小点\n\n  在Windows server中，新建的用户属于users组\n  系统安装在NTFS盘中\n  ipconfig /release可以释放IP地址\n  权限以最低为准\n  每个人的最低权限都是只读权限\n\n\n\n\n1. 域名空间结构\n简单介绍\n  根域：代表域名命名空间的根，这里为空。\n\n  顶级域：直接处于根域下面的域，代表一种类型的组织或一些国家。在Internet中，顶级域由InterNIC（Internet Network Information Center）进行管理和维护。\n\n  二级域：在顶级域下面，用来标明顶级域以内的一个特定的组织。在Internet中，二级域也是由InterNIC负责管理和维护。\n\n  子域：在二级域的下面所创建的域，它一般由各个组织根据自己的需求与要求，自行创建和维护。\n\n  主机：是域名命名空间中的最下面一层，它被称之为完全合格的域名（Fully Qualified Domain Name，FQDN），例如www.sanxia.net.cn就是一个完全合格的域名。\n\n域名级别\n\n机构顶级域名：\n  com 商业机构，\n  gov 政府机构，\n  edu 教育机构，\n  int 国际组织，\n  mil 军事部门，\n  net 网络运行与服务中心\n  org 其他的非赢利机构\n\n地区顶级域名：\n  CN（中国）\n  hk （中国香港）\n  TW（中国台湾）\n  JP（日本）\n  RU（俄罗斯）\n  UK或GB（英国）\n\n\n\n2.Window Server 2016主要新增功能\n身份标识和访问权限\n  Window Server 2016的Active Directory域服务可以帮助组织保护Active Directory环境并为组织和个人设备提供更好的标识管理，并提供联合身份验证服务(AD FS) , AD FS对轻型目录访问协议(LDAP) 目录中存储的用户进行身份验证的新功能。\n\n系统管理性能\n  Window Server 2016提供了新安装选项: Nano Server。 Nano Server针对私有云和数据中心进行优化的远程管理的服务器操作系统。其所需磁盘空间小，启动速度快。Windows Server 2016引入了一种新的PackageManagement功能(以前称为OneGet)，该功能可以允许IT专业人员或开发人员使软件发现、安装、清单(SDIl)在本地或远程自动进行，无论安装程序技术为何，也不管软件位于何处。\n\n系统网络管理\n  Window Server 2016新增了软件定义的网络。与分布式防火墙和网络安全组联合使用，使你能够以类似于Azure的方式动态分段和保护工作负荷。其次，你可以使用System Center Virtual Machine\n\n  Manager部署并管理整个软件定义的网络(SDN)堆栈。最后，可以使用Docker来管理Windows Server 容器网络，并将SDN 策略与虚拟机和容器关联。在TCP性能改进方面，默认初始拥塞窗口(ICW) 已从4增加到10并已实现TCP快速打开(TFO)。\n\n系统数据存储\n  Windows Server 2016中的存储包括软件定义存储以及传统文件服务器的新功能和增强功能。存储空间直通允许通过使用具有本地存储的服务器构建高可用性和可缩放存储。存储副本可在各个服务器或群集之间实现存储不可知的块级同步复制，以便在站点间进行灾难恢复及故障转移群集扩展。\n\nweb应用程序开发\n  Windows Server 2016中的lIS 10.0 Web服务器提供的新增功能包括:\n\n  1. 在网络堆栈中支持HTTP/2协议，并与IIS10.0集成，允许IIS 10.0网站针对支持的配置为HTTP/2请求自动提供服务。\n\n  2. 在Nano Server 中运行和管理lIS 10.0的功能\n\n  3. 支持通配符主机头，使管理员能够为域设置Web 服务器，然后让Web服务器为任何子域的请求提供服务。\n一个用于管理IIS的新 PowerShell模块(1ISAdministration)。\n\n\n\n3.DHCP报文\n  DHCP服务器和客户端之间通过8种类型的报文进行通信。8种类型报文的格式相同，只是某些字段的取值不同。DHCP报文格式基于BOOTP的报文格式。它们是:\n\n1. DHCP DISCOVER:\n  这是DHCP客户端首次登录网络时进行DHCP过程的第一个报文，用来寻找DHCP服务器。\n\n2. DHCP OFFER:\n  DHCP服务器用来响应DHCP，DISCOVER报文，此报文携带了各种配置信息。\n\n3. DHCP REQUEST\n  此报文用于以下三种用途：\n\n  客户端初始化后，发送广播的DHCP REQUEST 报文来回应服务器的 DHCP OFFER 报文。\n\n  客户端重启初始化后，发送广播的 DHCP REQUEST 报文来确认先前被分配的IP地址等配置信息。\n\n  当客户端已经和某个IP地址绑定后，发送 DHCP REQUEST 报文来延长IP地址的租期。\n\n4. DHCP ACK:\n  服务器对客户端的DHCP REQUEST 报文的确认响应报文，客户端收到此报\n文后，才真正获得了IP地址和相关的配置信息。\n\n5. DHCP NAK:\n  服务器对客户端的DHCP REQUEST 报文的拒绝响应报文，比如服务器对客户\n\n  端分配的IP地址已超过使用租借期限（服务器没有找到相应的租约记录)或者由于某些原因无法正常分配IP地址，则发送 DHCP NAK报文作为应答（客户端移到了另一个新的网络)。\n\n  通知DHCP客户端无法分配合适IP地址。DHCP客户端需要重新发送\n\nDHCP DISCOVERY\n  报文来申请新的IP地址。\n\nDHCP DECLINE:\n  当客户端发现服务器分配给它的IP地址发生冲突时会通过发送此报文来通知服务器，并且会重新向服务器申请地址。\n\nDHCP RELEASE:\n  客户端可通过发送此报文主动释放服务器分配给它的IP地址，当服务器收到此报文后，可将这个IP地址分配给其它的客户端。\n\nDHCP INFORM:\n  客户端已经获得了IP地址，发送此报文的目的是为了从服务器获得其他的一些网络配置信息，比如网关地址、DNS服务器地址等，\n\n\n\n4.操作题（ip配置）\n\n  在DHCP服务器上创建一个IP地址作用域，它的名称为“office”，所包含的IP地址范围为：192.168.1.1～192.168.1.100，子网掩码为：255.255.255.0，需要排除的IP地址范围为：192.168.1.51～192.168.1.60，采用默认的租约期限，不用配置DHCP选项。\n\n操作步骤：\n  步骤1：单击【开始】→【程序】→【管理工具】→【DHCP】，打开“DHCP”管理控制台。\n\n  步骤2：右键单击这台计算机的名称，然后选择【新建作用域】 。\n\n  步骤3：当出现“欢迎使用新建作用域向导”时，单击【下一步】按钮。这时出现“作用域名”对话框。\n\n  步骤4：在“作用域名”对话框中，输入：“office”，然后单击【下一步】按钮。\n\n  步骤5：在“IP地址范围”对话框中的【起始IP地址】中输入：192.168.1.1、在【结束IP地址】中输入：192.168.1.100、在【子网掩码】中输入：255.255.255.0。单击【下一步】。\n\n  步骤6：在“添加排除”对话框中的【起始IP地址】中输入：192.168.1.51、在【结束IP地址】中输入： 192.168.1.60、然后单击【添加】按钮，再单击【下一步】按钮。\n\n  步骤7：在“配置DHCP选项”对话框中，选择【否，我想稍后配置这些选项】，单击【下一步】按钮。\n\n  步骤8：当出现“正在完成建立作用域向导”对话框时，单击【完成】按钮。\n\n5.DHCP地址分配类型\nDHCP允许有三种类型的地址分配如下:\n\n1.自动分配方式\n  当DHCP客户端第一次成功的从DHCP 服务器端租用到IP地址之后,就永远使用这个地址。\n\n2.动态分配方式\n  当DHCP第一次从 HDCP服务器端租用到IP地址之后，并非永久的使用该地址，只要租约到期，客户端就得释放这个IP地址，以给其它工作站使用。当然，客户端可以比其它主机更优先的更新租约，或是租用其它的IP地址。\n\n3.手工分配方式\n  DHCP客户端的IP地址是由网络管理员指定的,DHCP服务器只是把指定的IP地址告诉客户端。\n\n\n\n6.分布式文件系（DFS）的优点\n  DFS是将相同的文件同时存储到网络上多台服务器上后，就可以有以下功能和优点:\n\n1.访问文件更加容易\n  分布式文件系统使用户可以更容易地访问文件。共享文件可能在物理上跨越多个服务器,用户只需要转到网络上的一个位置即可访问文件。\n\n2.可用性\n  基于域的DFS命名空间以两种方法确保用户保持文件的访问，一是WindowsServer 20016自动将DFS拓扑发布到活动目录中，以确保DFS拓扑对域中所有服务器上的用户总是可见的;二是用户可以复制DFS根目录和DFS共享文件夹。复制意味着可以在域中的多个服务器上存储DFS根目录和DFS共享文件夹，即使这些文件驻留的一个物理服务器不可用，用户仍然可以访问此文件。\n\n3.服务器负载平衡\n  DFS根目录支持物理上分布在网络中的多个DFS共享文件夹。这一点很有用,例如，当用户将频繁访问某一文件时,并非所有的用户都在单个服务器上物理地访问此文件，这将会增加服务器的负担,DFS确保访问文件的用户分布于多个服务器。然而，在用户看来,文件驻留在网络上的相同位置。\n\n7.服务器的分类\n主DNS服务器\n  主域名服务器负责维护域中的域名服务信息，管理员需要配置正向解析文件、反向解析文件等相关信息，本身具有向客户机提供域名解析的功能。\n\n辅助DNS服务器\n  辅助域名服务器不需要配置正向解析与反向解析的数据库文件，辅助域名服务器的正向解析与反向解析数据库是从主域名服务器复制得来的。辅助域名服务器的作用是分担主域名服务器的查询负担，提供域名查询的稳定性和可靠性。\n\n转发DNS服务器\n  转发DNS服务器(Forwarder Name Server)可以向其他DNS转发解析请求。\n\n惟缓存DNS服务器\n  惟缓存DNS服务器不配置域名解析数据库文件，也不从主域名服务器同步其数据库信息。当本地DNS客户机有查询请求时，它会向某个远程DNS服务器转发查询请求。\n\n\n\n8.操作题（账户配置）\n\n在计算机上创建一个本地用户帐户，帐户名为“student”，密码为“12345”，并且允许用户在第一次登录时更改密码。\n\n操作步骤：\n\n步骤1：右键单击【我的电脑】→【管理】，然后在“计算机管理”对话框中的【本地用户和组】中右击【用户】，然后选择【新用户】 。\n\n步骤2：在“新用户”对话框中的【用户名】中输入【student】 ，在【密码】中输入：12345，在【确认密码】中再次输入：12345，然后选中用户【下次登录时须更改密码 】 。\n\n步骤3：单击【创建】按钮。\n\n\n\n9.如何在一台服务器上建立多个Web站点\n\n\n  使用不同的IP地址\n  使用不同的端口号\n  使用主机头\n\n\n10.概念考察总汇\n\n操作系统\n  操作系统位于底层硬件与用户之间，是两者沟通的桥梁。用户可以通过操作系统的用户界面，输入命令。\n\n动态磁盘\n  动态硬盘，即动态磁盘。动态硬盘是指在Windows操作系统的磁盘管理器中将本地硬盘升级得来的。\n\nDNS\n  即域名系统，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。\n\nVPN\n  VPN虚拟专用网络，利用公用网络架设专用网络活动目录。\n\n组策略\n  是管理员为用户和计算机定义并控制程序、网络资源及操作系统行为的主要工具。\n"
} ,
  
  {
    "title"    : "计算机组成原理",
    "category" : "",
    "tags"     : " 计算机组成原理, 期末考试",
    "url"      : "/computer",
    "date"     : "December 18, 2022",
    "excerpt"  : "计算机组成原理重点讲授计算机系统的硬件组成，及其主要功能子系统的基本原理和逻辑设计；主要内容包括计算机系统概述，数据的表示、运算与校验，CPU子系统，存储子系统，总线与I/O子系统，I/O设备及接口等。\n\n\n\n前言\n本博客针对《计算机组成原理》课程进行期末复习，其中复习形式以对真题的解答为主要方式。本门课程偏硬件，对于软件专业的可能需要花费更多的时间来攻克本门课程。希望你顺利通过本门考试。\n\n\n\n考题分析\n\n\n  \n    \n      题型\n      单项分数\n      题量\n   ...",
  "content"  : "计算机组成原理重点讲授计算机系统的硬件组成，及其主要功能子系统的基本原理和逻辑设计；主要内容包括计算机系统概述，数据的表示、运算与校验，CPU子系统，存储子系统，总线与I/O子系统，I/O设备及接口等。\n\n\n\n前言\n本博客针对《计算机组成原理》课程进行期末复习，其中复习形式以对真题的解答为主要方式。本门课程偏硬件，对于软件专业的可能需要花费更多的时间来攻克本门课程。希望你顺利通过本门考试。\n\n\n\n考题分析\n\n\n  \n    \n      题型\n      单项分数\n      题量\n      总分\n    \n  \n  \n    \n      选择\n      2\n      10\n      20\n    \n    \n      判断\n      1\n      10\n      10\n    \n    \n      简答\n      5\n      10\n      20\n    \n    \n      计算\n      10\n      3\n      30\n    \n    \n      综合\n      15\n      2\n      30\n    \n  \n\n\n\n\n选择题\n\n1. 两个数\\(9F5 H\\)和\\(513 H\\)相加，得( C ).\n\n\n  后缀H表示16进制，其表示方式\\(9F5 H\\)等价于\\((9F5)_{16}\\)\n\n\n  A: BDBH\n  B: CD8H\n  C: F08H\n  D: CC8H\n\n2. ( D )表示法主要用于表示浮点数中的阶码。\n\n  A: 原码\n  B: 补码\n  C: 反码\n  D: 移码\n\n3. 存储字长是( C )\n\n  存储字长是位数，大小才是个数\n\n\n  A: 存储单元的个数\n  B: 机器指令的位数\n  C: 存放在一个存储单元之后的二进制代码位数\n  D: 机器字长\n\n4. 若[x]补 = 1.10001100，则[x]原=( B )。\n\n  这里的第一位表示符号位不是小数点\n原码 = 补码按位取反后 + 1\n\n\n  A: 1.0010101\n  B: 1.01110100\n  C: 0.0010110\n  D: 0.1101010\n\n5. 若CPU的地址线为A0~A15，某芯片存储单元有8K，则加在该存储器芯片上的地址线为( C )。\n\n  1k 表示 \\(2^{10}\\) 所以可以推算出 8k 表示 \\(2^{13}\\) 所以总线占据13位\n\n\n  A: A0~A10\n  B: A0~A11\n  C: A0~A12\n  D: A0~A13\n\n6. 冯.诺依曼机工作方式的基本特点是( B )。\n\n  A: 多指令流单数据流\n  B: 按地址访问并顺序执行指令\n  C: 堆栈操作\n  D: 存储器按内容选择地址\n\n7. 某一RAM 芯片，其容为1024*8位，其数据线和地延线分别为( C )。\n\n  1024 表示地址线 \\(2^{10}\\) 共10位，数据线为8位\n\n\n  A: 3、10\n  B: 10、3\n  C: 8、10\n  D: 10、8\n\n8. Cache的地址映射中，若主存中的任意一块均可映射到Cache内的任意一块的位置上，称( B )。\n\n  直接映射表示：取模映射，每一个块只能映射到模数固定的位置上。\n全相联映射：如题意。\n组相联映射：组间直接映射，组内全映射\n\n\n  A: 直接映射\n  B: 全相联映射\n  C: 组相联映射\n  D: 以上全是\n\n9. 某机字长8位，来用补码形式，则机疑数能表示的范国是( C )。\n\n  左闭右开\n\n\n  A: -127~+127\n  B: -128~+128\n  C: -128~+127\n  D: -127~+128\n\n10. 计算机操作的最小单位时间是( A )。\n\n  A: 时钟周期\n  B: 机器周期\n  C: CPU周期\n  D: 指令周期\n\n\n\n判断题\n\n11．超前进位不要考虑前一位来的进位。（✔）\n12. 在补码的加减法中，用两位符号位判断溢出,两位符号位组合为10时，表示结果正溢。（✖）\n\n  00\t结果为正，无溢出 \n01\t正溢，（大于机器所能表示的最大正数）\n10\t负溢，（小于机器所能表示的最小负数）\n11\t结果为负，无溢出\n\n\n13. NAND闪存更适用作为U盘。 （✔）\n14. 在程序的执行过程中，Cache与主存的地址映射是由操作系统来管理的。 (✖)\n\n  此处应该把操作系统换成硬件\n\n\n15．存取时间比存取周期花费的时间要长一些。 (✖)\n\n  存取周期包括了存储时间，所以存储周期时间要更长\n\n\n16. 浮点数的正负由阶码的正负符号决定。 (✖)\n\n  正负由符号位决定\n\n\n17. NOR闪存更适用作为程序存储器。 (✖)\n\n18. \\(E^2PROM\\) 是带电可擦可编程的只读存储。 (✔)\n19．硬件实现的功能一般比款件实现具有更尚的执行速度。 (✔)\n20. 动态存储DRAM的刷新是以列为单位的。 (✖)\n\n  应该以行为单位\n\n\n\n\n简答题\n21. 任意写出五种指令寻址方式。\n\n  1. 隐含寻址\n  2. 立即寻址\n  3. 直接寻址\n  4. 间接寻址\n  5. 寄存器寻址\n  6. 寄存器间接寻址\n  7. 偏移寻址\n  8. 堆栈寻址\n\n22．写出 NOR和NAND型Flash闪存各自的优缺点\n  NOR可靠性高，适用于擦除次数和编程操作较少，而直接执行代码的场合。\n  NAND存储速度快，闪存有10倍于NOR闪存的可擦除次数，适用于大容量存储设备。\n\n\n\n计算题\n23. 二进制计算\n\n  指数 = 阶码 - 127\n\n  IEEE754标准: 1位符号位 + 8位阶码 + 23位尾数\n\n\n(1)设浮点数的阶码和尾数部分均用二进制补码表示，按照浮点数的运算规则计算X+Y:\\(X=2^{-101}*0.101100，Y=2^{-100}*(-0.101000)\\)\n\n  [x]浮=1011;0.101100，[y]浮=1100;1.011000\n\n  对阶:小阶向大阶看齐。\n\n  △E=EA-EB=-1\n\n  [x]浮’=1100;0.010110\n\n  尾数相加：00.010110+11.011000=11.101110\n\n  需左规一次\n\n  [x+y]浮=1011；1.011100\n\n  X+Y=2-101*（-0.100100）\n\n（2）将十进制数10.375表示成单精度的IEEE754标准规定的32位短浮点数（结呆以十六进制形式给出)。\n\n将整数部分和小数部分整理成二进制可以得到：\n\n  \\(10.375=(1010.011)_2\\)\n\n移动小数点，使其位于第一二位之间：\n\n  \\(1010.011=1.010011 X 2^3\\)\n\n可以得到：\n\n  \\(S=0 E=3+127=130 M=010011\\)\n\n所以有二进制的IEEE754标准表达式：\n\n  \\(01000001 00100110 00000000 00000000\\)\n\n最终得到16进制的IEEE754标准表达式：\n\n  \\((41260000)_{16}\\)\n\n24．设主存容量为256K字，Cache容量为2K字，块长为256字，存储器按字寻址。\n\n  块数 = 容量 / 块长\n\n  直接映射标志位 = s - r\n全相联映射标志位 = s\nw = log(块大小)，r = log(Cache行数)，s = log(主存块数) - w\n\n\n1)在直接映射方式下,设计主存地址格式并求标志位的位数;\n\n  \\(块大小 = 256 = 2^8 = 2^w 字节\\)\n  \\(所以w=8位\\)\n\n  \\(主存寻址单元数 = 256K = 2^{18} = 2^{s+w}\\)\n  \\(所以s = 18-8 = 10 位\\)\n\n  \\(Cache的行大小=2K/256=2^2=2^r\\)\n  \\(所以r=2 位，标记位位数=s-r=10-2=8位\\)\n\n综上所述：\n\n\n  \n    \n      标记s-r\n      行r\n      字地址w\n    \n  \n  \n    \n      8位\n      2位\n      8位\n    \n  \n\n\n标记位的位数是8位\n\n2)在全相联映射方式下，设计主存地址格式并求标志位的位数。\n  \\(块大小 = 256 = 2^8 = 2^w 字节\\)\n  \\(所以w=8位\\)\n\n  \\(主存寻址单元数 = 256K = 2^{18} = 2^{s+w}\\)\n  \\(所以s = 18-8 = 10 位\\)\n\n综上所述\n\n\n  \n    \n      标记s\n      字地址w\n    \n  \n  \n    \n      10位\n      8位\n    \n  \n\n\n标记位的位数是10位\n\n\n\n综合题\n\n25．用8K*2位的SRAM芯片组成32K*8位的存储器。试问:\n\n1)地址寄存器多少位?(5分)\n\n  字大小 = 32K = 2^15\n  所以需要15位\n\n2)共需要多少片SRAM?(5分)\n\n由题意可得\n  新组成的存储器，需要4倍的字扩容、4倍的位扩容才能得到\n  所以：需要\\(4*4 = 16\\)片\n\n3)画出此存储器的组成简要框图。(5分)\n\n\n    \n    \n        \n    \n    \n\n\n26. 作图（微指令与微操作）\n\n\n    \n    \n        \n    \n    \n\n\n参见图1的数据通路,画出取数指令“LDA(R3),RO的指令周期流程图,其含义是将(R3)为地址数存单元的内容取至寄存器RO中，画出方框图并标出各微操作信号序列。\n\n  输入可以不用画\n\n  在下图中，包括菱形在内的上面部分是取指，不包括菱形的下部分是执行\n\n\n\n    \n    \n        \n    \n    \n\n\n"
} ,
  
  {
    "title"    : "马克思主义原理",
    "category" : "",
    "tags"     : " 马克思主义基本原理, 期末考试",
    "url"      : "/marxism",
    "date"     : "December 17, 2022",
    "excerpt"  : "马克思主义基本原理是指马克思主义政治经济学、辩证唯物主义和历史唯物主义以及科学社会主义。它是马克思主义科学体系的基本理论、基本范畴，是其立场、观点和方法的理论表达。\n\n\n\n前言\n本篇博客为对马原课程的期末复习整理，主要是针对68个知识点来整理的，内容较多。祝愿你可以在考试中拿下一个好成绩！\n\n\n\n考试题型\n\n\n  \n    \n      题型\n      题量\n      分值（题/分）\n      总分\n    \n  \n  \n    \n      单选\n      20\n      1\n...",
  "content"  : "马克思主义基本原理是指马克思主义政治经济学、辩证唯物主义和历史唯物主义以及科学社会主义。它是马克思主义科学体系的基本理论、基本范畴，是其立场、观点和方法的理论表达。\n\n\n\n前言\n本篇博客为对马原课程的期末复习整理，主要是针对68个知识点来整理的，内容较多。祝愿你可以在考试中拿下一个好成绩！\n\n\n\n考试题型\n\n\n  \n    \n      题型\n      题量\n      分值（题/分）\n      总分\n    \n  \n  \n    \n      单选\n      20\n      1\n      20\n    \n    \n      多选\n      10\n      2\n      20\n    \n    \n      简答\n      2\n      5\n      10\n    \n    \n      论述\n      2\n      10\n      20\n    \n    \n      分析\n      2\n      15\n      30\n    \n    \n      合计\n      36\n       \n      100\n    \n  \n\n\n\n考题分析\n\n\n\n导论\n1.马克思主义的三个基本组成部分及其理论来源（P2、P5）\n  三个基本组成部分：马克思主义哲学、马克思主义政治经济学和科学社会主义。\n  理论来源：德国古典哲学、英国古典政治经济学、英法两国的空想社会主义。\n\n2.马克思主义产生的社会根源、阶级基础和思想渊源（P4-5）（待确定）\n  社会根源：资本主义生产方式的发展。\n  阶级基础：无产阶级斗争对科学理论的需求。 \n  思想渊源：19世纪西欧三大先进思潮。细胞学说，能量守恒与转化定律，生物进化论，为马克思主义的产生提供了自然科学前提。\n\n3.马克思主义公开问世的标志（P6）\n  《共产党宣言》的发表。\n\n4.《反杜林论》（P7）\n  恩格斯写出了《反杜林论》。全面阐述了马克思主义理论体系。\n\n5.马克思主义的鲜明特征（P10-11）\n  科学性，人民性，实践性，发展性。\n\n6.马克思主义的当代价值（P12-15）（多选）\n  观察当代世界变化的认识工具\n  指引当代中国发展的行动指南\n  引领人类社会进步的科学真理。\n\n7.自觉学习和运用马克思主义（P17-18）\n  努力学习和掌握马克思主义的基本立场观点方法。\n  努力学习和掌握马克思主义中国化的理论成果。\n  坚持理论联系实际的马克思主义学风。\n  自觉将马克思主义内化于心外化于行。\n\n\n\n第一章\n8.哲学的基本问题（P21）\n  哲学的基本问题主要包括两方面内容。一是存在和思维，物质和意识谁为本源的问题，即何者为第一性的问题，对于这一问题的不同回答形成了唯物主义和唯心主义两种根本对立的哲学派别，二是存在和思维，物质和意识是否具有同一性的问题，即思维能否正确的反映存在人能否认识或彻底认识世界的问题，对这一问题的不同回答，产生了可知论和不可知论的理论分野\n\n9.意识的本质（P26）\n  意识是人脑这样一种特殊物质的机能和属性，是客观世界的主观映象。\n\n10.主观能动和客观规律性的辩证统一（P27）\n  一方面尊重客观规律是正确发挥主观能动性的前提。\n  另一方面只有充分发挥主观能动性，才能正确认识和利用客观规律。\n\n11.联系的含义及特点（P32）\n  联系是指事物内部各要素之间和事物之间互相影响，互相制约，互相作用的关系。\n  联系具有客观性，普遍性、多样性、条件性。\n\n12.发展的实质（P33）\n  新事物的产生和旧事物的灭亡。\n\n13.矛盾的同一性和斗争性原理及其方法论要求（P35-36）\n\n  本知识点考查大题目\n\n\n方法论原理：\n  矛盾的同一性是指矛盾着的对立面，互相依存，互相贯通的性质和趋势，有两个方面的含义\n  一是矛盾着的对立面，相互依存互为存在的前提并共处于一个统一个体中。\n  二是矛盾着的对立面，互相贯通，在一定条件下可以互相转化。矛盾的斗争性是矛盾着的，对立面互相排斥，互相分离的性质和趋势。\n\n方法论要求：\n  矛盾的统一性和斗争性的辩证关系原理，要求我们在观察和处理问题时，必须善于把两者结合起来，既要看到矛盾双方的对立，又要看到矛盾双方的统一，在斗争中把握同一性，在同一性中把握斗争性。\n\n14.矛盾的普遍性和特殊性的辩证关系原理及其方法论要求（P37）\n\n  本知识点考查大题目\n\n\n方法论原理：\n  矛盾的普遍性和特殊性是辩证统一的关系，矛盾的普遍性，即矛盾的共性，矛盾的特殊性，即矛盾的个性。 \n  二者相互区别矛盾的共性是无条件的，绝对的矛盾的，个性是有条件的，相对的\n  二者相互区别任何存在的事物都是共性和个性的有机统一，共性寓于个性之中，没有离开个性的共性，也没有离开共性的个性\n  二者在一定条件下相互转化\n  方法论要求我们坚持个性与共性相结合的分析方法\n\n方法论要求：\n  矛盾同一性和斗争性的辩证关系原理要求，我们在观察和处理问题时，必须善于把两者结合起来，在斗争性中把握同一性，在同一性中把握斗争性，既要看到矛盾双方的对立，又要看到矛盾双方的统一。\n\n15.量变质变规律及其方法论要求（P38）\n\n  本知识点考查大题目\n\n\n方法论原理：\n  第一量变是质变的必要准备；\n  第二质变是量变的必然结果；\n  第三量变和质变是相互渗透的；\n\n方法论要求：\n  一方面当事物的发展处在量变阶段时，要踏踏实实做好日常工作，为未来重大改变做准备。\n  另一方面当质变来临的时候要果断的不失时机的抓住机遇，促成质变，使工作迈上新台阶。\n\n16.辩证的否定观及其方法论要求（P39）\n\n  本知识点考查大题目\n\n\n方法论原理：\n  第一否定是事物自我否定；\n  第二否定是事物发展的环节；\n  第三否定是新旧事物联系的环节；\n  第四辩证否定的实质是扬弃。\n\n方法论要求：\n  按照否定之父定规律办事，就要求我们树立辩证的否定观，反对形而上学的肯定一切或否定一切，要对事物采取科学分析的态度，使实践活动符合事物自我否定的辩证本性，同时又要求我们正确看待事物发展的过程，既要看到道路的曲折，又要看到前途的光明。\n\n17.原因与结果（P41）\n  原因与结果是揭示事物引起和被引起关系的一对范畴，在事物的普遍联系中，引起某种现象的现象就是原因，被某种现象所引起的现象就是结果。\n\n18.辩证思维能力（P50）\n\n  本知识点考查大题目\n\n\n  提高辩证思维能力，要求我们客观地而不是主观地联系地，而不是孤立地发展地，而不是静止的全面地而不是片面地系统地而不是零散地观察事物，把握事物的本质和发展规律，找到解决问题的方法和途径。\n  以问题为向导，善于正确分析矛盾，在对立中把握统一在统一中把握对立，克服极端化，片面化，善于运用辩证思维谋划事业发展。\n\n\n\n第二章\n19.实践的基本特征（P62-63）\n  实践具有客观实在性、自觉能动性、社会历史性。\n\n20.实践对认识的决定作用（P67-68）\n\n  本知识点考查论述题\n\n\n实践是认识的来源；\n  实践是认识发展的动力；\n  实践是认识的目的；\n  实践是检验认识真理的唯一标准。\n\n21.两条根本对立的认识路线（P69）\n\n  本知识点考查大题目\n\n\n  在认识的本质问题上，存在着两条根本对立的认识路线：\n  一条是坚持从物到感觉和思想的唯物主义认识路线。\n  另一条是坚持从思想和感觉到物的唯心主义认识路线。\n\n22.认识的本质（P71）\n  在认识的本质问题上，存在着两条根本对立的认识路线：\n  一条是坚持从物到感觉和思想的唯物主义认识路线；\n  另一条是坚持从思想和感觉到物的唯心主义认识路线。\n\n23.感性认识和理性认识的辩证统一关系（P74）\n\n  本知识点考查论述题\n\n\n  第一理性认识依赖于感性认识；\n  第二感性认识有待于发展和深化为理性认识；\n  第三感性认识和理性认识相互渗透相互包含\n  第四毛泽东说。我们的实践证明，感觉到了的东西，我们不能立刻理解它，只有理解了的东西才更深刻的感觉它。这段话形象的说明了感性认识上升为理性认识的重要性以及二者关系的交融性\n\n24.实践与认识的辩证运动规律（P77）\n\n  本知识点考查大题目\n\n\n  实践与认识的辩证运动是由一个感性认识到理性认识，又有理性认识，到实践的飞跃是实践认识再实践，再认识循环往复以至无穷的辩证发展过程。\n\n25.真理的一元性（P81）\n  真理的一元性是指在同一条件下，对于特定的认识客体的真理性认识只有一个，而不可能有多个\n\n26.真理的绝对性和相对性的含义（P81-82）\n  真理的绝对性真理的绝对性是指真理主客观统一的确定性和发展的无限性；\n  真理的相对性真理的相对性是指人们在一定条件下对客观事物及其本质和发展规律的正确认识总是有限度的，不完善的；\n\n27.真理与谬误的辩证关系（P85）\n\n  本知识点考查简答题\n\n\n  第一，真理与谬误相互对立；\n  第二，真理与谬误的对立又是相对的，它们在一定条件下能够相互转化。\n\n28.实践是检验真理的唯一标准（P87）\n  实践之所以能够作为检验真理的唯一标准，是由真理的本性和实践的特点决定的。\n\n29.价值的基本特性（P91-92）\n  第一，价值的主体性，价值的主体性是指价值直接与主体相联系，始终以主体为中心；\n  第二，价值的客观性，价值的客观性是指在一定条件下客体对于主体的意义不依赖于主体的主观意识而存在；\n  第三，价值的多维性，价值的多维性是指每个主体的价值，关系具有多样性，同一客体相对于主体的不同需要与会产生不同的价值；\n  第四，价值的社会历史性，主体和客体的不断变化决定了价值的社会历史性\n\n30.价值评价的特点（P92-94）\n\n  本知识点考查简答题\n\n\n  第一，评价与主客体的价值关系为认识对象；\n  第二，评价结果与评价主体直接相关；\n  第三，评价结果的正确与否依赖于客体状态和主体需要的认识；\n  第四，价值评价有科学与非科学之别。\n\n31.真理与价值在实践中的辩证统一（P95-96）\n  人们的实践活动总是受着真理尺度和价值尺度的制约。\n  任何实践活动都是在这两种尺度共同制约下进行的，任何成功的实践都是真理尺度和价值尺度的统一，是合规律性和合目的性的统一。\n  一方面价值尺度必须以真理为前提。\n  另一方面人类自身需要的内在尺度推动着人们不断发现新的真理。\n\n32.理论创新和实践创新的良性互动（P106-107）\n  实践创新为理论创新提供不竭的动力源泉；\n  理论创新为实践创新提供科学的行动指南；\n  努力实现理论创新与实践创新的良性互动。\n\n\n\n第三章\n33.自然地理环境在人类社会生存和发展中的重要作用（P112）\n  自然地理环境是指人类社会所处的地理位置相联系的自然条件的总和，是人类社会生存和发展永恒的必要的条件，是人们生活和生产的自然基础。\n\n34.物质生产方式（P113）\n  物质的生产方式是社会存在和发展的基础及决定力量。\n\n35.社会存在和社会意识的辩证关系（P116）\n\n  本知识点考查简答题（有待补充）\n\n\n  社会存在和社会意识是辩证统一的，社会存在决定社会意识，社会意识是社会存在的反映，并反作用于社会存在\n\n36.社会意识对社会存在具有能动的反作用（P117）\n  社会意识对社会存在具有能动的反作用，这是社会意识相对独立性的突出表现。\n\n37.生产力（P121）\n  劳动者是生产力中最活跃的因素\n\n38.经济基础与上层建筑的辩证关系（P127）\n  经济基础与上层建筑是辩证统一的，经济基础决定上层建筑，上层建筑反作用于经济基础，二者相互影响相互作用。\n\n39.社会形态更替的一般规律及特殊形式（P133-136）\n  社会形态的内涵；\n  社会形态更替的统一性和多样性\n  社会形态更替的必然性与人们的历史选择性；\n  社会形态更替的前进性和曲折性。\n\n40.社会革命在社会发展中的重要作用（P148）\n  革命对社会发展起巨大作用，“革命是历史的火车头”，是社会进步和政治进步的强大推动力。社会革命是实现社会形态根体的重要手段和决定性环节。\n\n41.改革在社会历史发展中的重要作用（P149）\n  在一定社会形态总的量变过程中，当社会基本矛盾发展到一定程度带有尚未激化到引起社会革命的程度时，就需要依靠改革的途径或手段来改变与生产力不相适应的生产关系和与经济基础不相适应的上层建筑。\n\n42.科学技术在社会发展中的作用（P151-153）\n\n  本知识点考查大题目\n\n\n  积极作用：每一次科技革命都不同程度地引起了生产方式，生活方式和思维方式的深刻变化和社会的巨大进步。首先对生产方式产生了深刻影响，其次对于生活方式产生了巨大影响，最后促进了思维方式的变革。\n\n  消极作用：例如工业的发展带来水和空气的污染，大规模的开垦和过度放牧，造成森林和草原的生态破坏。生命科学的发展提出了涉及人自身尊严，健康，遗传以及生态安全和环境保护等方面的伦理问题，基因工程可能导致基因歧视转基因食品的安全性和基因治疗克隆技术的适用范围等问题引起了人们高度关注。互联网可以迅速广泛的传播大量有用的信息，但也存在大量垃圾信息和虚假信息，并可能侵害国家安全，企业经营秘密以及个人隐私。\n\n  方法论要求：正确认识和运用科学技术：一，充分发挥其积极作用，努力创造条件，将消极作用转化为积极作用。二首要的就是有合理的社会制度，保障科学技术的正确运用，始终坚持使科学技术为人类社会的健康发展服务，让科学技术为人类造福\n\n43.两种历史观在历史创造者问题上的对立（P153）\n  唯物史观与唯心史观的对立，在历史创造者问题上表现为群众史观与英雄史观的对立。\n\n44.人民群众在创造历史过程中的决定作用（P157）\n  人民群众是社会物质财富的创造者，人民群众是社会精神财富的创造者，人民群众是社会改革的决定力量。\n\n45.群众路线（P159）\n  一切为了群众，一切依靠群众，从群众中来到群众中去。\n\n\n\n第四章\n46.商品及其二因素（P169-170）\n  商品是用来交换能满足人的某种需要的劳动产品，具有使用价值和价值两因素或两种属性。\n  价值是商品所持有的社会属性。\n\n47.商品价值量的决定（P171）\n  决定商品价值量的不是生产商品的个别劳动时间，而是社会必要劳动时间。\n\n48.价值规律的表现形式（P174）\n  商品经济中价值规律的表现形式是商品的价格围绕商品的价值自发的波动。\n\n49.资本原始积累的两个途径（P186）\n  一是用暴力手段剥夺农民的土地，二是用暴力手段掠夺货币财富。\n\n50.资本主义生产过程的两重性（P192）\n  资本主义生产过程具有二重性：\n  一方面生产物质资料的劳动过程；\n  另一方面是生产剩余价值的过程及价值增值过程。\n\n51.剩余价值的含义（P193）\n  剩余价值是雇佣工人所创造的，并被资本家无偿占有的，超过劳动力价值的那部分价值，他是雇佣工人劳动价值的凝结。\n\n52.资本主义的基本矛盾（P206）\n  生产社会化和生产资料资本主义私人占有之间的矛盾，是资本主义的基本矛盾。\n\n\n\n第五章\n53.资本主义发展的客观规律（P220）\n  自由竞争引起生产集中和资本集中生产集中和资本集中发展到一定阶段必然引起垄断，这是资本主义发展的客观规律。\n\n54.金融寡头对国家机器的控制（P223）\n  金融寡头对国家机器的控制主要是通过同政府的“个人联合”来实现的。\n\n55.垄断价格（P224）\n  垄断价格，包括垄断高价和垄断低价两种形式。\n\n56.国家垄断资本主义的含义（P225）\n  国家垄断资本主义是国家政权和私人垄断资本联合在一起的垄断资本主义。\n\n57.金融垄断资本得以形成和壮大的重要制度条件（P229）\n  金融自由化与金融创新是金融垄断资本得以形成和壮大的重要制度条件。\n\n58.经济全球化的表现（P235）\n  生产全球化，贸易全球化，金融全球化。\n\n59.第二次世界大战后，居主导地位的资本所有制形式（P240）\n  法人资本所有制崛起并成为居主导地位的资本所有制形式。\n\n60.第二次世界大战后资本主义发生变化的根本推动力量（P244）\n  科学技术革命和生产力的发展，是资本主义发生变化的根本推动力量\n\n\n\n第六章\n61.空想社会主义发展到高级阶段的三个代表人物（P259）\n  法国的圣西门、傅立叶和英国的欧文。\n\n62.社会主义从理想到现实的伟大飞跃（P265）\n  十月革命实现了社会主义从理想到现实的伟大飞跃。\n\n63.无产阶级是最先进最革命的阶级（P274）\n  无产阶级是最先进最革命的阶级，肩负着推翻资本主义旧世界、建立社会主义和共产主义新世界的历史使命。\n\n64.探索适合本国国情的发展道路（P290-291）\n  第一，探索社会主义发展道路，必须坚持对待马克思主义的科学态度。\n  第二，探索社会主义发展道路，必须坚持从当时当地的社会历史条件出发，坚持“走自己的路”。\n  第三，探索社会主义发展道路，必须充分吸收人类的一切文明成果。\n  发展社会主义不能照搬苏联社会主义的模式，照搬别国模式，从来不能成功，这是一个被历史反复证明了的颠扑不破的真理。\n\n\n\n第七章\n65.预见未来社会的方法论原则（P300-303）（多选）\n  在揭示人类社会发展一般规律的基础上指明社会发展的方向。\n  在剖析资本主义旧世界的过程中阐发未来新世界的特点。\n  在社会主义社会发展中不断深化对未来共产主义社会的认识。\n  立足于揭示未来社会的一般规律，而不对各种细节做具体描绘。\n\n66.共产主义社会个人消费品的分配方式（P306）\n  在共产主义社会，个人消费品的分配方式是“各尽所能，按需分配”。\n\n67.马克思主义追求的根本价值目标（P309）\n  实现人的自由而全面的发展是马克思主义追求的根本，价值目标也是共产主义社会的根本特征。\n\n68.实现共产主义是历史发展的必然（P312-313）\n  共产主义理想作为一种社会理想，是对人类社会发展规律认识的基础上，设想的社会目标。\n  遗产主义理想是一定会实现的，是以前的社会发展规律以及资本主义社会的基本矛盾发展为依据的。\n  社会主义运动的实践，特别是社会主义国家的兴起和不断发展已经并正在用事实证明共产主义理想实现的必然性。\n"
} ,
  
  {
    "title"    : "机器学习",
    "category" : "",
    "tags"     : " 机器学习, 期末考试, python",
    "url"      : "/machinelearning",
    "date"     : "December 9, 2022",
    "excerpt"  : "今天的人工智能主要依赖的不再是符号知识表示和程序推理机制，现代 AI 而是建立在新的基础上，即机器学习。无论是传统的基于数学的机器学习模型或决策树，还是深度学习的神经网络架构，当今人工智能领域的大多数 AI 应用程序都是基于机器学习技术。\n\n\n\n前言\n机器学习是智能专业的专核心课，其科目本身的难度较高，不论是在于理论层面还是代码实现层面都有一定的难度。想要征服机器学习还是一件非常具有挑战性的事情。\n\n本次博客整理了有关机器学习课程的期末考试重点，希望同学们可以获得一个好成绩。\n\n\n\n问题一...",
  "content"  : "今天的人工智能主要依赖的不再是符号知识表示和程序推理机制，现代 AI 而是建立在新的基础上，即机器学习。无论是传统的基于数学的机器学习模型或决策树，还是深度学习的神经网络架构，当今人工智能领域的大多数 AI 应用程序都是基于机器学习技术。\n\n\n\n前言\n机器学习是智能专业的专核心课，其科目本身的难度较高，不论是在于理论层面还是代码实现层面都有一定的难度。想要征服机器学习还是一件非常具有挑战性的事情。\n\n本次博客整理了有关机器学习课程的期末考试重点，希望同学们可以获得一个好成绩。\n\n\n\n问题一：有关拟合的问题\n什么是过拟合和欠拟合？\n\n过拟合是指模型在训练集上表现很好，到了验证和测试阶段就很差，即模型的泛化能力很差。\n欠拟合是指模型在训练集上表现的不好，以至于在验证和测试阶段表现的也比较差。\n\n如何解决过拟合与欠拟合？\n过拟合的解决方法：\n\n  重新调整一下参数和超参数。\n  对数据进行特征降维处理，有选择性的抛弃一些特征。\n  降低模型的复杂度。\n  使用正则化约束。\n\n\n欠拟合的解决方法：\n\n  增加模型的复杂度，例如使用神经网络代替线性回归、用随机森林代替决策树。\n  考虑选用更多更具有代表意义的特征的数据特征。\n  重新调整一下参数和超参数。\n  降低正则化约束。\n\n\n决策树如何防止过拟合\n剪枝。\n\n\n问题二：回归模型与分类模型的区别是什么？请举例说明。\n\n回归模型：是对连续变量，进行预测的模型，即回归问题是定量问题。\n回归模型问题的举例：对某城市房价预测、对某地区空气湿度的预测。\n\n分类模型：是对离散变量、进行预测的模型，即分类问题是定类问题。\n分类模型问题的举例：对明天是否下雨的预测、判断病人是否患有某种疾病的预测。\n\n\n问题三：机器学习的四大问题是什么？\n回归、分类、聚类、降维。\n\n\n问题四：机器学习的一般步骤。（需要以某一实物为例）\n回归问题以披萨价格预测为例。\n明确任务收集数据。\n在一定范围内的各个城市中随机选取若干家披萨店，作为初始数据。\n数据分析与预处理。\n将数据特征初步定为以下几项：\n\n比萨的尺寸、披萨的脂肪含量、披萨的制作成本、披萨的口味、披萨的品牌、披萨所在城市的GDP水平、生产披萨的披萨店的知名度。\n\n分析这些特征是否出现缺失值，对缺失值较多的特征直接删除。对缺失值较少的使用平均值填补定量的特征（例如披萨的脂肪含量），使用众数填补定类的特征（例如披萨的口味）。\n\n将定类数据数值化，方便后期计算。\n\n使用灰色关联分析法有选择性地剔除关联度较小的几个特征，即进行降维与特征选择处理。\n\n模型训练\n\n选择使用线性回归解决该回归问题。\n\n模型评估与参数调优\n\nR2评估，模型的优劣，当R2的值越接近1时模型性能越好。\n使用k折交叉验证方法选取出最佳的学习率等参数并再次进行模型训练。\n\n模型应用\n\n将训练模型保存下来，并公布用以推广。\n\n分类问题以肿瘤预测为例。\n明确任务收集数据。\n随机选取若干家医院的肿瘤病人数据作为初始数据\n\n数据分析与预处理。\n\n将数据特征初步定为以下几项：\n肿瘤的直径、体积、颜色、数量、肿瘤是否为良性、病人体温、病人是否出现炎症等信息。\n\n将肿瘤是否为良性作为目标列作为输出项并做数值化处理。\n\n分析这些特征是否出现缺失值，对缺失值较多的特征直接删除。对缺失值较少的使用平均值填补定量的特征（例如肿瘤的直径），使用众数填补定类的特征（例如病人是否出现炎症）。\n\n使用灰色关联分析法有选择性地剔除关联度较小的几个特征，即进行降维与特征选择处理。\n\n模型训练\n\n选择使用逻辑回归解决该分类问题。\n\n模型评估与参数调优\n\n使用AUC值评估模型的优劣，当R2的值越接近1时模型性能越好。\n使用k折交叉验证方法选取出最佳的激活函数的阈值等参数并再次进行模型训练。\n\n模型应用\n\n将训练模型保存下来，并公布用以推广。\n\n\n\n问题五：k折交叉验证的简述。\n\nk折交叉验证常用于参数调优，使得更容易训练出较高性能的模型。\n\nk折交叉验证的工作流程：\n\n  将训练集随机地进行k块、并选出其中1块作为验证集。\n  用其余k-1块的数据进行训练，并用验证集，计算出这一次的误差。\n  重复k次以上步骤，每次选取不同的块作为验证集\n  统计每一次计算得到的误差估计，并取平均值作为本次训练参数的最终指标。\n\n\n\n\n问题六：模型的评估标准\n回归问题的评估标准\n\n  MSE（均方误差） 预测残差的平方和，数值越小越好。\n  RMSE（平均绝对误差）是在MSE的基础上开根号计算得到，同样数值越小越好。\n  MAE（平均绝对误差）预测残差的绝对值之和，值越小越好。\n  R2 (R方分数)既考虑预测值与真值之间的差异又考虑问题本身与真值之间的差异。结果的约接近于1越好。\n    分类问题的评估标准\n  \n  正确率（Accuracy）即被预测正确的样本在所有预测样本中的占比。\n  召回率(TRR) 即在所有真的正类中被模型预测出来的比例。\n  AUC值：AUC的概率意义是随机取一对正负样本，正样本得分大于负样本得分的概\n AUC的范围在[0, 1]之间，并且越接近1越好，越接近0.5属于乱猜\n\n\n\n\n问题七：决策树的建立（以ppt为例）\n考察公式：\n\n信息熵公式：\\(H(X)=\\sum_{i=1}^{n}p_i log_2^{\\frac{1}{p_i}}=-\\sum_{i=1}^{n}p_i log_2{p_i}\\)\n信息增益公式：\\(Gain(D,a)=Ent(D)-Ent(d|a)=Ent(D)-\\sum_{v=1}^V \\frac{D_v}{D}Ent(D_v)\\)\n\n问题描述\n\n如下图，第一列为论坛号码，第二列为性别，第三列为活跃度，最后一列用户是否流失。\n\n\n    \n    \n        \n    \n    \n\n\n根据该图整理得到如下表格：\n\n\n    \n    \n        \n    \n    \n\n\n整体熵为多少\n\n\n    \n    \n        \n    \n    \n\n\n计算按照性别划分的信息增益\n\n要计算性别的信息增益需要先计算性别的信息熵\n\n\n    \n    \n        \n    \n    \n\n\n因此得到按照性别划分的信息增益为\n\n\n    \n    \n        \n    \n    \n\n\n计算按照活跃度划分的信息增益\n\n同样的，要计算活跃度的信息增益需要先计算活跃度的信息熵\n\n\n    \n    \n        \n    \n    \n\n\n因此得到按照活跃度划分的信息增益为：\n\n\n    \n    \n        \n    \n    \n\n\n比较两种特征对流失度的影响\n\n活跃度的信息增益比性别的信息增益大，也就是说，活跃度对用户流失的影响比性别大。\n\n做出决策树图形并说明理由\n\n根据第三问的分析，活跃度的信息增益比性别的信息增益大所以要选用，活跃度作为决策树的根节点。最终结果如下所示：\n\n\n    \n    \n        \n    \n    \n\n\n\n\n问题八：逻辑回归的优化目标函数是什么？交叉熵中的两个概率是分布什么？(不确定)\n\n逻辑回归的优化目标函数是:对数似然函数。 \n交叉熵的灵感概率是：真实分布，非真实分布。\n\n问题九：简述k近邻的算法流程，以及问题问题分析\n算法流程\n\n  计算距离：计算已知类别数据集中的点与当前点之间的距离\n2）排序：按距离递增次序排序\n3）选择：选取与当前点距离最小的k个点\n4）计算频次：统计前k个点所在的类别出现的频率\n5）确定类别：返回前k个点出现频率最高的类别作为当前点的预测分类\n\n\n计算题（以ppt为例）\n考察公式\n欧氏距离：平方和开根号 \n曼哈顿距离（城市街区距离）：绝对值的和\n\n提问\n假设我们现在有几部电影，如何去预测序号9电影的类别？\n\n\n    \n    \n        \n    \n    \n\n\n分别计算每个电影和被预测电影的距离，然后求解\n\n\n    \n    \n        \n    \n    \n\n\n所以最终结果预测为喜剧片。\n\n\n\n问题十：标准化与归一化问题（以PPT为例）\n归一化（重点）\n\n归一化定义：通过对原始数据进行变换把数据映射到(默认为[0,1])之间\n\n\n    \n    \n        \n    \n    \n\n\n作用于每一列，max为一列的最大值，min为一列的最小值，那么X’’为最终结果，mx，mi分别为指定区间值，默认mx为1，mi为0\n\n\n    \n    \n        \n    \n    \n\n\n标准化\n\n定义：通过对原始数据进行变换把数据变换到均值为0,标准差为1范围内\n\n\n    \n    \n        \n    \n    \n\n\n其中，它作用于每一列，mean为平均值，σ为标准差\n\n\n\n问题十一：k均值（k-means）聚类的算法\n流程\n\n  随机设置K个特征空间内的点作为初始的聚类中心\n  对于其他每个点计算到K个中心的距离，未知的点选择最近的一个聚类中心点作为标记类别\n  接着对着标记的聚类中心之后，重新计算出每个聚类的新中心点（平均值）\n  如果计算得出的新中心点与原中心点一样（质心不再移动），那么结束，否则重新进行第二步过程\n\n\n\n\n问题十二：梯度下降法\n梯度下降算法的作用：\n\n梯度下降法是一个优化算法，可以递归地找到模型的最小值，从而找到在最优参数。\n\n需要处理的问题：\n\n\n  学习率：需要在模型建立的速度和质量上做出权衡，学习率过大可能会导致最终结果不收敛，学习率过小会导致训练时间过长。\n  方向：计算出当前点的梯度方向，并向下不断更新自己的位置。\n  终止条件：考虑使用迭代次数、损失函数值到达一定范围之后终止。\n\n\n\n\n问题十三：逻辑回归（不确定）\n损失函数：\n\n\n    \n    \n        \n    \n    \n\n\n目标函数\n\n\n    \n    \n        \n    \n    \n\n\n定义：\n逻辑回归是机器学习中的一种分类模型，做二分类（1/0）任务，并给出相应概率。\nsigmoid函数\nsigmoid可以将数值压缩到[0,1]的范围内。\n\n\n\n问题十四：编程大题\n线性回归（以实验为例）\n\n\n  \n    \n      序号\n      直径（英寸）\n      价格（ 美元）\n    \n  \n  \n    \n      1\n      6\n      7\n    \n    \n      2\n      8\n      9\n    \n    \n      3\n      10\n      13\n    \n    \n      4\n      14\n      17.5\n    \n    \n      5\n      18\n      18\n    \n  \n\n\n该线性回归是一个几元函数，表达式是什么？\n是一个一元线性回归函数。\n表达式为：\\(f(x) = w_1x_1 + b\\)\n其中\\(w_1\\)表示的是“直径”特征的权重，\\(x_1\\)表示“直径”变量，\\(b\\)表示截距\n\n代码实现\nimport numpy as np\nimport pandas as pd\nfrom sklearn.linear_model import LinearRegression   # 最小二乘法线性回归\nfrom sklearn.model_selection import train_test_split\nimport matplotlib.pyplot as plt\n\nX_train_old = np.array([6,8,10,14,18]).reshape(5,1)\nY_train_old = np.array([7,9,13,17.5,18]).reshape(5,1)\nX_train_old,Y_train_old\n\n# 因为数据较少所以没必要再单独划出测试集了\nX_train,X_test,Y_train,Y_test = train_test_split(X_train_old,Y_train_old,random_state=33,test_size=0.2)\n# X_train,X_test,Y_train,Y_test = X_train_old,[],Y_train_old,[]\nX_train,X_test,Y_train,Y_test\n\nmodel = LinearRegression()\nmodel.fit(X_train,Y_train)\n\nT_sim1 = model.predict(X_test)\n\n\n逻辑回归（以实验为例）\n代码实现：\nimport pandas as pd\nimport numpy as np\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.linear_model import LogisticRegression\n\n# 1.获取数据\nnames = [&#39;Sample code number&#39;, &#39;Clump Thickness&#39;, &#39;Uniformity of Cell Size&#39;, &#39;Uniformity of Cell Shape&#39;,\n                   &#39;Marginal Adhesion&#39;, &#39;Single Epithelial Cell Size&#39;, &#39;Bare Nuclei&#39;, &#39;Bland Chromatin&#39;,\n                   &#39;Normal Nucleoli&#39;, &#39;Mitoses&#39;, &#39;Class&#39;]\ndata = pd.read_csv(r&quot;breast-cancer-wisconsin.data&quot;,names=names)\ndata.head()\n\nx_train, x_test, y_train, y_test = train_test_split(x, y, random_state=22)\nx_train.head()\n\nestimator = LogisticRegression()\nestimator.fit(x_train, y_train)\n\ny_predict = estimator.predict(x_test)\n\n问题十五：随机森林\n随机森林的算法流程（随机森林=Bagging+决策树）\n\n\n  随机选取m条数据\n  随机选取k个特征\n  训练决策树\n  重复1-3\n  对上面的若决策树进行平权投票\n\n\nbagging和boosting的区别\n\n区别一:数据方面\n\n  Bagging：对数据进行采样训练；\n  Boosting：根据前一轮学习结果调整数据的重要性。\n\n\n区别二:投票方面\n\n  Bagging：所有学习器平权投票；\n  Boosting：对学习器进行加权投票。\n\n\n区别三:学习顺序\n\n  Bagging的学习是并行的，每个学习器没有依赖关系；\n  Boosting学习是串行，学习有先后顺序。\n\n\n区别四:主要作用\n\n  Bagging主要用于提高泛化性能（解决过拟合，也可以说降低方差）\n  Boosting主要用于提高训练精度 （解决欠拟合，也可以说降低偏差）\n\n"
} ,
  
  {
    "title"    : "机器学习三大基础库",
    "category" : "",
    "tags"     : " 机器学习, python, numpy, pandas, matplotlib",
    "url"      : "/machine",
    "date"     : "December 6, 2022",
    "excerpt"  : "机器学习是研究怎样使用计算机模拟或实现人类学习活动的科学，是人工智能中最具智能特征，最前沿的研究领域之一。自20世纪80年代以来，机器学习作为实现人工智能的途径，在人工智能界引起了广泛的兴趣，特别是近十几年来，机器学习领域的研究工作发展很快，它已成为人工智能的重要课题之一。机器学习不仅在基于知识的系统中得到应用，而且在自然语言理解、非单调推理、机器视觉、模式识别等许多领域也得到了广泛应用。一个系统是否具有学习能力已成为是否具有“智能”的一个标志。\n\n\n\n前言\n\n本次博客主要内容为以下三个p...",
  "content"  : "机器学习是研究怎样使用计算机模拟或实现人类学习活动的科学，是人工智能中最具智能特征，最前沿的研究领域之一。自20世纪80年代以来，机器学习作为实现人工智能的途径，在人工智能界引起了广泛的兴趣，特别是近十几年来，机器学习领域的研究工作发展很快，它已成为人工智能的重要课题之一。机器学习不仅在基于知识的系统中得到应用，而且在自然语言理解、非单调推理、机器视觉、模式识别等许多领域也得到了广泛应用。一个系统是否具有学习能力已成为是否具有“智能”的一个标志。\n\n\n\n前言\n\n本次博客主要内容为以下三个python库\n\n  numpy\n  pandas\n  matplotlib\n\n\n前两个库numpy、pandas主要作用是对于数据存储与数据处理，并且广泛适用于很多机器学习的模型。而matplotlib是作图的好帮手，主要用户机器模型数据的可视化。\n\nnumpy（机器学习前缀知识）\n属性\n\n  数组的维数：对象名.ndim\n  数组的每个维度的数量：对象名.shape返回一个元组，元组中的数字表示该维度的长度。\n  元素总个数：对象名.size\n  成员的数据类型：对象名.dtype\n  矩阵的转置：对象名.T\n  对象名.flat 表示返回一个可以遍历所有元素的迭代器\n  numpy.nan 表示无穷\n  xxx\n\n\n功能型小函数\n\n\n  numpy.sum 求和\n  numpy.min 求最小值\n  numpy.max 求最大值\n  numpy.average 求平均值\n  numpy.median 求中位数\n  numpy.cumsum 返回前缀和向量\n  numpy.diff 返回一个差分数组（少一位）\n  numpy.argmin 求最小值的索引（从0开始计算）\n  numpy.argmax 求最大值的索引（从0开始计算）\n  numpy.nonzero返回n个向量，表示非元素所在位置的索引。\n  numpy.sort 返回对数组排序的结果，如果是多维则只会对一维排序（每一行）。\n  numpy.transpose 返回矩阵转置的结果\n  对象名.flatten() 返回该对象的一维展开（即变成一个行向量）\n  对象名.copy() 返回该对象的值拷贝（直接使用“=”是引用拷贝）注意不同于列表使用对象名[:]不能实现值拷贝，必须使用copy函数\n  numpy.random.randn 按正太分布的概率产生随机数数组\n  numpy.all(逻辑表达式) 逻辑表达式后半段 通过用这种方式将矩阵中所有数据参与计算返回一个bool判断矩阵中是不是所有元素都满足这个式子。\n  numpy.any(数组对象)逻辑表达式后半段 通过用这种方式将矩阵中所有数据参与计算返回一个bool判断矩阵中是否存在某个元素满足这个式子。\n\n\n示例（以numpy.sum为例）\n函数的默认计算区域是所有元素，当想要指定维度使用时需要使用axis来指定，axis从\n0开始计数。特别的对于一个矩阵来说，axis=0表示对每一列求和，axis=1表示对每一行求和。\n代码示例：\n\nimport numpy as np\n\na = np.arange(4).reshape(2,2)\nprint(a)\nprint(np.sum(a),np.sum(a,axis=1))\n\n程序运行截图：\n[[0 1]\n [2 3]]\n6 [1 5]\n\n\n矩阵索引\n以二维数组（矩阵）为例\n\n访问单元素的方法\na[i][j]，或 a[i,j]\n\n访问多元素的方法\n访问第i+1行的所有元素\na[i,:]\n访问第j+1列的所有元素\na[:,j]\n\n矩阵初始化 array\n函数签名：\narray(p_object, dtype=None, *args, **kwargs):\n\n上面的构造器接受以下参数：\n\n  object 任何暴露数组接口方法的对象都会返回一个数组或任何（嵌套）序列。\n  dtype 数组的所需数据类型，可选。\n  copy 可选，默认为true，对象是否被复制。\n  order C（按行）、F（按列）或A（任意，默认）。\n  subok 默认情况下，返回的数组被强制为基类数组。 如果为true，则返回子类。\n  ndmin 指定返回数组的最小维数。\n\n\n示例：\narray = numpy.array([[1,2,3],[4,5,6]].numpy.int64)\n\n滤波器clip\n\n函数签名：\ndef clip(a, a_min, a_max, out=None, **kwargs):\n\n将数组中小于a_min的值取a_min，将数组中大于a_max的值取a_max\n代码示例：\nimport numpy as np\n\na = np.arange(12)\n\nprint(np.clip(a,5,9))\n\n程序运行截图：\n[5 5 5 5 5 5 6 7 8 9 9 9]\n\n创建一个全1数组ones\n函数签名：\ndef ones(shape, dtype=None, order=&#39;C&#39;, *, like=None):\n\n示例：\nnumpy.noes((2,3,4)) # 创建一个2叶3行4列的全1矩阵\n\n\n创建一个全0数组zeros\n函数签名：\ndef zeros(shape, dtype=None, order=&#39;C&#39;, *args, **kwargs):\n\n\n示例：\nnumpy.zeros((2,3,4)) # 创建一个2叶3行4列的全0矩阵。\n\n\n创建有序数组arange\n函数签名：\ndef arange(start=None, *args, **kwargs):\n\n示例1（创建一个0~9的行向量）：\nnumpy.arange(10)\n\n程序输出：[0 1 2 3 4 5 6 7 8 9]\n\n示例2（创建一个5~9的行向量）：\nnumpy.arenge(5,10)\n\n程序输出：[5 6 7 8 9]\n\n示例3（创建一个以3为步长1~10的行向量）\nnumpy.arange(1,11,3)\n\n程序输出：[ 1  4  7  10]\n\n示例4（创建一个0~9的2行5列的矩阵）\nnumpy.arange(10).reshape(2,5) # 规模必须与元素个数相匹配\n\n程序输出：\n[[0 1 2 3 4]\n [5 6 7 8 9]]\n\n\n创建一个均匀划分的线段 linspace\n函数签名：\ndef linspace(start, stop, num=50, endpoint=True, retstep=False,type=None,axis=0):\n\n作用：以start为开始以stop结束以num为划分次数创建一个行向量。\n\n示例1（一般示例）：\nnumpy.linspace(0，10，2)\n\n程序输出：\n[ 0. 10.]\n\n示例2（重组元素为一个2*5的矩阵）\nnumpy.linspace(0,10,10).reshape(2,5)\n\n程序输出：\n[[ 0.          1.11111111  2.22222222  3.33333333  4.44444444]\n [ 5.55555556  6.66666667  7.77777778  8.88888889 10.        ]]\n\n\nnumpy的运算\n矩阵加减法：\n代码示例：\na = np.array([10,20,30,40])\nb = np.arange(1,5)\nprint(a-b)\nprint(a+b)\n\n程序运行截图：\n[ 9 18 27 36]\n[11 22 33 44]\n\n\n矩阵点乘：\n代码示例1（矩阵点乘）：\nimport numpy as np\n\na = np.array([10,20,30,40])\nb = np.arange(1,5)\nprint(a*b)\n\n程序运行截图：[ 10  40  90 160]\n\n代码示例2（矩阵乘数字）：\nimport numpy as np\n\na = np.array([10,20,30,40])\n\nprint(a*5)\n\n程序运行截图：[ 50 100 150 200]\n\n矩阵乘法：\n示例1（使用np.dot函数实现矩阵乘法）\n代码示例：\nimport numpy as np\n\na = np.arange(1,4).reshape(1,3)\nb = np.arange(1,4).reshape(3,1)\n\nc_dot = np.dot(a,b)\nd_dot = np.dot(b,a)\nprint(c_dot,d_dot,sep=&#39;\\n&#39;)\n\n程序运行截图：\n[[14]]\n[[1 2 3]\n [2 4 6] \n [3 6 9]]\n\n示例二（使用@符号实现矩阵乘法）：\n\n代码示例：\nimport numpy as np\n\na = np.arange(1,4).reshape(1,3)\nb = np.arange(1,4).reshape(3,1)\n\nprint(a@b,b@a,sep=&#39;\\n&#39;)\n\n程序运行截图：\n[[14]]\n[[1 2 3]\n [2 4 6]\n [3 6 9]]\n\n数组的逻辑判断：\n\n数组可以直接进行逻辑判断，其返回值为与元素组同规模的bool型结果数组。\n可以使用对象[逻辑表达式] 来过滤符合条件的项，返回一个行向量。\n\n代码示例：\nimport numpy as np\n\na = np.arange(10)\nprint(a &amp;lt; 3)\ns = np.random.random((4,4))\nprint(s[s &amp;gt; 0.5])\n\n程序运行截图：\n[ True  True  True False False False False False False False]\n[0.50784044 0.51138057 0.75612031 0.61457462 0.9712732  0.79497591]\n\n矩阵元素的函数运算：\n代码示例：\nimport numpy as np\n\na = np.arange(10)\nprint(np.sin(a))\n\n程序运行截图：\n[ 0.          0.84147098  0.90929743  0.14112001 -0.7568025  -0.95892427\n -0.2794155   0.6569866   0.98935825  0.41211849]\n\n\n创建一个元素值在0~1之间的随机矩阵\n示例（创建一个元素值在0~1之间的2行4列的随机矩阵）：\n代码示例：\nimport numpy as np\n\na = np.random.random((2,4))\n\nprint(a)\n\n程序运行截图：\n[[0.24853676 0.47803948 0.04436044 0.92552742]\n [0.61756337 0.31913713 0.83677922 0.51923448]]\n\n\n合并数组\n上下合并函数签名：\ndef vstack(tup):\n\n左右合并函数签名：\ndef hstack(tup):\n\n代码演示：\nimport numpy as np\n\na = np.array([1,2,3,4])\nb = np.array([4,3,5,8])\nprint(np.vstack((a,b)))\nprint(np.hstack((a,b)))\n\n程序运行截图：\n[[1 2 3 4]\n [4 3 5 8]]\n[1 2 3 4 4 3 5 8]\n\n数组分割 split or array_split\n等量数组分割 split\n\n函数签名：\ndef split(ary, indices_or_sections, axis=0):\n\n注意：axis表示对照切割的维度，例如对于矩阵而言axis=0表示横向切割，axis=1表示纵向切割，切割必须是对等切割否则报错。\n代码展示：\nimport numpy as np\n\nA = np.arange(12).reshape(3,4)\nprint(A)\nprint(&quot;纵向切割&quot;)\nprint(np.split(A,2,axis=1))\nprint(&quot;横向切割&quot;)\nprint(np.split(A,3,axis=0))\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n不等量数组分割 array_split\n函数签名：\ndef array_split(ary, indices_or_sections, axis=0):\n\n注意：这里与函数split最大的区别就是可以实现不等分的分法。前面等分，后面几项少分。\n代码展示：\nimport numpy as np\n\nA = np.arange(12).reshape(3,4)\n\nprint(A)\nprint(&quot;纵向切割&quot;)\nprint(np.array_split(A,3,axis=1))\nprint(&quot;横向切割&quot;)\nprint(np.array_split(A,2,axis=0))\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\npandas（机器学习前缀知识）\n属性\n\n  dtypes 获取所有列的数据格式\n  columns 获取所有列名\n  values 去除行名和列名，返回所有的内容，返回对象是numpy.ndarry。\n  T 获得矩阵的转置（列名和行名也会一起转）。\n    功能型小函数\n  \n  fillna(x) 将序列中出现的nan转变为x\n  isnull返回一个bool矩阵当原矩阵中该数值为nan时为true，非nan数据时为false。可以与numpy.any，numpy.all配套使用。\n  读取csv文件pd.read_csv(文件名)\n\n\n初始化矩阵\n创建矩阵 Series\n创建方式类似于numpy\n代码展示：\nimport pandas as pd\n\ns = pd.Series([1,3,6,44,1])\nprint(s)\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n定义有名称的数据 DataFrame\n说明：\nindex表示行标题，columns表示列标题，默认名称为从0开始的有序数列\n注意：每一行对应的数据数量要保持一致。\n示例1（使用序列创建）\n代码展示：\nimport pandas as pd\nmport numpy as np\ns = \nd.DataFrame(np.random.randn(3,4),index=[&#39;x&#39;,&#39;y&#39;,&#39;x&#39;],columns=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;])\nprint(s)\n\n程序运行截图:\n\n\n    \n    \n        \n    \n    \n\n\n示例2（使用字典创建）\n代码展示：\nimport pandas as pd\n\ns = pd.DataFrame({\n    &quot;a&quot;: [1,3],\n    &quot;b&quot;: [1.2,4],\n    &quot;c&quot;: [1.5,84],\n    &quot;d&quot;: [0.2,6]\n})\nprint(s)\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n数组访问\nloc （名称）表示法\n说明：\nloc[ [行名序列]，[列名序列] ]直接访问\nloc[ 行名序列i：行名序列j，列名序列i：列名序列j ]切片访问（切片是闭区间）\n\n两者可以混合使用。\n\n代码展示：\nimport pandas as pd\nimport numpy as np\n\ndates = pd.date_range(&#39;20221001&#39;, periods=6)\ns = pd.DataFrame(np.random.randn(6, 4), index=dates, columns=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])\n\nprint(s)\nprint(&#39;单个数据访问&#39;,s.loc[&quot;20221002&quot;,&#39;a&#39;],sep=&#39;\\n&#39;)\nprint(&#39;多行单列&#39;,s.loc[[&#39;20221002&#39;,&#39;20221001&#39;],&#39;b&#39;],sep=&#39;\\n&#39;)\nprint(&#39;单行多列&#39;,s.loc[&#39;20221002&#39;,[1,2]],sep=&#39;\\n&#39;)\nprint(&#39;多行多列&#39;,s.loc[[&#39;20221002&#39;,&#39;20221001&#39;],[&#39;a&#39;,&#39;b&#39;]],sep=&#39;\\n&#39;)\nprint(&#39;多行多列切片访问&#39;,s.loc[&#39;20221001&#39;:&#39;20221002&#39;,[&#39;a&#39;,&#39;b&#39;]],sep=&#39;\\n&#39;)\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\niloc（下标）表示法\n说明：\n使用方式等同于loc但是序列名变成了索引号（从0开始计数）（不同于loc的是使用切片表示法时是左开右闭区间）\n代码展示：\nimport pandas as pd\nimport numpy as np\n\ndates = pd.date_range(&#39;20221001&#39;, periods=6)\ns = pd.DataFrame(np.random.randn(6, 4), index=dates, columns=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])\n\nprint(s)\nprint(&#39;单个数据访问&#39;,s.iloc[1,1],sep=&#39;\\n&#39;)\nprint(&#39;多行单列&#39;,s.iloc[0:3,3],sep=&#39;\\n&#39;)\nprint(&#39;单行多列&#39;,s.iloc[0,0:3],sep=&#39;\\n&#39;)\nprint(&#39;多行多列&#39;,s.iloc[0:2,[0,3]],sep=&#39;\\n&#39;)\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n访问一列\n访问方式：\n\n对象名[列名]（适用于所有情况的访问方式）\n对象名.列名（这种访问方式仅适用于标题为字符串型的情况）\n\n代码展示：\nimport pandas as pd\nimport numpy as np\ndates = pd.date_range(&#39;20221001&#39;, periods=6)\ns = pd.DataFrame(np.random.randn(6, 4), index=dates, columns=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])\nprint(s)\nprint(s[&#39;a&#39;])\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n访问一行数据 loc\n代码展示：\nimport pandas as pd\nimport numpy as np\n\ndates = pd.date_range(&#39;20221001&#39;, periods=6)\ns = pd.DataFrame(np.random.randn(6, 4), index=dates, columns=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])\n\nprint(s)\nprint(s.loc[&quot;20221002&quot;])\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n访问多行数据\n\n多行数据直接访问语法：\n对象名[start:end] 这里的start、end既可以是数字用于表示序列的索引，当行名不是整数型时也可以直接使用行名（行名可以是字符串）\n\n数组修改\n说明：\n与赋值相似，对已存在的数值进行修改就是修改，对不存在的数据就是添加可以通过修改不存在的行列使得数据的行列增加（未知数据用NAN代替）\n代码展示：\nimport pandas as pd\nimport numpy as np\n\ndates = pd.date_range(&#39;20221001&#39;, periods=6)\ns = pd.DataFrame(np.random.randn(6, 4), index=dates, columns=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])\nprint(s)\nprint(&quot;修改数值&quot;)\ns.a[s.a &amp;lt; 0] = 0\nprint(s)\nprint(&quot;增加行&quot;)\ns.loc[&#39;new_index&#39;] = np.nan\nprint(s)\nprint(&quot;增加列&quot;)\ns.loc[:,&quot;new_columns&quot;] = np.array([0,1,2,3,4,5,6])\nprint(s)\nprint(&quot;同时增加行和列&quot;)\ns.loc[8,&#39;f&#39;] = np.nan\nprint(s)\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n删除行列 dropna\n说明：\n\naxis = 0 时表示删除行，1表示删除列\n\nhow参数有两个值：\n\n\n  “any”：如果存在任何NAN值，则删除该行或列。\n  “all”：如果所有值都为NAN值，则删除该行或列。\n\n\n注意：dropna 只是返回修改后的结果不会改变原本的值\n代码展示：\nimport pandas as pd\nimport numpy as np\n\ndates = pd.date_range(&#39;20221001&#39;, periods=6)\ns = pd.DataFrame(np.random.randn(6, 4), index=dates, columns=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])\n\nprint(s)\ns.iloc[0,0] = np.nan\ns.iloc[2] = np.nan\ns.iloc[:,3] = np.nan\nprint(s)\nprint(&quot;axis == 0 时表示删除行，1表示删除列&quot;)\ns = s.dropna(axis=0,how=&#39;all&#39;)\nprint(s)\ns = s.dropna(axis=1,how=&#39;all&#39;)\nprint(s)\ns = s.dropna(axis=0,how=&#39;any&#39;)\nprint(s)\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n读写excle文件 read_excle or .to_excle\n注意：\n\nread_excle 得到的是一个pandas对象，之前数据访问修改删除等操作依然成立。\nto_excle创建时会添加一列行名，可以使用index=False 去除行名的添加。\n脚本编程\n逻辑表达式筛选：\n\n使用对象名[逻辑表达式]方式筛选。\n代码展示：\nimport pandas as pd\nimport numpy as np\n\ndates = pd.date_range(&#39;20221001&#39;, periods=6)\ns = pd.DataFrame(np.random.randn(6, 4), index=dates, columns=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])\nprint(s)\nprint(&#39;第0列数据大于0的数据有：&#39;)\nprint(s[s.iloc[:,0] &amp;gt; 0])\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n数据分析 describe\n代码展示：\nimport pandas as pd\n\ns = pd.DataFrame({\n    &quot;a&quot;: [1,3],\n    &quot;b&quot;: [1.2,4],\n    &quot;c&quot;: [1.5,84],\n    &quot;d&quot;: [2,6.2]\n})\nprint(s.describe(),sep=&#39;\\n&#39;)\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n排序 sort_index &amp;amp; sort_values\nsort_index 对行列名排序\n说明：\naxis = 0表示对行名进行排序，1表示对列名进行排序。\n排序默认升序排序，当ascending = True 表示倒序排序\n函数签名：\ndef sort_index(\n    self,\n    axis: Axis = 0,\n    level: Level | None = None,\n    ascending: bool | int | Sequence[bool | int] = True,\n    inplace: bool = False,\n    kind: str = &quot;quicksort&quot;,\n    na_position: str = &quot;last&quot;,\n    sort_remaining: bool = True,\n    ignore_index: bool = False,\n    key: IndexKeyFunc = None,\n):\n\n代码展示：\nimport pandas as pd\ns = pd.DataFrame({\n    &quot;a&quot;: [1, 3],\n    &quot;b&quot;: [1.2, 4],\n    &quot;c&quot;: [1.5, 84],\n    &quot;d&quot;: [2, 6.2]\n})\nprint(s.sort_index(axis=0, ascending=False), sep=&#39;\\n\\n&#39;)\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\nsort_values对数据列排序\n函数签名：\ndef sort_values(  # type: ignore[override]\n    self,\n    by,\n    axis: Axis = 0,\n    ascending=True,\n    inplace: bool = False,\n    kind: str = &quot;quicksort&quot;,\n    na_position: str = &quot;last&quot;,\n    ignore_index: bool = False,\n    key: ValueKeyFunc = None,\n):\n\n代码展示：\nimport pandas as pd\n\ns = pd.DataFrame({\n    &quot;a&quot;: [1, 3],\n    &quot;b&quot;: [1.2, 4],\n    &quot;c&quot;: [1.5, 84],\n    &quot;d&quot;: [2, 6.2]\n})\n\nprint(s.sort_values(&#39;a&#39;,ascending=False))\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n合并数组 merge\n说明：\nhow 有4个取值：inner（默认）、outer、left、right 分别表示内连接、外连接、左外连接、右外连接。\non 表示连接是使用的列（类似于外键）\nindictor == True时，在结果列中增加一列以显示每一个数据连接的方式默认为False，可以给indictor赋予字符串，以表示新列的名称\nleft_\tindex &amp;amp; right_index同时为True时可以按行名合并，默认都为False，两者必须同为True才能生效。\nsuffixex当给其一个包含两个字符串的元组时，合并时若出现同名字段，则会加上这两个字符串后缀。\n函数签名：\ndef merge(\n    left: DataFrame | Series,\n    right: DataFrame | Series,\n    how: str = &quot;inner&quot;,\n    on: IndexLabel | None = None,\n    left_on: IndexLabel | None = None,\n    right_on: IndexLabel | None = None,\n    left_index: bool = False,\n    right_index: bool = False,\n    sort: bool = False,\n    suffixes: Suffixes = (&quot;_x&quot;, &quot;_y&quot;),\n    copy: bool = True,\n    indicator: bool = False,\n    validate: str | None = None,\n) -&amp;gt; DataFrame:\n\n\n案例演示\n示例1（依照指定列进行合并）：\n代码演示：\nimport numpy as np\nimport pandas as pd\n\nleft = pd.DataFrame({\n    &#39;key&#39;: [&#39;K0&#39;, &#39;k1&#39;, &#39;k2&#39;, &#39;k3&#39;],\n    &#39;A&#39;: [&#39;A0&#39;, &#39;A1&#39;, &#39;A2&#39;, &#39;A3&#39;],\n    &#39;B&#39;: [&#39;B0&#39;, &#39;B1&#39;, &#39;B2&#39;, &#39;B3&#39;]\n})\n\nright = pd.DataFrame({\n    &#39;key&#39;:[&#39;K0&#39;, &#39;k1&#39;, &#39;k2&#39;, &#39;k3&#39;],\n    &#39;C&#39;:[&#39;C0&#39;,&#39;C1&#39;,&#39;C2&#39;,&#39;C2&#39;],\n    &#39;D&#39;:[&#39;D0&#39;,&#39;D1&#39;,&#39;D2&#39;,&#39;D3&#39;]\n})\n\nprint(left)\nprint(right)\nres = pd.merge(left,right,on=&#39;key&#39;)\nprint(res)\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n示例2依照多列进行合并\n代码演示：\nimport numpy as np\nimport pandas as pd\n\nleft = pd.DataFrame({\n    &#39;key1&#39;: [&#39;K0&#39;, &#39;k0&#39;, &#39;k1&#39;, &#39;k2&#39;],\n    &#39;key2&#39;: [&#39;K0&#39;, &#39;k1&#39;, &#39;k0&#39;, &#39;k1&#39;],\n    &#39;A&#39;: [&#39;A0&#39;, &#39;A1&#39;, &#39;A2&#39;, &#39;A3&#39;],\n    &#39;B&#39;: [&#39;B0&#39;, &#39;B1&#39;, &#39;B2&#39;, &#39;B3&#39;]\n})\n\nright = pd.DataFrame({\n    &#39;key1&#39;: [&#39;K0&#39;, &#39;k1&#39;, &#39;k1&#39;, &#39;k2&#39;],\n    &#39;key2&#39;: [&#39;K0&#39;, &#39;k0&#39;, &#39;k0&#39;, &#39;k0&#39;],\n    &#39;C&#39;: [&#39;C0&#39;, &#39;C1&#39;, &#39;C2&#39;, &#39;C2&#39;],\n    &#39;D&#39;: [&#39;D0&#39;, &#39;D1&#39;, &#39;D2&#39;, &#39;D3&#39;]\n})\n\nprint(left)\nprint(right)\n# how = [&#39;left&#39;,&#39;right&#39;,&#39;inner&#39;,&#39;outer&#39;]\nprint(&#39;内连接&#39;)\nprint(pd.merge(left, right, on=[&#39;key1&#39;,&#39;key2&#39;],how=&#39;inner&#39;))\nprint(&#39;全外连接&#39;)\nprint(pd.merge(left, right, on=[&#39;key1&#39;,&#39;key2&#39;],how=&#39;outer&#39;))\nprint(&#39;左外连接&#39;)\nprint(pd.merge(left, right, on=[&#39;key1&#39;,&#39;key2&#39;],how=&#39;left&#39;))\nprint(&#39;右外连接&#39;)\nprint(pd.merge(left, right, on=[&#39;key1&#39;,&#39;key2&#39;],how=&#39;right&#39;))\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n示例3（显示每一列的合并方式）\n代码演示：\nimport pandas as pd\ndf1 = pd.DataFrame({&#39;col1&#39;:[0,1],&#39;col_left&#39;:[&#39;a&#39;,&#39;b&#39;]})\ndf2 = pd.DataFrame({&#39;col1&#39;:[1,2,2],&#39;col_right&#39;:[2,2,2]})\nprint(df1)\nprint(df2)\nres = pd.merge(df1,df2,on=&#39;col1&#39;,indicator=True,how=&#39;outer&#39;)\nprint(res)\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n示例4（依照行名进行合并）\n代码演示：\nimport pandas as pd\nleft = pd.DataFrame({\n    &#39;A&#39;:[&#39;A0&#39;,&#39;A1&#39;,&#39;A2&#39;],\n    &#39;B&#39;:[&#39;B0&#39;,&#39;B1&#39;,&#39;B2&#39;]},\n    index=[&#39;K0&#39;,&#39;K1&#39;,&#39;K2&#39;])\nright = pd.DataFrame({\n    &#39;C&#39;:[&#39;C0&#39;,&#39;C2&#39;,&#39;C3&#39;],\n    &#39;D&#39;:[&#39;D0&#39;,&#39;D2&#39;,&#39;D3&#39;]},\n    index=[&#39;K0&#39;,&#39;K2&#39;,&#39;K3&#39;])\nprint(left)\nprint(right)\nres = pd.merge(left,right,right_index=True,left_index=True,how=&#39;outer&#39;)\nprint(res)\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n示例5（同名字段加后缀）\n代码演示：\nimport pandas as pd\nboys = pd.DataFrame({&#39;k&#39;: [&#39;K0&#39;, &#39;k1&#39;, &#39;k2&#39;], &#39;age&#39;: [1, 2, 3]})\ngirls = pd.DataFrame({&#39;k&#39;: [&#39;K0&#39;, &#39;K1&#39;, &#39;K2&#39;], &#39;age&#39;: [4, 5, 6]})\nprint(boys)\nprint(girls)\nres = pd.merge(boys,girls,on=&#39;k&#39;,suffixes=(&#39;_boy&#39;,&#39;_girl&#39;),how=&#39;outer&#39;)\nprint(res)\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n合并数组 concat\n说明：\naxis == 0(默认) 表示竖向的合并，1表示横向合并\nignore == True表示纵向合并时忽略原行序列从新有序定义行标号，默认False\njoin 表示纵向连接方式默认为outer外连接（默认），还可以选择 inner 内连接\n注意：当竖向合并时，列名不一致（不包括次序不一致）将产生新列（全外连接）\n\n示例1\n代码展示：\nimport pandas as pd\nimport numpy as np\n\ndf1 = pd.DataFrame(np.ones((3,4))*0,columns=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;])\ndf2 = pd.DataFrame(np.ones((3,4))*1,columns=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;])\ndf3 = pd.DataFrame(np.ones((3,4))*2,columns=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;])\n\nprint(pd.concat([df1,df2,df3],axis=0,ignore_index=True))\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n示例2（纵向连接，两种连接的比较）\n代码演示：\nimport pandas as pd\nimport numpy as np\n\ndf1 = pd.DataFrame(np.ones((3,4))*0,index=[1,2,3],columns=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;])\ndf2 = pd.DataFrame(np.ones((3,4))*1,index=[2,3,4],columns=[&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;])\n\nprint(pd.concat([df1,df2],axis=0,join=&#39;outer&#39;))\nprint(pd.concat([df1,df2],axis=0,join=&#39;inner&#39;))\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n示例三（横向连接的4种方式比较）\n注意：\n代码演示：\nimport pandas as pd\nimport numpy as np\n\ndf1 = pd.DataFrame(np.ones((3,4))*0,index=[1,2,3],columns=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;])\ndf2 = pd.DataFrame(np.ones((3,4))*1,index=[2,3,4],columns=[&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;])\nprint(&quot;全外连接&quot;)\nprint(pd.concat([df1,df2],axis=1))\nprint(&quot;左外链接&quot;)\nprint(pd.concat([df1,df2.reindex(df1.index)],axis=1))\nprint(&quot;右外连接&quot;)\nprint(pd.concat([df2,df1.reindex(df2.index)],axis=1))\nprint(&quot;内连接&quot;)\nprint(pd.concat([df2.reindex(df1.reindex(df2.index).index)],axis=1))\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n数据筛选query\nDataFrame.query(expr, inplace=False, **kwargs)，用于通过boolean表达式来查询dataframe中的列。\n主要参数为expr，它是字符串表达式，有如下说明：\n\n可以引用变量，方法是在变量前添加一个@字符，例如@a + b。\n可以在反引号内将包含空格或运算符的列名引用起来。 这样，您还可以转义以数字开头或Python关键字的名称。 基本上是无效的Python标识符。\n\nmatplotlib（图像绘制）\n\n函数应用\n函数签名：\ndef plot(*args, scalex=True, scaley=True, data=None, **kwargs):\n\n\n\n  x: 横坐标，可选的， 默认为 range(len(y))\n  y: 纵坐标，即数据项，可以是一维或多维的列表或数组\n  markersize: 标记大小\n  color: 线条颜色\n  marker: 数据标记的形状，默认是没有标记\n  linestyle: 线条样式，默认为实线\n代码演示：\n\n\nimport matplotlib.pyplot as plt\n\nx = [1, 2, 3]\ny = [1, 2, 3]\n# 以下两种写法等价，\nplt.plot(x, y, color=&#39;green&#39;, marker=&#39;o&#39;, linestyle=&#39;dashed&#39;, linewidth=2, markersize=12)\n# plt.flot(x, y, &#39;go--&#39;，linewidth=2, markersize=12)\n# 可以在一个画布上绘制多张图片，\ny1 = [4, 5, 6]\nplt.plot(x, y1, color=&#39;red&#39;, marker=&#39;*&#39;, linestyle=&#39;solid&#39;, linewidth=2, markersize=12)\nplt.show()\n\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n重要示例\n\n示例1（创建4个折线图）\n说明：使用plot实现，其中show函数主要实现图像的展示工作。\n代码演示：\n\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndata = pd.DataFrame(np.random.randn(1000,4),index=np.arange(1000),columns=list(&quot;ABCD&quot;))\n\ndata = data.cumsum()    # 累加\ndata.plot()\nplt.show()\n\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n示例二（创建2个散点图）\n代码演示：\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndata = pd.DataFrame(np.random.randn(1000,4),index=np.arange(1000),columns=list(&quot;ABCD&quot;))\ndata = data.cumsum()    # 累加\nax = data.plot.scatter(x=&#39;A&#39;,y=&#39;B&#39;,color=&#39;DarkBlue&#39;,label=&quot;Class 1&quot;)\ndata.plot.scatter(x=&#39;A&#39;,y=&#39;C&#39;,color=&#39;DarkGreen&#39;,label=&quot;Class 2&quot;,ax=ax)\nplt.show()\n\n程序运行截图：\n\n\n    \n    \n        \n    \n    \n\n\n日常问题\n图形中文乱码\n\n解决方法：更改字体防止图形乱码\nfrom matplotlib import pyplot as pl\npl.rcParams[&#39;font.sans-serif&#39;] = [&#39;SimHei&#39;]\n\n"
} ,
  
  {
    "title"    : "python 多线程与多进程",
    "category" : "",
    "tags"     : " python, 多线程, 多进程",
    "url"      : "/process",
    "date"     : "December 5, 2022",
    "excerpt"  : "进程是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。线程是进程中的一部分，也是进程的的实际运作单位，它也是操作系统中的最小运算调度单位。\n\n\n前言\n多线程与多进程还是比较实用的。本博客以应用为目的展示两个基础的类。\n\n多进程 Process\n\nprocess模块是一个创建进程的模块，借助这个模块，就可以完成进程的创建。\nfrom multiprocessing import Process\n\n参数介绍\nProcess(group=N...",
  "content"  : "进程是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。线程是进程中的一部分，也是进程的的实际运作单位，它也是操作系统中的最小运算调度单位。\n\n\n前言\n多线程与多进程还是比较实用的。本博客以应用为目的展示两个基础的类。\n\n多进程 Process\n\nprocess模块是一个创建进程的模块，借助这个模块，就可以完成进程的创建。\nfrom multiprocessing import Process\n\n参数介绍\nProcess(group=None, target=None, name=None, args=(), kwargs={})\n\n\n\n  group——参数未使用，值始终为None\n  target——表示调用对象，即子进程要执行的任务\n  args——表示调用对象的位置参数元组，args=(1,2,’egon’,)\n  kwargs——表示调用对象的字典，kwargs={‘name’:’egon’,’age’:18}\n  name——为子进程的名称\n\n\n方法介绍\n\n  obj.start()：启动进程，并调用该子进程中的obj.run()\n  obj.run()：进程启动时运行的方法，正是它去调用target指定的函数，我们自定义类的类中一定要实现该方法\n  obj.terminate()：强制终止进程obj，不会进行任何清理操作，如果obj创建了子进程，该子进程就成了僵尸进程，使用该方法需要特别小心这种情况。如果obj还保存了一个锁那么也将不会被释放，进而导致死锁\n  obj.is_alive()：如果obj仍然运行，返回True\n  obj.join([timeout])：主线程等待obj终止（强调：是主线程处于等的状态，而obj是处于运行的状态）。timeout是可选的超时时间，需要强调的是，obj.join只能join住start开启的进程，而不能join住run开启的进程\n\n\n属性介绍\n\n  obj.daemon：默认值为False，如果设为True，代表obj为后台运行的守护进程，当obj的父进程终止时，obj也随之终止，并且设定为True后，obj不能创建自己的新进程，必须在\n  obj.start()：之前设置\n  obj.name：进程的名称\n  obj.pid：进程的pid\n  obj.exitcode：进程在运行时为None、如果为–N，表示被信号N结束(了解即可)\n  obj.authkey：进程的身份验证键,默认是由os.urandom()随机生成的32字符的字符串。这个键的用途是为涉及网络连接的底层进程间通信提供安全性，这类连接只有在具有相同的身份验证键时才能成功（了解即可）\n\n\n使用案例\nfrom multiprocessing import Process\nimport os\n\ndef worker(arg):\n    # 返回父子进程的pid\n    print(os.getpid(), os.getppid())\n\n\nif __name__ == &quot;__main__&quot;:\n    print(&#39;I am parent process&#39;)\n    jobs = []\n    for i in range(5):\n        p = Process(target=worker, args=(i,))\n        jobs.append(p)\n        p.start()\n\n方法介绍\n\n\n    \n    \n        \n    \n    \n\n\n使用样例\n利用函数使用多线程\nfrom threading import Thread\na = 0\ndef work():\n    global a\n    a += 1\n    print(a，end=’’)\n\nif __name__ == &#39;__main__&#39;:\n    childs = []\n    for i in range(5):\n        childs.append(Thread(target=work))\n        childs[-1].start()\n\n\n程序运行结果：\n1 2 3 4 5\n如果创建的不是线程而是进程则资源不会共享，运行结果会是：\n1 1 1 1 1\n\n利用类重写Thrrad方法实现多线程\nfrom threading import Thread\nimport time\nnum = 0\nchilds = []\nclass MyThread(Thread):\n    def run(self):\n        self.t = num\n\n        for _ in range(3):\n            print(self.t, &#39;线程正在工作&#39;)\n            time.sleep(0.5)\n\n\nfor i in range(3):\n    num = i + 1\n    childs.append(MyThread())\n    childs[-1].start()\n\n运行结果之一：\n1 线程正在工作\n2 线程正在工作\n3 线程正在工作\n132 线程正在工作 线程正在工作 \n线程正在工作\n\n13 线程正在工作\n2 线程正在工作\n 线程正在工作\n\n可以看到输出十分的杂乱，说明确实是多线程输出。\n"
} ,
  
  {
    "title"    : "OpenStack",
    "category" : "",
    "tags"     : " OpenStack, 期末考试",
    "url"      : "/openstack",
    "date"     : "December 4, 2022",
    "excerpt"  : "OpenStack是Rackspace和NASA共同成立的一个开源项目，它是为云计算服务的，提供存储空间、计算能力等资源服务的Web Service。简单来说，OpenStack就是一个操作系统，一套软件，一套IaaS（基础设施即服务）软件，对资源进行管理，并且以服务的形式提供给上层应用或者用户去使用。\n\n\n\n前言\n\n以下为openstack的期末复习，考试考点整理，内容比较多且知识点生僻难懂，请好好准备，祝愿各位可以在期末获取一个好成绩！\n\n\n\n第一章考点\n什么是云计算\n云计算是一种把计...",
  "content"  : "OpenStack是Rackspace和NASA共同成立的一个开源项目，它是为云计算服务的，提供存储空间、计算能力等资源服务的Web Service。简单来说，OpenStack就是一个操作系统，一套软件，一套IaaS（基础设施即服务）软件，对资源进行管理，并且以服务的形式提供给上层应用或者用户去使用。\n\n\n\n前言\n\n以下为openstack的期末复习，考试考点整理，内容比较多且知识点生僻难懂，请好好准备，祝愿各位可以在期末获取一个好成绩！\n\n\n\n第一章考点\n什么是云计算\n云计算是一种把计算机基础资源经过重组后给用户使用的一系列相关服务。\n\n云计算架构对应几种架构模式以及概念\nIaaS（基础设施即服务）\nPaaS（平台即服务）\nSaaS（软件即服务）\n\nOpenStack 的主要项目以及对应的项目名称\n\n\n  \n    \n      服务\n      直译\n      项目名称\n    \n  \n  \n    \n      Dashboard\n      仪表盘\n      Horizon\n    \n    \n      Computer\n      计算\n      Nova\n    \n    \n      Natwork\n      网络\n      Neutron\n    \n    \n      Object Storage\n      对象存储\n      Swift\n    \n    \n      Block Storage\n      块存储\n      Cindar\n    \n    \n      Identity\n      身份\n      Keystone\n    \n    \n      Image\n      镜像\n      Glance\n    \n    \n      Telemetry\n      计量\n      Ceilometer\n    \n    \n      Orchestration\n      编排\n      Heat\n    \n    \n      Database\n      数据库\n      Trove\n    \n    \n      Data Processing\n      数据处理\n      Sahara\n    \n  \n\n\n\n\n第二章考点\n网络配置流程\n\n\n  进入网络配置的文件：vi  /etc/sysconfig/netwrok-scripts/ifcfg-ens33\n  修改BOOTPROTO的值为static \n  修改ONBOOT的值为yes\n  添加配置4条信息：IPADDR NETNASK GATEWAY DNS1\n  键入qw保存并退出配置文件\n  输入：systemctl restart network 重启network服务。\n\n\nopenstack的安装\n\n\n  安装openstack-packstack以及其依赖包：yum install -y openstack-packstack\n  安装openstack：packstack --allinone\n  进入文件查看生成的初始密码配置：vi /etc/my.cnf.d/server.cnf\n\n\n\n\n第三章考点\n\n数据库\n1.数据库验证\n验证方式：systemctl status sqlname\n\n2. 数据库有哪些\nNoSQL数据库：MongoDB Memcached Redis\nSQL数据库：MySQL Maria PostgreSQL\n\n消息队列\n什么是消息队列\n消息队列是一种应用程序对应用程序的通信方法。消息传递指的是程序之间通过打消良中发送数却进行通信,而不是通过百捉调用彼此来通信。\n\n消息队列实现的协议以及对应的软件\n协议：AMQP\n软件：RabbitMQ\n\n\n\n第四章考点\n\nREST 含义解释\nRESTFUL是一种网络应用程序的设计风格和开发方式，是我们用http调用资源的时候的统一接口的访问形式，用自己的话说就是把对资源的调用转化到一种表现方式上来，例如开发的时候使用微信小程序表现可以避免用不同的语言开发app应用\n\n调用OpenStack API的四种方式\n\n  cURL \n  OpenStack命令行客服端\n  REST客户端\n  OpenStack的Python SDK\n\n\nOpenStack 的认证与API 请求流程\n\n\n  向云管理员提供的身份端点请求一个认证令牌。\n  如果请求成功，服务器会返回一个认证令牌。\n  发送API请求，并在X-Auth-Token头部包括上一步返回的认证令牌。可以一直使用这个令牌发送API请求，直到服务完成该请求，或者出现未授权(401)的错误。\n  如果遇到未授权（401）的错误，则需要重新请求另一个令牌。\n\n\n获取OpenStack认证令牌\n\n\n  进入demo环境：source keystonerc_demo\n  运行命令cURL来请求一个令牌。\n\n\n发送API请求\n\n\n  设置OS_TOKEN环境变量，将其值设为令牌ID： export OS_TOKEN=令牌ID\n  设置OS_PROJECT_NAME环境变量：export OS_PROJECT_NAME=demo\n  设置OS_COMPUTE_API环境变量：export OS_COMPUTE_API=http://192.168.199.21:8774/v2.1\n  使用Compute API列出示例类型：curl -s -H &quot;X-Auth-Token: $OS_TOKEN&quot; $os_COMPUTE_API/flavors lpython -m json.tool。\n\n\n\n第五章\n\nKeystone的管理层次结构\n\n\n    \n    \n        \n    \n    \n\n\n问：在一个域中的用户User1是否可以管理项目Project1\n\n答：可以，因为用户User1是系统管理员，拥有对项目Project1的管理权限。\n\n\nKeystone认证流程图\n这张图需要背下来。\n\n\n    \n    \n        \n    \n    \n\n\n对图片的解释：\n\n\n  用户向Keystone提供凭证，Keystone验证通过后向用户返回令牌的同时还会返回一个通用目录。\n  用户使用该令牌向该目录列表中的端点请求该用户对应的项目信息，Keystone验证通过后返回用户对应的项目列表\n  用户从列表中选择要访问的项目再次向Keystone发出请求，Keystone验证通过后返回管理该项目的服务列表，并允许访问该项目的令牌。\n  用户会通过这个服务和通用目录映射找到服务的端点，并通过端点找到实际服务组件的位置。\n  用户在凭借项目令牌和端点来访问实际上的服务组件。\n  服务组件会向Keystone提供这个用户项目令牌进行验证，Keystone验证通过后会返回一系列的确认信息和附加信息给服务\n  服务执行一系列操作。\n\n\n罗列命令行操作\n\n  列出可用角色：openstack role list\n  创建角色：openstack role create new-role\n  分配角色：openstack role add --user 用户名或ID --oject项目名或ID角色名或ID\n  查看角色详细信息：openstack role show角色名或ID\n  删除角色：openstack role remove --user 用户名或ID--project用户名或ID角色名或ID\n\n\n\n\n第六章\n常用的镜像格式以及容器\n\n镜像格式：qcwr\n不用容器使用bare代替\n使用容器可以在ovf ova aki ari docker中选择\n\nopenstack中创建镜像的流程\n创建镜像，转成快照\n\n\n  获取实例啃决照的文件路径，可通过查看其详细信息中的“ID”值。\n  其中执行openstack image create 创建新的镜像：openstack image create &quot;entOS7-img&quot;--file varlib/glance/limages/快照id --disk-format qcow2--container-format bare\n  新创建的镜像类型变为镜像(image) .\n\n\n\n第七章\n\n虚拟机实例化的流程\n\n  首先用户（可以是OpenStack最终用户，也可以是其他程序）执行Nova Client提供的用于创建虚拟机的命令。\n  nova-api服务监听到来白于Nova Client的HTTP请求,并将这些请求转换为AMQP消息之后加入消息队列。\n  通过消息队列调用nova-conductor报务。\n  nova-conductor服务从消息队列中接收到虚拟机实例化请求消息后,进行一些准备工作。\n  nova-conductor服务通过消息队列告诉nova-scheduler服务去选择一个合适的计算节点来创建虚拟机，此时nova-scheduler会读取数据库的内容。\n  nova-conductor服务从nova-scheduler服务得到了合适的将计算节点的信息后，在通过消息队列来通知nova-compute服务实现虚拟机的创建。\n\n\n其他\n配置文件中对两个值的解释\n\n”” 空字符串\n表示“always”（总是）\n\n”!” 感叹号\n表示“nerver”或者“nobady”，即拒绝。\n\n小知识点\n\n\n  oslo.policy是json格式的文件。\n  openstack是使用python语言实现的。\n\n"
} ,
  
  {
    "title"    : "Jekyll 入门指导",
    "category" : "",
    "tags"     : " Jekyll, web前端",
    "url"      : "/jekyll",
    "date"     : "December 4, 2022",
    "excerpt"  : "jekyll是一个简单的免费的Blog生成工具，类似WordPress。但是和WordPress又有很大的不同，原因是jekyll只是一个生成静态网页的工具，不需要数据库支持。但是可以配合第三方服务,例如Disqus。最关键的是jekyll可以免费部署在Github上，而且可以绑定自己的域名。\n\n\n\n前言\n\n该博客的部署使用的就是Jekyll框架，Jekyll是一门很成熟的技术（也可能是有点老的缘故），他可以将makedown格式的文档转化成一个个静态的页面，即便你没有系统的学过前端三件套...",
  "content"  : "jekyll是一个简单的免费的Blog生成工具，类似WordPress。但是和WordPress又有很大的不同，原因是jekyll只是一个生成静态网页的工具，不需要数据库支持。但是可以配合第三方服务,例如Disqus。最关键的是jekyll可以免费部署在Github上，而且可以绑定自己的域名。\n\n\n\n前言\n\n该博客的部署使用的就是Jekyll框架，Jekyll是一门很成熟的技术（也可能是有点老的缘故），他可以将makedown格式的文档转化成一个个静态的页面，即便你没有系统的学过前端三件套也可以制作自己的主页（真的太棒了！）。\n\n对于使用者来说只需要找到对应的资源模板，套用jekyll即可得到你想要的博客。\n\n如果你想要了解更多，这个是Jekyll官网的传送门 \\(\\Longrightarrow\\) Jekyll\n\n\n\nJekyll 基础知识\n\n基本结构\nJekyll 也遵循「约定大于配置」的基本原则，所以上手成本极低。\n\n在新创建的项目目录下，有几个重要的文件夹：\n\n_layouts\n\n用于存放各种布局.html 的文件用于对.md文件的转换，在md设置的消息头中的变量，.md文件选择了layout布局之后，会引入对应的布局.html中，html会存放这些变量的默认值，\n\n_drafts\n\n用于存放.md博客的草稿，不会再jekyll工作的时候生成，需要使用指令jekyll server –draft 才会显示在界面中\n_posts\n\n用于存放博客文章\n_site\n\n用于存放项目构建完成之后所生成的静态文件，也就是说，静态网站的所有文件都会来源于此，其中 CSS 文件、JS 文件以及图片文件，会存放在该目录下的 assets 文件夹中。我们可以直接把该目录下的文件拿去部署\n\n除此之外，还有一些其他文件：\n_config.yml\n\n是项目的配置文件，一些全局配置会写在这个文件内，比如 collections（后续推文会讲解），默认文件/路径，等等。总之，这里可以自定义很多东西\n\n.gitignore\n\n创建项目时会自动生成，不需要纳入到 CVS 的文件存放于此，它可以限制一些元素在_site 中的生成\n\nGemfile &amp;amp; Gemfile.lock\n\n存放项目所依赖的 Ruby gems，里面拥有存放页面的样式信息，当新加入了主题配置之后，需要使用bundle install指令安装新的配置才能使用。需要使用新的主题时，需要在_config.yml文件的there做更改。注意，使用了新的布局之后可能会导致一些布局不可用，例如“post”，因为在新的主题上可能没有定义这样的布局。所以使用新的布局之后要在_layout中查看一下是否有对应的布局可以使用。\n\nabout.md\n\n会存放有关在界面中的about的内容，生成的页面会出现在主界面上的位置，同理命名其他的文件也会在主界面的上方出现\n\n\n\nmakedown 语法\npermalink\n可以用于自定义所创建页面的URL。例如，permalink：/Jekyll/ 表示创建的页面会在主页面URL中后加上/Jekyll\n\nlayout\n表示自己所使用的界面样式，常见的值有post\n\n._config.yml\n\n\n  defaults：可用于写一些默认值，例如为layout设置默认值（要注意以下冒号的位置）\n    defaults:\n  - \n scope:\n   path: &quot;&quot;  # 这里填写此默认值影响的返回路径\n values:   # 这里补充默认值\n     layout: &quot;post&quot;\n    \n    再例如对图片文件的加载：\n    defaults:\n  -\n scope:\n   path: &quot;assets/img&quot;\n values:\n   image: true\n    \n    该例子表示，在html文件中可能加载图片信息的位置会在，assets/img的文件夹下寻找\n  \n\n\n\n常用指令\n\n  jekyll new 工程名  创建工程\n  bundle exec jekyll server   启动项目，启动项目之后可以在浏览器中访问http://127.0.0.1:400/看到效果。\n  jekyll new PATH --blank  创建新的空项目\n  jekyll build 或 jekyll b 构建项目，生成可部署的 _site 目录\n  jekyll serve 或 jekyll s  构建并运行项目，会自动监听文件变化，不需要反复执行\n  jekyll clean  清除所有的构建产物\n  jekyll new-theme  创建一个新的主题脚手架\n  jekyll doctor  诊断，输出所有已经废弃的依赖包或者有问题的配置\n\n"
} ,
  
  {
    "title"    : "MySql 学习笔记",
    "category" : "",
    "tags"     : " MySql, 数据库",
    "url"      : "/mysql",
    "date"     : "December 3, 2022",
    "excerpt"  : "MySQL是一种关系型数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。\n\n\n前言\n本人比较懒，所以专门挑了一个篇幅比较少的MySql来写博客，主要还是针对笔记的性质来写的。如果有错欢迎指正。\n\n\n\nMySql 基本语法\n1.分组\nGROUP BY 字段名 [HAVING 条件表达式]\n\n2.去重\n在 select的字段前面加上distinct就可以去重\n\n3.插入多行数据\n\n格式：\ninsert into 表名[（字段名1...",
  "content"  : "MySQL是一种关系型数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。\n\n\n前言\n本人比较懒，所以专门挑了一个篇幅比较少的MySql来写博客，主要还是针对笔记的性质来写的。如果有错欢迎指正。\n\n\n\nMySql 基本语法\n1.分组\nGROUP BY 字段名 [HAVING 条件表达式]\n\n2.去重\n在 select的字段前面加上distinct就可以去重\n\n3.插入多行数据\n\n格式：\ninsert into 表名[（字段名1，字段名2,…）] values(值\\(a_1\\)，值\\(b_1\\),…), (值\\(a_2\\),值\\(b_2\\),…)\n\n示例：\ninsert into mywork\nvalues(&quot;小明&quot;,18),(&quot;小红&quot;,20)\n\n\n4.外连接\n语法：\nselect 字段列表 from 表1 [inner] join 表2 on 连接条件;\n示例:\n\nselect * \nfrom wuhan.commercialhousing \njoin secondhouse on district regexp qy\nlimit 10;\n\n\n同理还有左外连接：left join，右外连接：right join\n\n5.排序\n\n排序语句：order by 字段值[ desc | asc]\n其中 asc是表示升序（默认），表示降序\n\n示例：\nselect customer_number\nfrom Orders\ngroup by customer_number\norder by COUNT(*) desc\n\n\n6.if语句\n\n语法：IF(expr1,expr2,expr3)\n\n如果 expr1 是TRUE (或者expr1 &amp;lt;&amp;gt; 0 且 expr1 &amp;lt;&amp;gt; NULL)，则 IF()的返回值为expr2; 否则返回值则为 expr3。IF() 的返回值为数字值或字符串值，具体情况视其所在语境而定。\n\n7.ifnull语句\n\n语法：IFNULL(expr1,expr2)\nexpr1不为NULL，则 IFNULL() 的返回值为expr1; 否则其返回值为 expr2。IFNULL()的返回值是数字或是字符串，具体情况取决于其所使用的语境。\n\n8.正则语句\n\n关键字：regexp\n\n使用语法：被检测字符串 regexp [binary] 正则语句\n不区分大小写（即大写和小写都匹配）。为区分大小写，可以使用 BINARY 关键字例如：\nWHHERE name REGEXP BINARY &#39;Hern .000&#39;\n\n\n9.存在判断语句 exists\n\n当我们只需要判断某些满足特定条件的数据是否存在时，为了提高效率，我们不需要将所有的数据捞出来判断，只需要判断是否存在就可以了。\n采用exists即可满足需求。\n示例：\nselect exists (SELECT *\n        from  a \n        where\n        money&amp;gt;0 and time&amp;gt;&#39;2021-03-05&#39;;\n)\n\n\n10.表格合并\n\nUNION操作符合并两个或多个 SELECT 语句的结果。\nUNION关键字应处于两次查询之间\n默认地，UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL。\n注意：union的优先级低于order by，即先合并再排序。\n示例1：\nSELECT column_name(s) FROM table1\nUNION\nSELECT column_name(s) FROM table2;\n\n示例2：\nSELECT column_name(s) FROM table1\nUNION ALL\nSELECT column_name(s) FROM table2;\n\n\n11.数据修改 update\n语法：\nUPDATE &amp;lt;表名&amp;gt; SET 字段 1=值 1 [,字段 2=值 2… ] \n[WHERE 子句 ]\n[ORDER BY 子句] [LIMIT 子句]\n\n\n\n\nmysql常用函数\n\n日期比较函数：datediff\n\n语法：DATEDIFF(date1,date2)\n参数说明\ndate1: 比较日期1\ndate2: 比较日期2\n\nDATEDIFF函数返回date1 - date2的计算结果，date1和date2两个参数需是有效的日期或日期时间值;如果参数传递的是日期时间值，DATEDIFF函数仅将日期部分用于计算，并忽略时间部分(只有值的日期部分参与计算)\n\n示例：\nSELECT DATEDIFF(&#39;2022-04-29&#39;,&#39;2022-04-30&#39;); --返回 -1\nSELECT DATEDIFF(&#39;2022-04-30&#39;,&#39;2022-04-29&#39;); --返回 1\n\n\n日期加减函数：date_add\n\n语法：date_add(‘某个日期时间’,interval 1 时间种类名)\n示例：\n\nselect date_add(data, interval 1 year); --加1年\nselect date_add(fata, interval 1 month); --加1月\n\n\nquarter:季，week:周，day:天，hour:小时，minute:分钟，second:秒，microsecond:毫秒\n注：也可以不用变量，直接加减某个时间，如：select date_add(‘1998-01-01’, interval 1 day);\n\n字符串专题\n字符串拼接：concat\n\n将给入的参数逐一拼接\n例如：\nconcat(‘%’,’abc’,’%’) --结果为%abc%\n\n字符串与日期的相互转换\n使用语法：\nDATE_FORMAT(date,format) 日期转字符串\nSTR_TO_DATE(str,format) 字符串转日期\n示例：\n\nselect DATE_FORMAT(now(),&#39;%Y-%m-%d %H:%i:%s&#39;);\n\n返回：2022-12-01 10:07:41\n\nselect str_to_date(&#39;2022-8-7&#39;,&#39;%Y&#39;)\n\n返回：2022-00-00\n因为这里只获取到了年份，但是作为datetime对象需要补全月份和日所以会有-00-00出现。\n\n组内字符串拼接 group_concat\n\n语法：\nGROUP_CONCAT([DISTINCT] column1 [ORDER BY column2 ASC|DESC] [SEPARATOR seq])\n\n\n将分组中column1这一列对应的多行的值按照column2 升序或者降序进行连接，其中分隔符为seq\n如果用到了DISTINCT，将表示将不重复的column1按照column2升序或者降序连接\n如果没有指定SEPARATOR的话，也就是说没有写，那么就会默认以 ‘,’分隔\n\n字符串截取 substring\n语法格式：SUBSTRING(str, begin, end)\nsubstring函数可以将字符串str从下标begin到end截取下来（下标从1开始计算）（闭区间包括begin和end），其中end默认为空，当end省略时表示截取到字符串最后。\nmysq支持逆向访问，即可以使用负数表示下标，负数的下标即从右边开始计算的下标。\n示例：\nselect substring(&quot;01234&quot;,1,2);\t-- 01\nselect substring(&quot;01234&quot;,1);\t-- 01234\nselect substring(&quot;01234&quot;,1,100); -- 01234\nselect substring(&quot;01234&quot;,-1);\t-- 4\n\n\n字符串大小写转换\nupper(str)  字符串中所有字母转大写\nlower(str)  字符串中所有字母转小写\n\n\n\n技巧语法\n\n查询排名前n的数据\n\n使用limit n语句实现（该语句需要放在查询结果的最后）\n\n示例：\n\nSELECT * FROM wuhan.secondhouse limit 10;\n\n\n使用正则配对字符串\n\n使用regexp关键字实现\n格式： 字段值 regexp 正则字符串\n示例：\n\nselect distinct district,house_type,wq_area,wq_num,yqy_area,yqy_num\nfrom commercialhousing\nwhere district regexp &#39;江岸&#39;;\n\n"
} 
  
  
  
]
